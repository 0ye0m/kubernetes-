// +build !windows

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package master

import (
	"bytes"
	"crypto/aes"
	"encoding/binary"
	"fmt"
	"strings"
	"testing"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/apiserver/pkg/storage/value"
	aestransformer "k8s.io/apiserver/pkg/storage/value/encrypt/aes"
	kmsapi "k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1"
)

const (
	kmsPrefix     = "k8s:enc:kms:v1:grpc-kms-provider:"
	dekKeySizeLen = 2

	kmsConfigYAML = `
kind: EncryptionConfig
apiVersion: v1
resources:
  - resources:
    - secrets
    providers:
    - kms:
       name: grpc-kms-provider
       endpoint: unix:///@kms-provider.sock
`
)

// rawDEKKEKSecret provides operations for working with secrets transformed with Data Encryption Key(DEK) Key Encryption Kye(KEK) envelop.
type rawDEKKEKSecret []byte

func (r rawDEKKEKSecret) getDEKLen() int {
	// DEK's length is stored in the two bytes that follow the prefix.
	return int(binary.BigEndian.Uint16(r[len(kmsPrefix) : len(kmsPrefix)+dekKeySizeLen]))
}

func (r rawDEKKEKSecret) getDEK() []byte {
	return r[len(kmsPrefix)+dekKeySizeLen : len(kmsPrefix)+dekKeySizeLen+r.getDEKLen()]
}

func (r rawDEKKEKSecret) getStartOfPayload() int {
	return len(kmsPrefix) + dekKeySizeLen + r.getDEKLen()
}

func (r rawDEKKEKSecret) getPayload() []byte {
	return r[r.getStartOfPayload():]
}

// TestKMSProvider is an integration test between KubAPI, ETCD and KMS Plugin
// Concretely, this test verifies the following integration contracts:
// 1. Raw records in ETCD that were processed by KMS Provider should be prefixed with k8s:enc:kms:v1:grpc-kms-provider-name:
// 2. Data Encryption Key (DEK) should be generated by envelopeTransformer and passed to KMS gRPC Plugin
// 3. KMS gRPC Plugin should encrypt the DEK with a Key Encryption Key (KEK) and pass it back to envelopeTransformer
// 4. The payload (ex. Secret) should be encrypted via AES CBC transform
// 5. Prefix-EncryptedDEK-EncryptedPayload structure should be deposited to ETCD
func TestKMSProvider(t *testing.T) {
	pluginMock, test := mustSetupTest(t)
	defer pluginMock.cleanUp()
	defer test.cleanUp()

	secretETCDPath := test.getETCDPath()
	var rawSecretAsSeenByETCD rawDEKKEKSecret
	rawSecretAsSeenByETCD, err := test.getRawSecretFromETCD()
	if err != nil {
		t.Fatalf("failed to read %s from etcd: %v", secretETCDPath, err)
	}

	if !bytes.HasPrefix(rawSecretAsSeenByETCD, []byte(kmsPrefix)) {
		t.Fatalf("expected secret to be prefixed with %s, but got %s", kmsPrefix, rawSecretAsSeenByETCD)
	}

	// Since Data Encryption Key (DEK) is randomly generated (per encryption operation), we need to ask KMS Mock for it.
	dekPlainAsSeenByKMS, err := getDEKFromKMSPlugin(pluginMock)
	if err != nil {
		t.Fatalf("failed to get DEK from KMS: %v", err)
	}

	// KMS Mock uses base64 encoding to simulate encryption.
	decryptResponse, err := base64Decode(&kmsapi.DecryptRequest{Version: kmsAPIVersion, Cipher: rawSecretAsSeenByETCD.getDEK()})
	if err != nil {
		t.Fatalf("failed to decrypt DEK, %v", err)
	}
	dekPlainAsWouldBeSeenByETCD := decryptResponse.Plain

	if !bytes.Equal(dekPlainAsSeenByKMS, dekPlainAsWouldBeSeenByETCD) {
		t.Fatalf("expected dekPlainAsSeenByKMS %v to be passed to KMS Plugin, but got %s",
			dekPlainAsSeenByKMS, dekPlainAsWouldBeSeenByETCD)
	}

	plainSecret, err := decryptPayload(dekPlainAsWouldBeSeenByETCD, rawSecretAsSeenByETCD, secretETCDPath)
	if err != nil {
		t.Fatalf("failed to transform from storage via AESCBC, err: %v", err)
	}

	if !strings.Contains(string(plainSecret), secretVal) {
		t.Fatalf("expected %q after decryption, but got %q", secretVal, string(plainSecret))
	}

	// Secrets should be un-enveloped on direct reads from Kube API Server.
	mustReadSecret(t, test, true)
	test.printMetrics()
}

// TestKMSFailureImpactOnReads validates that KMS Plugin will not be called for secrets that were cached by api-server\pkg\storage\cacher.go
// Cacher.go (assuming sufficient memory) should intercept requests for secrets that were recently created or recently retrieved - thus
// alleviating the need for caching within envelop.go.
func TestKMSFailureImpactOnReads(t *testing.T) {
	pluginMock, test := mustSetupTest(t)
	defer pluginMock.cleanUp()
	defer test.cleanUp()

	pluginMock.gracefulStop()
	// Expect hit - cache was populated when the test secret was created (i.e. cacher.go has a cached version of the secret in plain text).
	mustReadSecret(t, test, false)
}

func mustSetupTest(t *testing.T) (*base64Plugin, *transformTest) {
	pluginMock, err := NewBase64Plugin()
	if err != nil {
		t.Fatalf("failed to create mock of KMS Plugin: %v", err)
	}

	test, err := newTransformTest(t, kmsConfigYAML)
	if err != nil {
		pluginMock.cleanUp()
		t.Fatalf("failed to start KUBE API Server with encryptionConfig\n %s", kmsConfigYAML)
	}

	// As part of newTransformTest a new secret was created, so KMS Mock should have been exercised by this point.
	if len(pluginMock.errorChan) != 0 {
		pluginMock.cleanUp()
		test.cleanUp()
		t.Fatalf("KMSPlugin failed while serving requests: %v", <-pluginMock.errorChan)
	}

	// Ensuring that the test secret has been cached - written to etcd and read back by cacher.
	pollErr := wait.PollImmediate(1*time.Second, wait.ForeverTestTimeout, func() (bool, error) {
		_, err := test.restClient.CoreV1().Secrets(test.ns.Name).Get(test.secret.Name, metav1.GetOptions{ResourceVersion: "0"})
		return err == nil, nil
	})

	if pollErr == wait.ErrWaitTimeout {
		pluginMock.cleanUp()
		test.cleanUp()
		t.Fatalf("failed to retrieve secret from cache within the alloted time period: %d", wait.ForeverTestTimeout)
	}

	return pluginMock, test
}

func mustReadSecret(t *testing.T, test *transformTest, bypassCache bool) {
	// ResourceVersion 0 implies cache will be checked, "" implies that cache will be bypassed.
	resourceVersion := "0"
	if bypassCache {
		resourceVersion = ""
	}

	s, err := test.restClient.CoreV1().Secrets(test.ns.Name).Get(test.secret.Name, metav1.GetOptions{ResourceVersion: resourceVersion})
	if err != nil {
		t.Fatalf("failed to get %s, error: %v", test.secret.Name, err)
	}
	if secretVal != string(s.Data[secretKey]) {
		t.Fatalf("expected %s from KubeAPI, but got %s", secretVal, string(s.Data[secretKey]))
	}
}

func getDEKFromKMSPlugin(pluginMock *base64Plugin) ([]byte, error) {
	select {
	case e := <-pluginMock.encryptRequest:
		return e.Plain, nil
	case <-time.After(wait.ForeverTestTimeout):
		return nil, fmt.Errorf("expected encryptRequest to be received by KMS Plugin within %v", wait.ForeverTestTimeout)
	}
}

func decryptPayload(key []byte, secret rawDEKKEKSecret, secretETCDPath string) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize AES Cipher: %v", err)
	}
	// etcd path of the key is used as the authenticated context - need to pass it to decrypt
	ctx := value.DefaultContext([]byte(secretETCDPath))
	aescbcTransformer := aestransformer.NewCBCTransformer(block)
	plainSecret, _, err := aescbcTransformer.TransformFromStorage(secret.getPayload(), ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to transform from storage via AESCBC, err: %v", err)
	}

	return plainSecret, nil
}
