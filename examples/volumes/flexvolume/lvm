#!/bin/sh

# Copyright 2015 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

usage() {
	err "Invalid usage. Usage: "
	err "\t$0 init"
	err "\t$0 attach <json params> <hostname>"
	err "\t$0 getvolumename <json params>"
	err "\t$0 waitforattach <json params>"
	err "\t$0 mountdevice <json params> <mount device> <mount path>"
	err "\t$0 unmountdevice <mount device>"
	err "\t$0 detach <mount device> <hostname>"
	err "\t$0 waitfordetach <mount device>"
	err "\t$0 mount <json params> <mount device> <mount path>"
	err "\t$0 unmount <mount path>"
	exit 1
}

err() {
	echo -ne $* 1>&2
}

log() {
	echo -ne $* >&1
}

# Check whether the path is mounted.
ismounted() {
	MOUNT=`findmnt -n ${MNTPATH} 2>/dev/null | cut -d' ' -f1`
	if [ "${MOUNT}" == "${MNTPATH}" ]; then
		echo "1"
	else
		echo "0"
	fi
}

# Attach the LVM volume. This call just imitates the attach call and cannot
# remotely check whether the volume exists on the Kubelet node.
attach() {
	DMDEV=
	VOLUMEID=$(echo $1 | awk -F "volumeID" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")
	VG=$(echo $1 | awk -F "volumegroup" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")
	SIZE=$(echo $1 | awk -F "size" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")

	# LVM substitutes - with --
	VOLUMEID=`echo $VOLUMEID|sed s/-/--/g`
	VG=`echo $VG|sed s/-/--/g`

	DMDEV="/dev/mapper/${VG}-${VOLUMEID}"

	# Return the device path.
	log "{\"status\": \"Success\", \"device\":\"${DMDEV}\"}"
}

# Wait for volume to attach on the Kubelet node. This call just imitates the
# call.
waitforattach() {
	attach $*
}

# Get globally unique volume name.
getvolumename() {
	VOLUMEID=$(echo $1 | awk -F "volumeID" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")
	VG=$(echo $1 | awk -F "volumegroup" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")

	# LVM substitutes - with --
	VOLUMEID=`echo $VOLUMEID|sed s/-/--/g`
	VG=`echo $VG|sed s/-/--/g`

	# In this simple example, volume name is not cluster wide unique. The framework
	# actually expects volume name to be unique.
	VOLUMENAME="${VG}-${VOLUMEID}"
	log "{\"status\": \"Success\", \"device\":\"${VOLUMENAME}\"}"

}

# Detach the volume.
detach() {
	log "{\"status\": \"Success\"}"
}

# Bind mount the volume.
domount() {
	OPTIONS=$1
	SRC=$2
	DEST=$3

	if [ ! -d "$SRC" ]; then
		err "{\"status\": \"Failure\", \"message\": \"${SRC} directory does not exist\"}"
		exit 1
	fi

	mkdir -p ${DEST} &> /dev/null

	mount --bind ${SRC} ${DEST} &> /dev/null
	if [ $? -ne 0 ]; then
		err "{ \"status\": \"Failure\", \"message\": \"Failed to bind mount ${SRC} at ${DEST}\"}"
		exit 1
	fi
	log "{\"status\": \"Success\"}"
}

# Mount the device at a global path. Individual pods will then bind mount this
# path.
mountdevice() {
	FSTYPE=$(echo $1 |awk -F "kubernetes.io/fsType" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")
	DMDEV=$2
	MNTPATH=$3
	RW=$(echo $1 |awk -F "kubernetes.io/readwrite" '{print $2}'|awk -F"," '{print $1}'|tr -d "\":}")

	if [ ! -b "${DMDEV}" ]; then
		err "{\"status\": \"Failure\", \"message\": \"${DMDEV} does not exist\"}"
		exit 1
	fi

	if [ $(ismounted) -eq 1 ] ; then
		log "{\"status\": \"Success\"}"
		exit 0
	fi

	VOLFSTYPE=`blkid -o udev ${DMDEV} 2>/dev/null|grep "ID_FS_TYPE"|cut -d"=" -f2`
	if [ "${VOLFSTYPE}" == "" ]; then
		mkfs -t ${FSTYPE} ${DMDEV} >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			err "{ \"status\": \"Failure\", \"message\": \"Failed to create fs ${FSTYPE} on device ${DMDEV}\"}"
			exit 1
		fi
	fi

	mkdir -p ${MNTPATH} &> /dev/null

	mount -o ${RW} ${DMDEV} ${MNTPATH} &> /dev/null
	if [ $? -ne 0 ]; then
		err "{ \"status\": \"Failure\", \"message\": \"Failed to mount device ${DMDEV} at ${MNTPATH}\"}"
		exit 1
	fi
	log "{\"status\": \"Success\"}"
}

# Unmount
unmount() {
	MNTPATH=$1
	if [ $(ismounted) -eq 0 ] ; then
		log "{\"status\": \"Success\"}"
		exit 0
	fi

	umount ${MNTPATH} &> /dev/null
	if [ $? -ne 0 ]; then
		err "{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at ${MNTPATH}\"}"
		exit 1
	fi

	log "{\"status\": \"Success\"}"
}

op=$1

if [ "$op" = "init" ]; then
	log "{\"status\": \"Success\"}"
	exit 0
fi

if [ $# -lt 2 ]; then
	usage
fi

shift

case "$op" in
	attach|waitforattach)
		attach $*
		;;

	getdevicename)
		getdevicename $*
		;;
	getvolumename)
		getvolumename $*
		;;
	detach)
		detach $*
		;;
	mountdevice)
		mountdevice $*
		;;
	mount)
		domount $*
		;;
	unmount|unmountdevice)
		unmount $*
		;;
	help)
		usage
		;;
	getdevicemountpath|*)
		log "{\"status\": \"Not supported\"}"
		;;
esac

exit 0
