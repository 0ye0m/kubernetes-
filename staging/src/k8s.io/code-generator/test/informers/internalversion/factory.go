/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was automatically generated by informer-gen

package internalversion

import (
	"github.com/golang/glog"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	cache "k8s.io/client-go/tools/cache"
	internal "k8s.io/code-generator/test/clientset/internal"
	internalinterfaces "k8s.io/code-generator/test/informers/internalversion/internalinterfaces"
	testgroup "k8s.io/code-generator/test/informers/internalversion/testgroup"
	reflect "reflect"
	"runtime/debug"
	sync "sync"
	time "time"
)

type sharedInformerFactory struct {
	client        internal.Interface
	defaultResync time.Duration

	// lock guards informers, started, startedInformers, stopCh
	lock             sync.Mutex
	informers        map[reflect.Type]cache.SharedIndexInformer
	started          bool
	startedInformers map[reflect.Type]bool
	stopCh           <-chan struct{}
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory
func NewSharedInformerFactory(client internal.Interface, defaultResync time.Duration) SharedInformerFactory {
	return &sharedInformerFactory{
		client:           client,
		defaultResync:    defaultResync,
		informers:        make(map[reflect.Type]cache.SharedIndexInformer),
		startedInformers: make(map[reflect.Type]bool),
	}
}

// Start initializes all requested informers.
func (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {
	f.lock.Lock()
	defer f.lock.Unlock()

	if f.started {
		glog.Warning("Invalid attempt to try to start the shared informer factory multiple times. This is a no-op but you should remove this invocation")
		debug.PrintStack()
		return
	}

	f.stopCh = stopCh

	for informerType, informer := range f.informers {
		if !f.startedInformers[informerType] {
			go informer.Run(f.stopCh)
			f.startedInformers[informerType] = true
		}
	}

	f.started = true
}

// WaitForCacheSync waits for all started informers' cache were synced.
func (f *sharedInformerFactory) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
	informers := func() map[reflect.Type]cache.SharedIndexInformer {
		f.lock.Lock()
		defer f.lock.Unlock()

		informers := map[reflect.Type]cache.SharedIndexInformer{}
		for informerType, informer := range f.informers {
			if f.startedInformers[informerType] {
				informers[informerType] = informer
			}
		}
		return informers
	}()

	res := map[reflect.Type]bool{}
	for informType, informer := range informers {
		res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
	}
	return res
}

// InformerFor returns the SharedIndexInformer for obj. If the factory has already been started and
// this is the first time this particular informer has been referenced, the informer will be
// automatically started. Otherwise, the informer will be started when Start() is invoked.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {
	f.lock.Lock()
	defer f.lock.Unlock()

	informerType := reflect.TypeOf(obj)
	informer, exists := f.informers[informerType]
	if exists {
		return informer
	}

	informer = newFunc(f.client, f.defaultResync)
	f.informers[informerType] = informer

	if f.started {
		go informer.Run(f.stopCh)
		f.startedInformers[informerType] = true
	}

	return informer
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
type SharedInformerFactory interface {
	internalinterfaces.SharedInformerFactory
	ForResource(resource schema.GroupVersionResource) (GenericInformer, error)
	WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool

	Testgroup() testgroup.Interface
}

func (f *sharedInformerFactory) Testgroup() testgroup.Interface {
	return testgroup.New(f)
}
