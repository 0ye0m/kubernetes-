/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

// This file contains a collection of methods that can be used from go-restful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored.
//
// Those methods can be generated by using hack/update-generated-swagger-docs.sh

// AUTO-GENERATED FUNCTIONS START HERE. DO NOT EDIT.
var map_Extender = map[string]string{
	"":                 "Extender holds the parameters used to communicate with the extender. If a verb is unspecified/empty, it is assumed that the extender chose not to provide that extension.",
	"urlPrefix":        "URLPrefix at which the extender is available",
	"filterVerb":       "Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.",
	"preemptVerb":      "Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.",
	"prioritizeVerb":   "Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.",
	"weight":           "The numeric multiplier for the node scores that the prioritize call generates. The weight should be a positive integer",
	"bindVerb":         "Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender. If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender can implement this function.",
	"enableHttps":      "EnableHTTPS specifies whether https should be used to communicate with the extender",
	"tlsConfig":        "TLSConfig specifies the transport layer security config",
	"httpTimeout":      "HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize timeout is ignored, k8s/other extenders priorities are used to select the node.",
	"nodeCacheCapable": "NodeCacheCapable specifies that the extender is capable of caching node information, so the scheduler should only send minimal information about the eligible nodes assuming that the extender already cached full details of all nodes in the cluster",
	"managedResources": "ManagedResources is a list of extended resources that are managed by this extender. - A pod will be sent to the extender on the Filter, Prioritize and Bind\n  (if the extender is the binder) phases iff the pod requests at least\n  one of the extended resources in this list. If empty or unspecified,\n  all pods will be sent to this extender.\n- If IgnoredByScheduler is set to true for a resource, kube-scheduler\n  will skip checking the resource in predicates.",
	"ignorable":        "Ignorable specifies if the extender is ignorable, i.e. scheduling should not fail when the extender returns an error or is not reachable.",
}

func (Extender) SwaggerDoc() map[string]string {
	return map_Extender
}

var map_ExtenderManagedResource = map[string]string{
	"":                   "ExtenderManagedResource describes the arguments of extended resources managed by an extender.",
	"name":               "Name is the extended resource name.",
	"ignoredByScheduler": "IgnoredByScheduler indicates whether kube-scheduler should ignore this resource when applying predicates.",
}

func (ExtenderManagedResource) SwaggerDoc() map[string]string {
	return map_ExtenderManagedResource
}

var map_ExtenderTLSConfig = map[string]string{
	"":           "ExtenderTLSConfig contains settings to enable TLS with extender",
	"insecure":   "Server should be accessed without verifying the TLS certificate. For testing only.",
	"serverName": "ServerName is passed to the server for SNI and is used in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.",
	"certFile":   "Server requires TLS client certificate authentication",
	"keyFile":    "Server requires TLS client certificate authentication",
	"caFile":     "Trusted root certificates for server",
	"certData":   "CertData holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile",
	"keyData":    "KeyData holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile",
	"caData":     "CAData holds PEM-encoded bytes (typically read from a root certificates bundle). CAData takes precedence over CAFile",
}

func (ExtenderTLSConfig) SwaggerDoc() map[string]string {
	return map_ExtenderTLSConfig
}

var map_LabelPreference = map[string]string{
	"":         "LabelPreference holds the parameters that are used to configure the corresponding priority function",
	"label":    "Used to identify node \"groups\"",
	"presence": "This is a boolean flag If true, higher priority is given to nodes that have the label If false, higher priority is given to nodes that do not have the label",
}

func (LabelPreference) SwaggerDoc() map[string]string {
	return map_LabelPreference
}

var map_LabelsPresence = map[string]string{
	"":         "LabelsPresence holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.",
	"labels":   "The list of labels that identify node \"groups\" All of the labels should be either present (or absent) for the node to be considered a fit for hosting the pod",
	"presence": "The boolean flag that indicates whether the labels should be present or absent from the node",
}

func (LabelsPresence) SwaggerDoc() map[string]string {
	return map_LabelsPresence
}

var map_Policy = map[string]string{
	"":                               "Policy describes a struct for a policy resource used in api.",
	"predicates":                     "Holds the information to configure the fit predicate functions",
	"priorities":                     "Holds the information to configure the priority functions",
	"extenders":                      "Holds the information to communicate with the extender(s)",
	"hardPodAffinitySymmetricWeight": "RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule corresponding to every RequiredDuringScheduling affinity rule. HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 1-100.",
	"alwaysCheckAllPredicates":       "When AlwaysCheckAllPredicates is set to true, scheduler checks all the configured predicates even after one or more of them fails. When the flag is set to false, scheduler skips checking the rest of the predicates after it finds one predicate that failed.",
}

func (Policy) SwaggerDoc() map[string]string {
	return map_Policy
}

var map_PredicateArgument = map[string]string{
	"":                "PredicateArgument represents the arguments to configure predicate functions in scheduler policy configuration. Only one of its members may be specified",
	"serviceAffinity": "The predicate that provides affinity for pods belonging to a service It uses a label to identify nodes that belong to the same \"group\"",
	"labelsPresence":  "The predicate that checks whether a particular node has a certain label defined or not, regardless of value",
}

func (PredicateArgument) SwaggerDoc() map[string]string {
	return map_PredicateArgument
}

var map_PredicatePolicy = map[string]string{
	"":         "PredicatePolicy describes a struct of a predicate policy.",
	"name":     "Identifier of the predicate policy For a custom predicate, the name can be user-defined For the Kubernetes provided predicates, the name is the identifier of the pre-defined predicate",
	"argument": "Holds the parameters to configure the given predicate",
}

func (PredicatePolicy) SwaggerDoc() map[string]string {
	return map_PredicatePolicy
}

var map_PriorityArgument = map[string]string{
	"":                                  "PriorityArgument represents the arguments to configure priority functions in scheduler policy configuration. Only one of its members may be specified",
	"serviceAntiAffinity":               "The priority function that ensures a good spread (anti-affinity) for pods belonging to a service It uses a label to identify nodes that belong to the same \"group\"",
	"labelPreference":                   "The priority function that checks whether a particular node has a certain label defined or not, regardless of value",
	"requestedToCapacityRatioArguments": "The RequestedToCapacityRatio priority function is parametrized with function shape.",
}

func (PriorityArgument) SwaggerDoc() map[string]string {
	return map_PriorityArgument
}

var map_PriorityPolicy = map[string]string{
	"":         "PriorityPolicy describes a struct of a priority policy.",
	"name":     "Identifier of the priority policy For a custom priority, the name can be user-defined For the Kubernetes provided priority functions, the name is the identifier of the pre-defined priority function",
	"weight":   "The numeric multiplier for the node scores that the priority function generates The weight should be non-zero and can be a positive or a negative integer",
	"argument": "Holds the parameters to configure the given priority function",
}

func (PriorityPolicy) SwaggerDoc() map[string]string {
	return map_PriorityPolicy
}

var map_RequestedToCapacityRatioArguments = map[string]string{
	"":      "RequestedToCapacityRatioArguments holds arguments specific to RequestedToCapacityRatio priority function.",
	"shape": "Array of point defining priority function shape.",
}

func (RequestedToCapacityRatioArguments) SwaggerDoc() map[string]string {
	return map_RequestedToCapacityRatioArguments
}

var map_ResourceSpec = map[string]string{
	"":       "ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.",
	"name":   "Name of the resource to be managed by RequestedToCapacityRatio function.",
	"weight": "Weight of the resource.",
}

func (ResourceSpec) SwaggerDoc() map[string]string {
	return map_ResourceSpec
}

var map_ServiceAffinity = map[string]string{
	"":       "ServiceAffinity holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.",
	"labels": "The list of labels that identify node \"groups\" All of the labels should match for the node to be considered a fit for hosting the pod",
}

func (ServiceAffinity) SwaggerDoc() map[string]string {
	return map_ServiceAffinity
}

var map_ServiceAntiAffinity = map[string]string{
	"":      "ServiceAntiAffinity holds the parameters that are used to configure the corresponding priority function",
	"label": "Used to identify node \"groups\"",
}

func (ServiceAntiAffinity) SwaggerDoc() map[string]string {
	return map_ServiceAntiAffinity
}

var map_UtilizationShapePoint = map[string]string{
	"":            "UtilizationShapePoint represents single point of priority function shape.",
	"utilization": "Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.",
	"score":       "Score assigned to given utilization (y axis). Valid values are 0 to 10.",
}

func (UtilizationShapePoint) SwaggerDoc() map[string]string {
	return map_UtilizationShapePoint
}

// AUTO-GENERATED FUNCTIONS END HERE
