/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package audit

import (
	"context"
	"github.com/stretchr/testify/assert"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apiserver/pkg/authentication/user"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	authnv1 "k8s.io/api/authentication/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	auditinternal "k8s.io/apiserver/pkg/apis/audit"
	"k8s.io/apiserver/pkg/authorization/authorizer"
	"k8s.io/apiserver/pkg/endpoints/request"
	"k8s.io/client-go/kubernetes/scheme"
)

func TestLogAnnotation(t *testing.T) {
	ev := &auditinternal.Event{
		Level:   auditinternal.LevelMetadata,
		AuditID: "fake id",
	}
	LogAnnotation(ev, "foo", "bar")
	LogAnnotation(ev, "foo", "baz")
	assert.Equal(t, "bar", ev.Annotations["foo"], "audit annotation should not be overwritten.")

	LogAnnotation(ev, "qux", "")
	LogAnnotation(ev, "qux", "baz")
	assert.Equal(t, "", ev.Annotations["qux"], "audit annotation should not be overwritten.")
}

func TestMaybeTruncateUserAgent(t *testing.T) {
	req := &http.Request{}
	req.Header = http.Header{}

	ua := "short-agent"
	req.Header.Set("User-Agent", ua)
	assert.Equal(t, ua, maybeTruncateUserAgent(req))

	ua = ""
	for i := 0; i < maxUserAgentLength*2; i++ {
		ua = ua + "a"
	}
	req.Header.Set("User-Agent", ua)
	assert.NotEqual(t, ua, maybeTruncateUserAgent(req))
}

func TestNewEventFromRequest(t *testing.T) {
	var (
		testTime   = time.Now()
		userAgent  = "test-event"
		remoteAddr = "127.0.0.1"
		auditID    = types.UID("test-event-id")
		superuser  = &user.DefaultInfo{Name: "superuser", Groups: []string{"system:masters"}, Extra: map[string][]string{"foo": {"bar"}}}
	)

	testCases := []requestToEvent{
		{
			// Do not LogAnnotation if no level
			desc: "no-auditID no-level",
			Verb: "GET",
			Path: "/version",
			attributes: &authorizer.AttributesRecord{
				Path:            "/version",
				Verb:            "get",
				ResourceRequest: false,
			},
			annotations: []annotation{
				{
					key:   "foo",
					value: "bar",
				},
			},
			// If the context does not contain auditID,
			// NewEventFromRequest will be generated by uuid.New()
			expectedEvent: &auditinternal.Event{
				AuditID: "",
			},
		},
		{
			desc:    "resource",
			Verb:    "POST",
			Path:    "/api/v1/nodes/mynode",
			level:   auditinternal.LevelRequest,
			auditID: auditID,
			attributes: &authorizer.AttributesRecord{
				User:            superuser,
				Verb:            "create",
				Path:            "/api/v1/nodes/mynode",
				ResourceRequest: true,
				Resource:        "nodes",
				APIVersion:      "v1",
				Name:            "mynode",
			},
			annotations: []annotation{
				{
					key:   "foo",
					value: "bar",
				},
			},
			expectedEvent: &auditinternal.Event{
				RequestURI:               "/api/v1/nodes/mynode",
				Verb:                     "create",
				Level:                    auditinternal.LevelRequest,
				AuditID:                  auditID,
				SourceIPs:                []string{remoteAddr},
				UserAgent:                userAgent,
				User:                     authnv1.UserInfo{Username: "superuser", Groups: []string{"system:masters"}, Extra: map[string]authnv1.ExtraValue{"foo": {"bar"}}},
				RequestReceivedTimestamp: metav1.NewMicroTime(testTime),
				ObjectRef: &auditinternal.ObjectReference{
					Name:       "mynode",
					Resource:   "nodes",
					APIGroup:   "",
					APIVersion: "v1",
				},
				Annotations: map[string]string{
					"foo": "bar",
				},
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.desc, func(t *testing.T) {
			gotEvent := newTestRequest(tc, remoteAddr, userAgent, testTime)

			if len(tc.auditID) == 0 {
				assert.NotEmpty(t, gotEvent.AuditID)
				return
			}
			assert.Equal(t, tc.expectedEvent, gotEvent)
		})
	}
}

type requestToEvent struct {
	desc          string
	Verb          string
	Path          string
	attributes    *authorizer.AttributesRecord
	level         auditinternal.Level
	auditID       types.UID
	annotations   []annotation
	expectedEvent *auditinternal.Event
}

func newTestRequest(rte requestToEvent, remoteAddr, userAgent string, timestamp time.Time) (gotEvent *auditinternal.Event) {
	req, _ := http.NewRequest(rte.Verb, rte.Path, nil)
	req.RemoteAddr = remoteAddr
	req.Header = http.Header{}
	req.Header.Set("User-Agent", userAgent)
	ctx := req.Context()

	// context contains or does not contain auditID
	ctx = request.WithAuditID(ctx, rte.auditID)

	// context contains or does not contain annotations
	if len(rte.annotations) != 0 {
		ctx = context.WithValue(ctx, auditAnnotationsKey, &rte.annotations)
	}
	req = req.WithContext(ctx)

	handler := http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		gotEvent, _ = NewEventFromRequest(req, timestamp, rte.level, rte.attributes)
	})
	handler.ServeHTTP(httptest.NewRecorder(), req)
	return gotEvent
}

func TestLogRequestObject(t *testing.T) {
	expTime := int64(time.Hour.Seconds())
	testCases := []struct {
		desc        string
		auditEvent  *auditinternal.Event
		obj         runtime.Object
		objGV       schema.GroupVersion
		sourceGVR   schema.GroupVersionResource
		subResource string
		expectEvent *auditinternal.Event
	}{
		{
			desc:        "auditEvent is nil",
			auditEvent:  nil,
			expectEvent: nil,
		},
		{
			desc: "encodeObject error",
			auditEvent: &auditinternal.Event{
				Level:     auditinternal.LevelRequest,
				ObjectRef: nil,
			},
			obj: &authnv1.TokenReview{
				Spec: authnv1.TokenReviewSpec{
					Token:     "foo",
					Audiences: []string{"k8s", "api"},
				},
			},
			objGV:     schema.GroupVersion{Group: "authentication.k8s.io", Version: "v2"},
			sourceGVR: schema.GroupVersionResource{Group: "authentication.k8s.io", Version: "v1", Resource: "tokenReviews"},
			expectEvent: &auditinternal.Event{
				Level: auditinternal.LevelMetadata,
				ObjectRef: &auditinternal.ObjectReference{
					Resource:   "tokenReviews",
					APIGroup:   "authentication.k8s.io",
					APIVersion: "v1",
				},
			},
		},
		{
			desc: "log resource at LevelMetadata",
			auditEvent: &auditinternal.Event{
				Level:     auditinternal.LevelMetadata,
				ObjectRef: nil,
			},
			obj: &authnv1.TokenReview{
				Spec: authnv1.TokenReviewSpec{
					Token:     "foo",
					Audiences: []string{"k8s", "api"},
				},
			},
			objGV:     schema.GroupVersion{Group: "authentication.k8s.io", Version: "v1"},
			sourceGVR: schema.GroupVersionResource{Group: "authentication.k8s.io", Version: "v1", Resource: "tokenReviews"},
			expectEvent: &auditinternal.Event{
				Level: auditinternal.LevelMetadata,
				ObjectRef: &auditinternal.ObjectReference{
					Resource:   "tokenReviews",
					APIGroup:   "authentication.k8s.io",
					APIVersion: "v1",
				},
			},
		},
		{
			desc: "log cross-group subResource at LevelRequest",
			auditEvent: &auditinternal.Event{
				Level: auditinternal.LevelRequest,
				// gvr is not in ObjectRef
				ObjectRef: nil,
			},
			obj: &authnv1.TokenRequest{
				Spec: authnv1.TokenRequestSpec{
					ExpirationSeconds: &expTime,
				},
				Status: authnv1.TokenRequestStatus{
					Token:               "foo",
					ExpirationTimestamp: metav1.Time{Time: time.Now().Add(3600 * time.Second)},
				},
			},
			objGV:       schema.GroupVersion{Group: "authentication.k8s.io", Version: "v1"},
			sourceGVR:   schema.GroupVersionResource{Group: "", Version: "v1", Resource: "serviceaccounts"},
			subResource: "token",
			expectEvent: &auditinternal.Event{
				Level: auditinternal.LevelRequest,
				ObjectRef: &auditinternal.ObjectReference{
					Resource:    "serviceaccounts",
					APIGroup:    "",
					APIVersion:  "v1",
					Subresource: "token",
				},
			},
		},
	}
	for _, tc := range testCases {
		t.Run(tc.desc, func(t *testing.T) {
			LogRequestObject(tc.auditEvent, tc.obj, tc.objGV, tc.sourceGVR, tc.subResource, scheme.Codecs)

			// encodeObject error
			if tc.desc == "encodeObject error" {
				assert.Empty(t, tc.auditEvent.RequestObject)
				assert.Equal(t, tc.expectEvent.ObjectRef, tc.auditEvent.ObjectRef)
				return
			}
			//cross-group subResources can be converted correctly after #102040
			if tc.desc == "log cross-group subResource at LevelRequest" {
				assert.NotEmpty(t, tc.auditEvent.RequestObject)
				assert.Equal(t, tc.expectEvent.ObjectRef, tc.auditEvent.ObjectRef)
				return
			}
			assert.Equal(t, tc.expectEvent, tc.auditEvent)
		})
	}
}
