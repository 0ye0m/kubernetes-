/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// set-gen is an example usage of go2idl.
package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"k8s.io/kubernetes/cmd/libs/go2idl/generator"
	"k8s.io/kubernetes/cmd/libs/go2idl/namer"
	"k8s.io/kubernetes/cmd/libs/go2idl/parser"
	"k8s.io/kubernetes/cmd/libs/go2idl/types"

	"github.com/golang/glog"
	flag "github.com/spf13/pflag"
)

var (
	inputDirs         = flag.StringP("input-dirs", "i", "./testdata/apis/group/version", "comma-separated list of directories to get input types from.")
	outputBase        = flag.StringP("output-base", "o", filepath.Join(os.Getenv("GOPATH"), "src"), "Output base; defaults to $GOPATH/src/")
	outputPackagePath = flag.StringP("output-package", "p", "k8s.io/kubernetes/pkg/client", "Package of client to add groups/versions to.")
)

func main() {
	flag.Parse()

	b := parser.New()
	for _, d := range strings.Split(*inputDirs, ",") {
		if err := b.AddDir(d); err != nil {
			glog.Fatalf("Unable to add directory %q: %v", d, err)
		}
	}
	namespacerNames := namer.NewPublicNamer(0)
	namespacerNames.Suffix = "Namespacer"
	interfaceNames := namer.NewPublicNamer(0)
	interfaceNames.Suffix = "Interface"
	c, err := generator.NewContext(
		b,
		namer.NameSystems{
			"namespacer": namespacerNames,
			"interface":  interfaceNames,
			"public":     namer.NewPublicNamer(0),
			"private":    namer.NewPrivateNamer(0),
			"raw":        namer.NewRawNamer(nil),
		},
		"public",
	)

	if err != nil {
		glog.Fatalf("Failed making a context: %v", err)
	}

	pkgs := generator.Packages{}
	checked := map[string]bool{}
	for _, t := range c.Order {
		path := t.Name.Package
		if path == "" || checked[path] {
			continue
		}
		checked[path] = true
		parts := strings.Split(path, string(filepath.Separator))
		n := len(parts)
		if n >= 2 && parts[n-1] == "v1" && parts[n-2] == "api" {
			pkgs = append(pkgs, newPackage(path, "legacy", "v1"))
		}
		if n >= 3 && parts[n-3] == "apis" {
			pkgs = append(pkgs, newPackage(path, parts[n-2], parts[n-1]))
		}
	}

	if err := c.ExecutePackages(*outputBase, pkgs); err != nil {
		glog.Fatalf("Failed executing generator: %v", err)
	}
}

func newPackage(path, group, version string) generator.Package {
	return &generator.DefaultPackage{
		PackageName: version,
		PackagePath: filepath.Join(*outputPackagePath, group, version),
		HeaderText: []byte(
			`/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by the command:
// $ ` + strings.Join(os.Args, " ") + `
// Do not edit it manually!

`),
		PackageDocumentation: []byte(fmt.Sprintf(
			`// Package %s is an autogenerated high level typed client for %s/%s.
`, version, group, version)),
		// Only look at types in the requested source package.
		FilterFunc: func(c *generator.Context, t *types.Type) bool {
			return t.Name.Package == path &&
				types.ExtractCommentTags("+", t.CommentLines)["genclient"] == "true"
		},
		// GeneratorFunc returns a list of generators. Each generator makes a
		// single file.
		GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
			generators = []generator.Generator{
				// Always generate a "doc.go" file.
				generator.DefaultGen{OptionalName: "doc"},
			}
			// Make a file per resource type.
			for _, t := range c.Order {
				generators = append(generators, &genClient{
					DefaultGen: generator.DefaultGen{
						// Use the privatized version of the
						// type name as the file name.
						//
						// TODO: make a namer that converts
						// camelCase to '-' separation for file
						// names?
						OptionalName: c.Namers["private"].Name(t),
					},
					typeToMatch: t,
					group:       group,
					version:     version,
				})
			}
			return generators
		},
	}
}

// genClient produces a file with a set for a single type.
type genClient struct {
	generator.DefaultGen
	typeToMatch    *types.Type
	group, version string
}

// Filter ignores all but one type because we're making a single file per type.
func (g *genClient) Filter(c *generator.Context, t *types.Type) bool { return t == g.typeToMatch }

func (g *genClient) Imports(c *generator.Context) (imports []string) {
	imports = []string{"reflect", "sort"}
	if n := g.typeToMatch.Name.Package; n != "" {
		imports = append(imports, n)
	}
	return imports
}

// GenerateType makes the body of a file implementing a set for type t.
func (g *genClient) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	options := types.ExtractCommentTags("+", t.CommentLines)
	namespaced := options["namespaced"] == "true"

	// We could use t directly as the argument, but in the template, I
	// think $.type|public$ is easier to read than $.|public$
	args := map[string]interface{}{
		"type":            t,
		"namespaced":      namespaced,
		"namespaceMember": ``,
		"namespaceRef":    ``,
		"version":         g.version,
		"group":           g.group,
	}
	if namespaced {
		args["namespaceMember"] = "\n\tns string"
		args["namespaceRef"] = `Namespace(c.ns).`
	}
	return generator.NewSnippetWriter(w, c, "$", "$").
		Do(midlevelInterface[namespaced]+interfaceCode, args).
		Error()
}

var midlevelInterface = map[bool]string{
	true: `// $.type|public$sNamespacer has methods to work with $.type|public$ resources in a namespace
type $.type|public$sNamespacer interface {
	$.type|public$s(namespace string) $.type|public$Interface
}

`,
	false: `// $.type|public$sInterface has methods to work with $.type|public$ resources in a namespace
type $.type|public$sInterface interface {
	$.type|public$s() $.type|public$Interface
}


`,
}

var interfaceCode = `// $.type|public$Interface has methods to work with $.type|public$ resources.
type $.type|public$Interface interface {
	List(label labels.Selector, field fields.Selector) (*$.type|raw$List, error)
	Get(name string) (*$.type|raw$, error)
	Delete(name string, options *api.DeleteOptions) error
	Create($.type|private$ *$.type|raw$) (*$.type|raw$, error)
	Update($.type|private$ *$.type|raw$) (*$.type|raw$, error)
	Watch(label labels.Selector, field fields.Selector, resourceVersion string) (watch.Interface, error)
	//Bind(binding *api.Binding) error
	UpdateStatus($.type|private$ *$.type|raw$) (*$.type|raw$, error)
}

// $.type|private$s implements $.type|public$sNamespacer interface
type $.type|private$s struct {
	r  *Client
	ns string
}

// new$.type|public$s returns a $.type|private$s
func new$.type|public$s(c *Client, namespace string) *$.type|private$s {
	return &$.type|private$s{
		r:  c,
		ns: namespace,
	}
}

// List takes label and field selectors, and returns the list of $.type|private$s that match those selectors.
func (c *$.type|private$s) List(label labels.Selector, field fields.Selector) (result *$.type|raw$List, err error) {
	result = &$.type|raw$List{}
	err = c.r.Get().Namespace(c.ns).Resource("$.type|private$s").LabelsSelectorParam(label).FieldsSelectorParam(field).Do().Into(result)
	return
}

// Get takes the name of the $.type|private$, and returns the corresponding $.type|public$ object, and an error if it occurs
func (c *$.type|private$s) Get(name string) (result *$.type|raw$, err error) {
	result = &$.type|raw${}
	err = c.r.Get().Namespace(c.ns).Resource("$.type|private$s").Name(name).Do().Into(result)
	return
}

// Delete takes the name of the $.type|private$, and returns an error if one occurs
func (c *$.type|private$s) Delete(name string, options *api.DeleteOptions) error {
	// TODO: to make this reusable in other client libraries
	if options == nil {
		return c.r.Delete().Namespace(c.ns).Resource("$.type|private$s").Name(name).Do().Error()
	}
	body, err := api.Scheme.EncodeToVersion(options, "$.version$")
	if err != nil {
		return err
	}
	return c.r.Delete().Namespace(c.ns).Resource("$.type|private$s").Name(name).Body(body).Do().Error()
}

// Create takes the representation of a $.type|private$.  Returns the server's representation of the $.type|private$, and an error, if it occurs.
func (c *$.type|private$s) Create($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {
	result = &$.type|raw${}
	err = c.r.Post().Namespace(c.ns).Resource("$.type|private$s").Body($.type|private$).Do().Into(result)
	return
}

// Update takes the representation of a $.type|private$ to update.  Returns the server's representation of the $.type|private$, and an error, if it occurs.
func (c *$.type|private$s) Update($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {
	result = &$.type|raw${}
	err = c.r.Put().Namespace(c.ns).Resource("$.type|private$s").Name($.type|private$.Name).Body($.type|private$).Do().Into(result)
	return
}

// Watch returns a watch.Interface that watches the requested $.type|private$s.
func (c *$.type|private$s) Watch(label labels.Selector, field fields.Selector, resourceVersion string) (watch.Interface, error) {
	return c.r.Get().
		Prefix("watch").
		Namespace(c.ns).
		Resource("$.type|private$s").
		Param("resourceVersion", resourceVersion).
		LabelsSelectorParam(label).
		FieldsSelectorParam(field).
		Watch()
}

/*
// Bind applies the provided binding to the named $.type|private$ in the current namespace (binding.Namespace is ignored).
func (c *$.type|private$s) Bind(binding *api.Binding) error {
	return c.r.Post().Namespace(c.ns).Resource("$.type|private$s").Name(binding.Name).SubResource("binding").Body(binding).Do().Error()
}
*/

// UpdateStatus takes the name of the $.type|private$ and the new status.  Returns the server's representation of the $.type|private$, and an error, if it occurs.
func (c *$.type|private$s) UpdateStatus($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {
	result = &$.type|raw${}
	err = c.r.Put().Namespace(c.ns).Resource("$.type|private$s").Name($.type|private$.Name).SubResource("status").Body($.type|private$).Do().Into(result)
	return
}
`
