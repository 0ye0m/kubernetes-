/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by the command:
// $ ./copy-gen -o sample_output
// Do not edit it manually!

package copy_funcs

import (
	pkix "crypto/x509/pkix"
	asn1 "encoding/asn1"
	spew "github.com/davecgh/go-spew/spew"
	cgroups "github.com/docker/libcontainer/cgroups"
	fs "github.com/docker/libcontainer/cgroups/fs"
	configs "github.com/docker/libcontainer/configs"
	proto "github.com/golang/protobuf/proto"
	client_model_go "github.com/prometheus/client_model/go"
	scanner "go/scanner"
	ssh "golang.org/x/crypto/ssh"
	api "k8s.io/kubernetes/pkg/api"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	v1 "k8s.io/kubernetes/pkg/api/v1"
	extensions "k8s.io/kubernetes/pkg/apis/extensions"
	v1beta1 "k8s.io/kubernetes/pkg/apis/extensions/v1beta1"
	runtime "k8s.io/kubernetes/pkg/runtime"
	util "k8s.io/kubernetes/pkg/util"
	net "net"
	syscall "syscall"
	unicode "unicode"
)

func copy_Bool(in, out *bool) error {
	*in = *out

}

func copy_Byte(in, out *byte) error {
	*in = *out

}

func copy_Byte(in, out *byte) error {
	*in = *out

}

func copy_Byte(in, out *byte) error {
	*in = *out

}

func copy_Int(in, out *int) error {
	*in = *out

}

func copy_Int16(in, out *int16) error {
	*in = *out

}

func copy_Int32(in, out *int32) error {
	*in = *out

}

func copy_Int64(in, out *int64) error {
	*in = *out

}

func copy_MapIntToInt(in, out *map[int]int) error {
	*out = make(map[int]int, len(*in))
	for k, v := range *in {
		var k2 int
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 int
		{
			in, out := &v, &v2
			*in = *out
		}
		(*out)[k2] = v2
	}

}

func copy_MapPointerByteToSliceByte(in, out *map[*byte][]byte) error {
	*out = make(map[*byte][]byte, len(*in))
	for k, v := range *in {
		var k2 *byte
		{
			in, out := &k, &k2
			*out = new(byte)
			{
				in, out := *in, *out
				*in = *out
			}
		}
		var v2 []byte
		{
			in, out := &v, &v2
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToBool(in, out *map[string]bool) error {
	*out = make(map[string]bool, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 bool
		{
			in, out := &v, &v2
			*in = *out
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToInt(in, out *map[string]int) error {
	*out = make(map[string]int, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 int
		{
			in, out := &v, &v2
			*in = *out
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToSliceByte(in, out *map[string][]byte) error {
	*out = make(map[string][]byte, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 []byte
		{
			in, out := &v, &v2
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToSliceInt(in, out *map[string][]int) error {
	*out = make(map[string][]int, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 []int
		{
			in, out := &v, &v2
			*out = make([]int, len(*in))
			copy(*out, *in)
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToSliceString(in, out *map[string][]string) error {
	*out = make(map[string][]string, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 []string
		{
			in, out := &v, &v2
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToString(in, out *map[string]string) error {
	*out = make(map[string]string, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 string
		{
			in, out := &v, &v2
			*in = *out
		}
		(*out)[k2] = v2
	}

}

func copy_MapStringToUint64(in, out *map[string]uint64) error {
	*out = make(map[string]uint64, len(*in))
	for k, v := range *in {
		var k2 string
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 uint64
		{
			in, out := &v, &v2
			*in = *out
		}
		(*out)[k2] = v2
	}

}

func copy_MapUint32ToSliceByte(in, out *map[uint32][]byte) error {
	*out = make(map[uint32][]byte, len(*in))
	for k, v := range *in {
		var k2 uint32
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 []byte
		{
			in, out := &v, &v2
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
		(*out)[k2] = v2
	}

}

func copy_MapUint64ToStruct(in, out *map[uint64]struct{}) error {
	*out = make(map[uint64]struct{}, len(*in))
	for k, v := range *in {
		var k2 uint64
		{
			in, out := &k, &k2
			*in = *out
		}
		var v2 struct{}
		{
			in, out := &v, &v2
			*out = *in
		}
		(*out)[k2] = v2
	}

}

func copy_PointerApisExtensionsV1beta1SubresourceReference(in, out **v1beta1.SubresourceReference) error {
	*out = new(v1beta1.SubresourceReference)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerBool(in, out **bool) error {
	*out = new(bool)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerByte(in, out **byte) error {
	*out = new(byte)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerByte(in, out **byte) error {
	*out = new(byte)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerByte(in, out **byte) error {
	*out = new(byte)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerDavecghGo_spewSpewConfigState(in, out **spew.ConfigState) error {
	*out = new(spew.ConfigState)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerDockerLibcontainerCgroupsStats(in, out **cgroups.Stats) error {
	*out = new(cgroups.Stats)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).CpuStats, &(*out).CpuStats
			*out = *in
			{
				in, out := &(*in).CpuUsage, &(*out).CpuUsage
				*out = *in
				{
					in, out := &(*in).PercpuUsage, &(*out).PercpuUsage
					*out = make([]uint64, len(*in))
					copy(*out, *in)
				}
			}
			{
				in, out := &(*in).ThrottlingData, &(*out).ThrottlingData
				*out = *in
			}
		}
		{
			in, out := &(*in).MemoryStats, &(*out).MemoryStats
			*out = *in
			{
				in, out := &(*in).Stats, &(*out).Stats
				*out = make(map[string]uint64, len(*in))
				for k, v := range *in {
					var k2 string
					{
						in, out := &k, &k2
						*in = *out
					}
					var v2 uint64
					{
						in, out := &v, &v2
						*in = *out
					}
					(*out)[k2] = v2
				}
			}
		}
		{
			in, out := &(*in).BlkioStats, &(*out).BlkioStats
			*out = *in
			{
				in, out := &(*in).IoServiceBytesRecursive, &(*out).IoServiceBytesRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).IoServicedRecursive, &(*out).IoServicedRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).IoQueuedRecursive, &(*out).IoQueuedRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).IoServiceTimeRecursive, &(*out).IoServiceTimeRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).IoWaitTimeRecursive, &(*out).IoWaitTimeRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).IoMergedRecursive, &(*out).IoMergedRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).IoTimeRecursive, &(*out).IoTimeRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).SectorsRecursive, &(*out).SectorsRecursive
				*out = make([]cgroups.BlkioStatEntry, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
		}
	}

}

func copy_PointerDockerLibcontainerConfigsMount(in, out **configs.Mount) error {
	*out = new(configs.Mount)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerDockerLibcontainerConfigsNetwork(in, out **configs.Network) error {
	*out = new(configs.Network)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerDockerLibcontainerConfigsRoute(in, out **configs.Route) error {
	*out = new(configs.Route)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerGoScannerError(in, out **scanner.Error) error {
	*out = new(scanner.Error)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Pos, &(*out).Pos
			*out = *in
		}
	}

}

func copy_PointerGoScannerErrorList(in, out **scanner.ErrorList) error {
	*out = new(scanner.ErrorList)
	{
		in, out := *in, *out
		*out = make(scanner.ErrorList, len(*in))
		for i := range *in {
			{
				in, out := &(*in[i]), &(*out[i])
				*out = new(scanner.Error)
				{
					in, out := *in, *out
					*out = *in
					{
						in, out := &(*in).Pos, &(*out).Pos
						*out = *in
					}
				}
			}
		}
	}

}

func copy_PointerGolangProtobufProtoParseError(in, out **proto.ParseError) error {
	*out = new(proto.ParseError)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerInt(in, out **int) error {
	*out = new(int)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerInt32(in, out **int32) error {
	*out = new(int32)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerInt64(in, out **int64) error {
	*out = new(int64)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerKubernetesPkgApiAWSElasticBlockStoreVolumeSource(in, out **api.AWSElasticBlockStoreVolumeSource) error {
	*out = new(api.AWSElasticBlockStoreVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiCephFSVolumeSource(in, out **api.CephFSVolumeSource) error {
	*out = new(api.CephFSVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Monitors, &(*out).Monitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).SecretRef, &(*out).SecretRef
			*out = new(api.LocalObjectReference)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_PointerKubernetesPkgApiCinderVolumeSource(in, out **api.CinderVolumeSource) error {
	*out = new(api.CinderVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiContainerStateWaiting(in, out **api.ContainerStateWaiting) error {
	*out = new(api.ContainerStateWaiting)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiDownwardAPIVolumeSource(in, out **api.DownwardAPIVolumeSource) error {
	*out = new(api.DownwardAPIVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Items, &(*out).Items
			*out = make([]api.DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				{
					in, out := &(*in[i]), &(*out[i])
					*out = *in
					{
						in, out := &(*in).FieldRef, &(*out).FieldRef
						*out = *in
					}
				}
			}
		}
	}

}

func copy_PointerKubernetesPkgApiEnvVarSource(in, out **api.EnvVarSource) error {
	*out = new(api.EnvVarSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).FieldRef, &(*out).FieldRef
			*out = new(api.ObjectFieldSelector)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_PointerKubernetesPkgApiExecAction(in, out **api.ExecAction) error {
	*out = new(api.ExecAction)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Command, &(*out).Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerKubernetesPkgApiFCVolumeSource(in, out **api.FCVolumeSource) error {
	*out = new(api.FCVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).TargetWWNs, &(*out).TargetWWNs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).Lun, &(*out).Lun
			*out = new(int)
			{
				in, out := *in, *out
				*in = *out
			}
		}
	}

}

func copy_PointerKubernetesPkgApiFlockerVolumeSource(in, out **api.FlockerVolumeSource) error {
	*out = new(api.FlockerVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiGCEPersistentDiskVolumeSource(in, out **api.GCEPersistentDiskVolumeSource) error {
	*out = new(api.GCEPersistentDiskVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiGitRepoVolumeSource(in, out **api.GitRepoVolumeSource) error {
	*out = new(api.GitRepoVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiGlusterfsVolumeSource(in, out **api.GlusterfsVolumeSource) error {
	*out = new(api.GlusterfsVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiHostPathVolumeSource(in, out **api.HostPathVolumeSource) error {
	*out = new(api.HostPathVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiISCSIVolumeSource(in, out **api.ISCSIVolumeSource) error {
	*out = new(api.ISCSIVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiLocalObjectReference(in, out **api.LocalObjectReference) error {
	*out = new(api.LocalObjectReference)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiNFSVolumeSource(in, out **api.NFSVolumeSource) error {
	*out = new(api.NFSVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiObjectFieldSelector(in, out **api.ObjectFieldSelector) error {
	*out = new(api.ObjectFieldSelector)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiPersistentVolumeClaimVolumeSource(in, out **api.PersistentVolumeClaimVolumeSource) error {
	*out = new(api.PersistentVolumeClaimVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiPodSecurityContext(in, out **api.PodSecurityContext) error {
	*out = new(api.PodSecurityContext)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiRBDVolumeSource(in, out **api.RBDVolumeSource) error {
	*out = new(api.RBDVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).CephMonitors, &(*out).CephMonitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).SecretRef, &(*out).SecretRef
			*out = new(api.LocalObjectReference)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_PointerKubernetesPkgApiSELinuxOptions(in, out **api.SELinuxOptions) error {
	*out = new(api.SELinuxOptions)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgApiSecretVolumeSource(in, out **api.SecretVolumeSource) error {
	*out = new(api.SecretVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerKubernetesPkgRuntimeRawExtension(in, out **runtime.RawExtension) error {
	*out = new(runtime.RawExtension)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).RawJSON, &(*out).RawJSON
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerKubernetesPkgUtilPortRange(in, out **util.PortRange) error {
	*out = new(util.PortRange)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerLibcontainerCgroupsFsBlkioGroup(in, out **fs.BlkioGroup) error {
	*out = new(fs.BlkioGroup)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerLibcontainerCgroupsFsCpusetGroup(in, out **fs.CpusetGroup) error {
	*out = new(fs.CpusetGroup)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerMapStringToString(in, out **map[string]string) error {
	*out = new(map[string]string)
	{
		in, out := *in, *out
		*out = make(map[string]string, len(*in))
		for k, v := range *in {
			var k2 string
			{
				in, out := &k, &k2
				*in = *out
			}
			var v2 string
			{
				in, out := &v, &v2
				*in = *out
			}
			(*out)[k2] = v2
		}
	}

}

func copy_PointerNetIP(in, out **net.IP) error {
	*out = new(net.IP)
	{
		in, out := *in, *out
		*out = make(net.IP, len(*in))
		copy(*out, *in)
	}

}

func copy_PointerNetIPAddr(in, out **net.IPAddr) error {
	*out = new(net.IPAddr)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).IP, &(*out).IP
			*out = make(net.IP, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerNetIPMask(in, out **net.IPMask) error {
	*out = new(net.IPMask)
	{
		in, out := *in, *out
		*out = make(net.IPMask, len(*in))
		copy(*out, *in)
	}

}

func copy_PointerNetIPNet(in, out **net.IPNet) error {
	*out = new(net.IPNet)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).IP, &(*out).IP
			*out = make(net.IP, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).Mask, &(*out).Mask
			*out = make(net.IPMask, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerNetMX(in, out **net.MX) error {
	*out = new(net.MX)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerNetSRV(in, out **net.SRV) error {
	*out = new(net.SRV)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerNetTCPAddr(in, out **net.TCPAddr) error {
	*out = new(net.TCPAddr)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).IP, &(*out).IP
			*out = make(net.IP, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerNetUDPAddr(in, out **net.UDPAddr) error {
	*out = new(net.UDPAddr)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).IP, &(*out).IP
			*out = make(net.IP, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerNetUnixAddr(in, out **net.UnixAddr) error {
	*out = new(net.UnixAddr)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1AWSElasticBlockStoreVolumeSource(in, out **v1.AWSElasticBlockStoreVolumeSource) error {
	*out = new(v1.AWSElasticBlockStoreVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1CephFSVolumeSource(in, out **v1.CephFSVolumeSource) error {
	*out = new(v1.CephFSVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Monitors, &(*out).Monitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).SecretRef, &(*out).SecretRef
			*out = new(v1.LocalObjectReference)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_PointerPkgApiV1CinderVolumeSource(in, out **v1.CinderVolumeSource) error {
	*out = new(v1.CinderVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1ContainerStateWaiting(in, out **v1.ContainerStateWaiting) error {
	*out = new(v1.ContainerStateWaiting)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1DownwardAPIVolumeSource(in, out **v1.DownwardAPIVolumeSource) error {
	*out = new(v1.DownwardAPIVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Items, &(*out).Items
			*out = make([]v1.DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				{
					in, out := &(*in[i]), &(*out[i])
					*out = *in
					{
						in, out := &(*in).FieldRef, &(*out).FieldRef
						*out = *in
					}
				}
			}
		}
	}

}

func copy_PointerPkgApiV1EnvVarSource(in, out **v1.EnvVarSource) error {
	*out = new(v1.EnvVarSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).FieldRef, &(*out).FieldRef
			*out = new(v1.ObjectFieldSelector)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_PointerPkgApiV1ExecAction(in, out **v1.ExecAction) error {
	*out = new(v1.ExecAction)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Command, &(*out).Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerPkgApiV1FCVolumeSource(in, out **v1.FCVolumeSource) error {
	*out = new(v1.FCVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).TargetWWNs, &(*out).TargetWWNs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).Lun, &(*out).Lun
			*out = new(int)
			{
				in, out := *in, *out
				*in = *out
			}
		}
	}

}

func copy_PointerPkgApiV1FlockerVolumeSource(in, out **v1.FlockerVolumeSource) error {
	*out = new(v1.FlockerVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1GCEPersistentDiskVolumeSource(in, out **v1.GCEPersistentDiskVolumeSource) error {
	*out = new(v1.GCEPersistentDiskVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1GitRepoVolumeSource(in, out **v1.GitRepoVolumeSource) error {
	*out = new(v1.GitRepoVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1GlusterfsVolumeSource(in, out **v1.GlusterfsVolumeSource) error {
	*out = new(v1.GlusterfsVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1HostPathVolumeSource(in, out **v1.HostPathVolumeSource) error {
	*out = new(v1.HostPathVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1ISCSIVolumeSource(in, out **v1.ISCSIVolumeSource) error {
	*out = new(v1.ISCSIVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1LocalObjectReference(in, out **v1.LocalObjectReference) error {
	*out = new(v1.LocalObjectReference)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1NFSVolumeSource(in, out **v1.NFSVolumeSource) error {
	*out = new(v1.NFSVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1ObjectFieldSelector(in, out **v1.ObjectFieldSelector) error {
	*out = new(v1.ObjectFieldSelector)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1PersistentVolumeClaimVolumeSource(in, out **v1.PersistentVolumeClaimVolumeSource) error {
	*out = new(v1.PersistentVolumeClaimVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1PodSecurityContext(in, out **v1.PodSecurityContext) error {
	*out = new(v1.PodSecurityContext)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1RBDVolumeSource(in, out **v1.RBDVolumeSource) error {
	*out = new(v1.RBDVolumeSource)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).CephMonitors, &(*out).CephMonitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		{
			in, out := &(*in).SecretRef, &(*out).SecretRef
			*out = new(v1.LocalObjectReference)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_PointerPkgApiV1SELinuxOptions(in, out **v1.SELinuxOptions) error {
	*out = new(v1.SELinuxOptions)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApiV1SecretVolumeSource(in, out **v1.SecretVolumeSource) error {
	*out = new(v1.SecretVolumeSource)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPkgApisExtensionsSubresourceReference(in, out **extensions.SubresourceReference) error {
	*out = new(extensions.SubresourceReference)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerPrometheusClient_modelGoLabelPair(in, out **client_model_go.LabelPair) error {
	*out = new(client_model_go.LabelPair)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Name, &(*out).Name
			*out = new(string)
			{
				in, out := *in, *out
				*in = *out
			}
		}
		{
			in, out := &(*in).Value, &(*out).Value
			*out = new(string)
			{
				in, out := *in, *out
				*in = *out
			}
		}
		{
			in, out := &(*in).XXX_unrecognized, &(*out).XXX_unrecognized
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerSliceByte(in, out **[]byte) error {
	*out = new([]byte)
	{
		in, out := *in, *out
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}

}

func copy_PointerSliceInt(in, out **[]int) error {
	*out = new([]int)
	{
		in, out := *in, *out
		*out = make([]int, len(*in))
		copy(*out, *in)
	}

}

func copy_PointerSliceKubernetesPkgRuntimeRawExtension(in, out **[]runtime.RawExtension) error {
	*out = new([]runtime.RawExtension)
	{
		in, out := *in, *out
		*out = make([]runtime.RawExtension, len(*in))
		for i := range *in {
			{
				in, out := &(*in[i]), &(*out[i])
				*out = *in
				{
					in, out := &(*in).RawJSON, &(*out).RawJSON
					*out = make([]byte, len(*in))
					copy(*out, *in)
				}
			}
		}
	}

}

func copy_PointerSliceString(in, out **[]string) error {
	*out = new([]string)
	{
		in, out := *in, *out
		*out = make([]string, len(*in))
		copy(*out, *in)
	}

}

func copy_PointerString(in, out **string) error {
	*out = new(string)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerSyscallCredential(in, out **syscall.Credential) error {
	*out = new(syscall.Credential)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Groups, &(*out).Groups
			*out = make([]uint32, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_PointerSyscallIovec(in, out **syscall.Iovec) error {
	*out = new(syscall.Iovec)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Base, &(*out).Base
			*out = new(byte)
			{
				in, out := *in, *out
				*in = *out
			}
		}
	}

}

func copy_PointerSyscallPtraceRegs(in, out **syscall.PtraceRegs) error {
	*out = new(syscall.PtraceRegs)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerSyscallRusage(in, out **syscall.Rusage) error {
	*out = new(syscall.Rusage)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Utime, &(*out).Utime
			*out = *in
		}
		{
			in, out := &(*in).Stime, &(*out).Stime
			*out = *in
		}
	}

}

func copy_PointerSyscallSockFilter(in, out **syscall.SockFilter) error {
	*out = new(syscall.SockFilter)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerSyscallTimeval(in, out **syscall.Timeval) error {
	*out = new(syscall.Timeval)
	{
		in, out := *in, *out
		*out = *in
	}

}

func copy_PointerUint(in, out **uint) error {
	*out = new(uint)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerUint16(in, out **uint16) error {
	*out = new(uint16)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerUint32(in, out **uint32) error {
	*out = new(uint32)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerUint64(in, out **uint64) error {
	*out = new(uint64)
	{
		in, out := *in, *out
		*in = *out
	}

}

func copy_PointerXCryptoSshPermissions(in, out **ssh.Permissions) error {
	*out = new(ssh.Permissions)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).CriticalOptions, &(*out).CriticalOptions
			*out = make(map[string]string, len(*in))
			for k, v := range *in {
				var k2 string
				{
					in, out := &k, &k2
					*in = *out
				}
				var v2 string
				{
					in, out := &v, &v2
					*in = *out
				}
				(*out)[k2] = v2
			}
		}
		{
			in, out := &(*in).Extensions, &(*out).Extensions
			*out = make(map[string]string, len(*in))
			for k, v := range *in {
				var k2 string
				{
					in, out := &k, &k2
					*in = *out
				}
				var v2 string
				{
					in, out := &v, &v2
					*in = *out
				}
				(*out)[k2] = v2
			}
		}
	}

}

func copy_PointerXCryptoSshSignature(in, out **ssh.Signature) error {
	*out = new(ssh.Signature)
	{
		in, out := *in, *out
		*out = *in
		{
			in, out := &(*in).Blob, &(*out).Blob
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceApisExtensionsV1beta1APIVersion(in, out *[]v1beta1.APIVersion) error {
	*out = make([]v1beta1.APIVersion, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceBool(in, out *[]bool) error {
	*out = make([]bool, len(*in))
	copy(*out, *in)

}

func copy_SliceByte(in, out *[]byte) error {
	*out = make([]byte, len(*in))
	copy(*out, *in)

}

func copy_SliceByte(in, out *[]byte) error {
	*out = make([]byte, len(*in))
	copy(*out, *in)

}

func copy_SliceCryptoX509PkixExtension(in, out *[]pkix.Extension) error {
	*out = make([]pkix.Extension, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).Id, &(*out).Id
				*out = make(asn1.ObjectIdentifier, len(*in))
				copy(*out, *in)
			}
			{
				in, out := &(*in).Value, &(*out).Value
				*out = make([]byte, len(*in))
				copy(*out, *in)
			}
		}
	}

}

func copy_SliceDockerLibcontainerCgroupsBlkioStatEntry(in, out *[]cgroups.BlkioStatEntry) error {
	*out = make([]cgroups.BlkioStatEntry, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceDockerLibcontainerConfigsIDMap(in, out *[]configs.IDMap) error {
	*out = make([]configs.IDMap, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceDockerLibcontainerConfigsRlimit(in, out *[]configs.Rlimit) error {
	*out = make([]configs.Rlimit, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceEncodingAsn1ObjectIdentifier(in, out *[]asn1.ObjectIdentifier) error {
	*out = make([]asn1.ObjectIdentifier, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make(asn1.ObjectIdentifier, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceEncodingAsn1RawValue(in, out *[]asn1.RawValue) error {
	*out = make([]asn1.RawValue, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).Bytes, &(*out).Bytes
				*out = make([]byte, len(*in))
				copy(*out, *in)
			}
			{
				in, out := &(*in).FullBytes, &(*out).FullBytes
				*out = make([]byte, len(*in))
				copy(*out, *in)
			}
		}
	}

}

func copy_SliceGolangProtobufProtoExtensionRange(in, out *[]proto.ExtensionRange) error {
	*out = make([]proto.ExtensionRange, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceInt(in, out *[]int) error {
	*out = make([]int, len(*in))
	copy(*out, *in)

}

func copy_SliceInt32(in, out *[]int32) error {
	*out = make([]int32, len(*in))
	copy(*out, *in)

}

func copy_SliceInt64(in, out *[]int64) error {
	*out = make([]int64, len(*in))
	copy(*out, *in)

}

func copy_SliceKubernetesPkgApiDownwardAPIVolumeFile(in, out *[]api.DownwardAPIVolumeFile) error {
	*out = make([]api.DownwardAPIVolumeFile, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).FieldRef, &(*out).FieldRef
				*out = *in
			}
		}
	}

}

func copy_SliceKubernetesPkgApiEnvVar(in, out *[]api.EnvVar) error {
	*out = make([]api.EnvVar, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).ValueFrom, &(*out).ValueFrom
				*out = new(api.EnvVarSource)
				{
					in, out := *in, *out
					*out = *in
					{
						in, out := &(*in).FieldRef, &(*out).FieldRef
						*out = new(api.ObjectFieldSelector)
						{
							in, out := *in, *out
							*out = *in
						}
					}
				}
			}
		}
	}

}

func copy_SliceKubernetesPkgApiLoadBalancerIngress(in, out *[]api.LoadBalancerIngress) error {
	*out = make([]api.LoadBalancerIngress, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceKubernetesPkgApiLocalObjectReference(in, out *[]api.LocalObjectReference) error {
	*out = make([]api.LocalObjectReference, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceKubernetesPkgApiVolumeMount(in, out *[]api.VolumeMount) error {
	*out = make([]api.VolumeMount, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceKubernetesPkgRuntimeRawExtension(in, out *[]runtime.RawExtension) error {
	*out = make([]runtime.RawExtension, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).RawJSON, &(*out).RawJSON
				*out = make([]byte, len(*in))
				copy(*out, *in)
			}
		}
	}

}

func copy_SliceNetIP(in, out *[]net.IP) error {
	*out = make([]net.IP, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make(net.IP, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceNetIPAddr(in, out *[]net.IPAddr) error {
	*out = make([]net.IPAddr, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).IP, &(*out).IP
				*out = make(net.IP, len(*in))
				copy(*out, *in)
			}
		}
	}

}

func copy_SlicePkgApiUnversionedAPIGroup(in, out *[]unversioned.APIGroup) error {
	*out = make([]unversioned.APIGroup, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).Versions, &(*out).Versions
				*out = make([]unversioned.GroupVersion, len(*in))
				for i := range *in {
					{
						in, out := &(*in[i]), &(*out[i])
						*out = *in
					}
				}
			}
			{
				in, out := &(*in).PreferredVersion, &(*out).PreferredVersion
				*out = *in
			}
		}
	}

}

func copy_SlicePkgApiUnversionedAPIResource(in, out *[]unversioned.APIResource) error {
	*out = make([]unversioned.APIResource, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SlicePkgApiUnversionedGroupVersion(in, out *[]unversioned.GroupVersion) error {
	*out = make([]unversioned.GroupVersion, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SlicePkgApiV1DownwardAPIVolumeFile(in, out *[]v1.DownwardAPIVolumeFile) error {
	*out = make([]v1.DownwardAPIVolumeFile, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).FieldRef, &(*out).FieldRef
				*out = *in
			}
		}
	}

}

func copy_SlicePkgApiV1EnvVar(in, out *[]v1.EnvVar) error {
	*out = make([]v1.EnvVar, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
			{
				in, out := &(*in).ValueFrom, &(*out).ValueFrom
				*out = new(v1.EnvVarSource)
				{
					in, out := *in, *out
					*out = *in
					{
						in, out := &(*in).FieldRef, &(*out).FieldRef
						*out = new(v1.ObjectFieldSelector)
						{
							in, out := *in, *out
							*out = *in
						}
					}
				}
			}
		}
	}

}

func copy_SlicePkgApiV1LoadBalancerIngress(in, out *[]v1.LoadBalancerIngress) error {
	*out = make([]v1.LoadBalancerIngress, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SlicePkgApiV1LocalObjectReference(in, out *[]v1.LocalObjectReference) error {
	*out = make([]v1.LocalObjectReference, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SlicePkgApiV1VolumeMount(in, out *[]v1.VolumeMount) error {
	*out = make([]v1.VolumeMount, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SlicePkgApisExtensionsAPIVersion(in, out *[]extensions.APIVersion) error {
	*out = make([]extensions.APIVersion, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SlicePointerDockerLibcontainerConfigsMount(in, out *[]*configs.Mount) error {
	*out = make([]*configs.Mount, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = new(configs.Mount)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_SlicePointerDockerLibcontainerConfigsNetwork(in, out *[]*configs.Network) error {
	*out = make([]*configs.Network, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = new(configs.Network)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_SlicePointerDockerLibcontainerConfigsRoute(in, out *[]*configs.Route) error {
	*out = make([]*configs.Route, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = new(configs.Route)
			{
				in, out := *in, *out
				*out = *in
			}
		}
	}

}

func copy_SlicePointerPrometheusClient_modelGoLabelPair(in, out *[]*client_model_go.LabelPair) error {
	*out = make([]*client_model_go.LabelPair, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = new(client_model_go.LabelPair)
			{
				in, out := *in, *out
				*out = *in
				{
					in, out := &(*in).Name, &(*out).Name
					*out = new(string)
					{
						in, out := *in, *out
						*in = *out
					}
				}
				{
					in, out := &(*in).Value, &(*out).Value
					*out = new(string)
					{
						in, out := *in, *out
						*in = *out
					}
				}
				{
					in, out := &(*in).XXX_unrecognized, &(*out).XXX_unrecognized
					*out = make([]byte, len(*in))
					copy(*out, *in)
				}
			}
		}
	}

}

func copy_SliceSliceByte(in, out *[][]byte) error {
	*out = make([][]byte, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceSliceInt(in, out *[][]int) error {
	*out = make([][]int, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make([]int, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceSliceSliceByte(in, out *[][][]byte) error {
	*out = make([][][]byte, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make([][]byte, len(*in))
			for i := range *in {
				{
					in, out := &(*in[i]), &(*out[i])
					*out = make([]byte, len(*in))
					copy(*out, *in)
				}
			}
		}
	}

}

func copy_SliceSliceString(in, out *[][]string) error {
	*out = make([][]string, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceSliceUint32(in, out *[][]uint32) error {
	*out = make([][]uint32, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = make([]uint32, len(*in))
			copy(*out, *in)
		}
	}

}

func copy_SliceString(in, out *[]string) error {
	*out = make([]string, len(*in))
	copy(*out, *in)

}

func copy_SliceSyscallSysProcIDMap(in, out *[]syscall.SysProcIDMap) error {
	*out = make([]syscall.SysProcIDMap, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceUint16(in, out *[]uint16) error {
	*out = make([]uint16, len(*in))
	copy(*out, *in)

}

func copy_SliceUint32(in, out *[]uint32) error {
	*out = make([]uint32, len(*in))
	copy(*out, *in)

}

func copy_SliceUint64(in, out *[]uint64) error {
	*out = make([]uint64, len(*in))
	copy(*out, *in)

}

func copy_SliceUnicodeRange16(in, out *[]unicode.Range16) error {
	*out = make([]unicode.Range16, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_SliceUnicodeRange32(in, out *[]unicode.Range32) error {
	*out = make([]unicode.Range32, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
			*out = *in
		}
	}

}

func copy_String(in, out *string) error {
	*in = *out

}

func copy_Struct(in, out *struct{}) error {
	*out = *in

}

func copy_StructUint32Uint64Uint64(in, out *struct {
	Size    uint32
	Mallocs uint64
	Frees   uint64
}) error {
	*out = *in

}

func copy_Uint(in, out *uint) error {
	*in = *out

}

func copy_Uint16(in, out *uint16) error {
	*in = *out

}

func copy_Uint32(in, out *uint32) error {
	*in = *out

}

func copy_Uint64(in, out *uint64) error {
	*in = *out

}
