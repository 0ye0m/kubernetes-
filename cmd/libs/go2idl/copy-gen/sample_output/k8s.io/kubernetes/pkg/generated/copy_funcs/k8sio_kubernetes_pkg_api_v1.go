/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by the command:
// $ ./copy-gen -o sample_output
// Do not edit it manually!

package copy_funcs

import (
	v1 "k8s.io/kubernetes/pkg/api/v1"
	runtime "k8s.io/kubernetes/pkg/runtime"
)

func copy_PkgApiV1AWSElasticBlockStoreVolumeSource(in, out *v1.AWSElasticBlockStoreVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1CephFSVolumeSource(in, out *v1.CephFSVolumeSource) error {
	*out = *in
	{
		in, out := &(*in).Monitors, &(*out).Monitors
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	{
		in, out := &(*in).SecretRef, &(*out).SecretRef
		*out = new(v1.LocalObjectReference)
		{
			in, out := *in, *out
			*out = *in
		}
	}

}

func copy_PkgApiV1CinderVolumeSource(in, out *v1.CinderVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1ContainerStateWaiting(in, out *v1.ContainerStateWaiting) error {
	*out = *in

}

func copy_PkgApiV1DaemonEndpoint(in, out *v1.DaemonEndpoint) error {
	*out = *in

}

func copy_PkgApiV1DeleteOptions(in, out *v1.DeleteOptions) error {
	*out = *in
	{
		in, out := &(*in).TypeMeta, &(*out).TypeMeta
		*out = *in
	}
	{
		in, out := &(*in).GracePeriodSeconds, &(*out).GracePeriodSeconds
		*out = new(int64)
		{
			in, out := *in, *out
			*in = *out
		}
	}

}

func copy_PkgApiV1DownwardAPIVolumeFile(in, out *v1.DownwardAPIVolumeFile) error {
	*out = *in
	{
		in, out := &(*in).FieldRef, &(*out).FieldRef
		*out = *in
	}

}

func copy_PkgApiV1DownwardAPIVolumeSource(in, out *v1.DownwardAPIVolumeSource) error {
	*out = *in
	{
		in, out := &(*in).Items, &(*out).Items
		*out = make([]v1.DownwardAPIVolumeFile, len(*in))
		for i := range *in {
			{
				in, out := &(*in[i]), &(*out[i])
				*out = *in
				{
					in, out := &(*in).FieldRef, &(*out).FieldRef
					*out = *in
				}
			}
		}
	}

}

func copy_PkgApiV1EnvVar(in, out *v1.EnvVar) error {
	*out = *in
	{
		in, out := &(*in).ValueFrom, &(*out).ValueFrom
		*out = new(v1.EnvVarSource)
		{
			in, out := *in, *out
			*out = *in
			{
				in, out := &(*in).FieldRef, &(*out).FieldRef
				*out = new(v1.ObjectFieldSelector)
				{
					in, out := *in, *out
					*out = *in
				}
			}
		}
	}

}

func copy_PkgApiV1EnvVarSource(in, out *v1.EnvVarSource) error {
	*out = *in
	{
		in, out := &(*in).FieldRef, &(*out).FieldRef
		*out = new(v1.ObjectFieldSelector)
		{
			in, out := *in, *out
			*out = *in
		}
	}

}

func copy_PkgApiV1EventSource(in, out *v1.EventSource) error {
	*out = *in

}

func copy_PkgApiV1ExecAction(in, out *v1.ExecAction) error {
	*out = *in
	{
		in, out := &(*in).Command, &(*out).Command
		*out = make([]string, len(*in))
		copy(*out, *in)
	}

}

func copy_PkgApiV1FCVolumeSource(in, out *v1.FCVolumeSource) error {
	*out = *in
	{
		in, out := &(*in).TargetWWNs, &(*out).TargetWWNs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	{
		in, out := &(*in).Lun, &(*out).Lun
		*out = new(int)
		{
			in, out := *in, *out
			*in = *out
		}
	}

}

func copy_PkgApiV1FlockerVolumeSource(in, out *v1.FlockerVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1GCEPersistentDiskVolumeSource(in, out *v1.GCEPersistentDiskVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1GitRepoVolumeSource(in, out *v1.GitRepoVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1GlusterfsVolumeSource(in, out *v1.GlusterfsVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1HostPathVolumeSource(in, out *v1.HostPathVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1ISCSIVolumeSource(in, out *v1.ISCSIVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1List(in, out *v1.List) error {
	*out = *in
	{
		in, out := &(*in).TypeMeta, &(*out).TypeMeta
		*out = *in
	}
	{
		in, out := &(*in).ListMeta, &(*out).ListMeta
		*out = *in
	}
	{
		in, out := &(*in).Items, &(*out).Items
		*out = make([]runtime.RawExtension, len(*in))
		for i := range *in {
			{
				in, out := &(*in[i]), &(*out[i])
				*out = *in
				{
					in, out := &(*in).RawJSON, &(*out).RawJSON
					*out = make([]byte, len(*in))
					copy(*out, *in)
				}
			}
		}
	}

}

func copy_PkgApiV1ListOptions(in, out *v1.ListOptions) error {
	*out = *in
	{
		in, out := &(*in).TypeMeta, &(*out).TypeMeta
		*out = *in
	}

}

func copy_PkgApiV1LoadBalancerIngress(in, out *v1.LoadBalancerIngress) error {
	*out = *in

}

func copy_PkgApiV1LoadBalancerStatus(in, out *v1.LoadBalancerStatus) error {
	*out = *in
	{
		in, out := &(*in).Ingress, &(*out).Ingress
		*out = make([]v1.LoadBalancerIngress, len(*in))
		for i := range *in {
			{
				in, out := &(*in[i]), &(*out[i])
				*out = *in
			}
		}
	}

}

func copy_PkgApiV1LocalObjectReference(in, out *v1.LocalObjectReference) error {
	*out = *in

}

func copy_PkgApiV1NFSVolumeSource(in, out *v1.NFSVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1NodeDaemonEndpoints(in, out *v1.NodeDaemonEndpoints) error {
	*out = *in
	{
		in, out := &(*in).KubeletEndpoint, &(*out).KubeletEndpoint
		*out = *in
	}

}

func copy_PkgApiV1NodeSpec(in, out *v1.NodeSpec) error {
	*out = *in

}

func copy_PkgApiV1NodeSystemInfo(in, out *v1.NodeSystemInfo) error {
	*out = *in

}

func copy_PkgApiV1ObjectFieldSelector(in, out *v1.ObjectFieldSelector) error {
	*out = *in

}

func copy_PkgApiV1PersistentVolumeClaimVolumeSource(in, out *v1.PersistentVolumeClaimVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1PersistentVolumeSource(in, out *v1.PersistentVolumeSource) error {
	*out = *in
	{
		in, out := &(*in).GCEPersistentDisk, &(*out).GCEPersistentDisk
		*out = new(v1.GCEPersistentDiskVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).AWSElasticBlockStore, &(*out).AWSElasticBlockStore
		*out = new(v1.AWSElasticBlockStoreVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).HostPath, &(*out).HostPath
		*out = new(v1.HostPathVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).Glusterfs, &(*out).Glusterfs
		*out = new(v1.GlusterfsVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).NFS, &(*out).NFS
		*out = new(v1.NFSVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).RBD, &(*out).RBD
		*out = new(v1.RBDVolumeSource)
		{
			in, out := *in, *out
			*out = *in
			{
				in, out := &(*in).CephMonitors, &(*out).CephMonitors
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			{
				in, out := &(*in).SecretRef, &(*out).SecretRef
				*out = new(v1.LocalObjectReference)
				{
					in, out := *in, *out
					*out = *in
				}
			}
		}
	}
	{
		in, out := &(*in).ISCSI, &(*out).ISCSI
		*out = new(v1.ISCSIVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).Cinder, &(*out).Cinder
		*out = new(v1.CinderVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}
	{
		in, out := &(*in).CephFS, &(*out).CephFS
		*out = new(v1.CephFSVolumeSource)
		{
			in, out := *in, *out
			*out = *in
			{
				in, out := &(*in).Monitors, &(*out).Monitors
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			{
				in, out := &(*in).SecretRef, &(*out).SecretRef
				*out = new(v1.LocalObjectReference)
				{
					in, out := *in, *out
					*out = *in
				}
			}
		}
	}
	{
		in, out := &(*in).FC, &(*out).FC
		*out = new(v1.FCVolumeSource)
		{
			in, out := *in, *out
			*out = *in
			{
				in, out := &(*in).TargetWWNs, &(*out).TargetWWNs
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			{
				in, out := &(*in).Lun, &(*out).Lun
				*out = new(int)
				{
					in, out := *in, *out
					*in = *out
				}
			}
		}
	}
	{
		in, out := &(*in).Flocker, &(*out).Flocker
		*out = new(v1.FlockerVolumeSource)
		{
			in, out := *in, *out
			*out = *in
		}
	}

}

func copy_PkgApiV1PodAttachOptions(in, out *v1.PodAttachOptions) error {
	*out = *in
	{
		in, out := &(*in).TypeMeta, &(*out).TypeMeta
		*out = *in
	}

}

func copy_PkgApiV1PodExecOptions(in, out *v1.PodExecOptions) error {
	*out = *in
	{
		in, out := &(*in).TypeMeta, &(*out).TypeMeta
		*out = *in
	}
	{
		in, out := &(*in).Command, &(*out).Command
		*out = make([]string, len(*in))
		copy(*out, *in)
	}

}

func copy_PkgApiV1PodProxyOptions(in, out *v1.PodProxyOptions) error {
	*out = *in
	{
		in, out := &(*in).TypeMeta, &(*out).TypeMeta
		*out = *in
	}

}

func copy_PkgApiV1PodSecurityContext(in, out *v1.PodSecurityContext) error {
	*out = *in

}

func copy_PkgApiV1RBDVolumeSource(in, out *v1.RBDVolumeSource) error {
	*out = *in
	{
		in, out := &(*in).CephMonitors, &(*out).CephMonitors
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	{
		in, out := &(*in).SecretRef, &(*out).SecretRef
		*out = new(v1.LocalObjectReference)
		{
			in, out := *in, *out
			*out = *in
		}
	}

}

func copy_PkgApiV1ReplicationControllerStatus(in, out *v1.ReplicationControllerStatus) error {
	*out = *in

}

func copy_PkgApiV1SELinuxOptions(in, out *v1.SELinuxOptions) error {
	*out = *in

}

func copy_PkgApiV1SecretVolumeSource(in, out *v1.SecretVolumeSource) error {
	*out = *in

}

func copy_PkgApiV1ServiceStatus(in, out *v1.ServiceStatus) error {
	*out = *in
	{
		in, out := &(*in).LoadBalancer, &(*out).LoadBalancer
		*out = *in
		{
			in, out := &(*in).Ingress, &(*out).Ingress
			*out = make([]v1.LoadBalancerIngress, len(*in))
			for i := range *in {
				{
					in, out := &(*in[i]), &(*out[i])
					*out = *in
				}
			}
		}
	}

}

func copy_PkgApiV1VolumeMount(in, out *v1.VolumeMount) error {
	*out = *in

}
