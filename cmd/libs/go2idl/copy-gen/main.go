/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// set-gen is an example usage of go2idl.
package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"k8s.io/kubernetes/cmd/libs/go2idl/generator"
	"k8s.io/kubernetes/cmd/libs/go2idl/namer"
	"k8s.io/kubernetes/cmd/libs/go2idl/parser"
	"k8s.io/kubernetes/cmd/libs/go2idl/types"

	"github.com/golang/glog"
	flag "github.com/spf13/pflag"
)

var (
	inputDirs         = flag.StringP("input-dirs", "i", "k8s.io/kubernetes/pkg/api,k8s.io/kubernetes/pkg/api/v1,k8s.io/kubernetes/pkg/apis/extensions/v1beta1,k8s.io/kubernetes/pkg/apis/extensions", "comma-separated list of directories to get input types from.")
	outputBase        = flag.StringP("output-base", "o", filepath.Join(os.Getenv("GOPATH"), "src"), "Output base; defaults to $GOPATH/src/")
	outputPackagePath = flag.StringP("output-package", "p", "k8s.io/kubernetes/pkg/generated", "Package within which the copy_funcs package will be created.")
)

func main() {
	flag.Parse()

	b := parser.New()
	for _, d := range strings.Split(*inputDirs, ",") {
		if err := b.AddDir(d); err != nil {
			glog.Fatalf("Unable to add directory %q: %v", d, err)
		}
	}
	c, err := generator.NewContext(
		b,
		namer.NameSystems{
			"public": namer.NewPublicNamer(3),
		},
		"public",
	)

	if err != nil {
		glog.Fatalf("Failed making a context: %v", err)
	}

	pkgs := generator.Packages{newPackage()}
	if err := c.ExecutePackages(*outputBase, pkgs); err != nil {
		glog.Fatalf("Failed executing generator: %v", err)
	}
}

func newPackage() generator.Package {
	return &generator.DefaultPackage{
		PackageName: "copy_funcs",
		PackagePath: filepath.Join(*outputPackagePath, "copy_funcs"),
		HeaderText: []byte(
			`/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by the command:
// $ ` + strings.Join(os.Args, " ") + `
// Do not edit it manually!

`),
		PackageDocumentation: []byte(fmt.Sprintf(
			`// Package copy_funcs is an autogenerated deep copy implementation.`)),
		FilterFunc: func(c *generator.Context, t *types.Type) bool {
			// Filter out un-copyable types.
			seen := map[*types.Type]bool{}
			if !isCopyable(seen, t) {
				return false
			}
			// Filter out types explicitly requesting no copy.
			if types.ExtractCommentTags("+", t.CommentLines)["gencopy"] == "false" {
				return false
			}
			return true
		},
		// GeneratorFunc returns a list of generators. Each generator makes a
		// single file.
		GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
			generators = []generator.Generator{
				// Always generate a "doc.go" file.
				generator.DefaultGen{OptionalName: "doc"},
			}
			// Make a file per source package.
			checked := map[string]bool{}
			for _, t := range c.Order {
				path := t.Name.Package
				if checked[path] {
					continue
				}
				checked[path] = true
				// Make up a name for this file.
				// TODO: better pathname sanitization:
				parts := strings.Split(path, string(filepath.Separator))
				joined := strings.Join(parts, "_")
				sanitized := strings.Replace(joined, ".", "", -1)
				sanitized = strings.Replace(sanitized, "-", "_", -1)
				if sanitized == "" {
					sanitized = "anonymous_types"
				}
				generators = append(generators, &genCopy{
					DefaultGen: generator.DefaultGen{
						OptionalName: sanitized,
					},
					sourcePackage: path,
				})
			}
			return generators
		},
	}
}

// genCopy produces a file with a set for a single type.
type genCopy struct {
	generator.DefaultGen
	sourcePackage string
	imports       *generator.ImportTracker
}

func (g *genCopy) Namers(c *generator.Context) namer.NameSystems {
	g.imports = generator.NewImportTracker()
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{"raw": namer.NewRawNamer(g.imports)}
}

func (g *genCopy) Filter(c *generator.Context, t *types.Type) bool {
	// Ignore types not in the proper source package.
	if t.Name.Package != g.sourcePackage {
		return false
	}
	return true
}

func isCopyable(seen map[*types.Type]bool, t *types.Type) bool {
	if seen[t] {
		// be optimistic in the case of type cycles.
		return true
	}
	seen[t] = true
	if t.Name.Package != "" {
		// Can't deep copy non-anonymous, private types.
		if strings.ToLower(t.Name.Name[:1]) == t.Name.Name[:1] {
			return false
		}
	}
	switch t.Kind {
	case types.Builtin:
		return true
	case types.Slice, types.Pointer:
		return isCopyable(seen, t.Elem)
	case types.Map:
		return isCopyable(seen, t.Key) && isCopyable(seen, t.Elem)
	case types.Struct:
		for _, m := range t.Members {
			if strings.ToLower(m.Name[:1]) == m.Name[:1] {
				return false
			}
			if !isCopyable(seen, m.Type) {
				return false
			}
		}
		return true
	case types.Func, types.Chan:
		return false
	default:
		return false
	}
}

func (g *genCopy) Imports(c *generator.Context) (imports []string) {
	return g.imports.ImportLines()
}

// GenerateType makes the body of a file implementing a set for type t.
func (g *genCopy) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	sw.Do("func copy_$.|public$(in, out *$.|raw$) error {\n", t)
	genFor(t)(sw)
	sw.Do("\n}\n\n", nil)
	return sw.Error()
}

// we use the system of shadowing 'in' and 'out' so that the same code is valid
// at any nesting level. This makes the autogenerator easy to understand, and
// the compiler shouldn't care.
func genFor(t *types.Type) func(sw *generator.SnippetWriter) {
	g := bodyGen{t}
	switch t.Kind {
	case types.Builtin:
		return g.doBuiltin
	case types.Map:
		return g.doMap
	case types.Slice:
		return g.doSlice
	case types.Struct:
		return g.doStruct
	case types.Interface:
		return g.doInterface
	case types.Pointer:
		return g.doPointer
	case types.Alias:
		return g.doAlias
	default:
		return g.unknown
	}
}

type bodyGen struct {
	t *types.Type
}

func (b bodyGen) unknown(sw *generator.SnippetWriter) {
	sw.Do("\\ Not sure how to generate $.|public$\n", b.t)
}

func (b bodyGen) doBuiltin(sw *generator.SnippetWriter) {
	sw.Do("*in = *out\n", nil)
}

func (b bodyGen) doMap(sw *generator.SnippetWriter) {
	args := map[string]interface{}{
		"type": b.t,
	}
	sw.Do(`*out = make($.type|raw$, len(*in))
	for k, v := range *in {
		var k2 $.type.Key|raw$
		{
			in, out := &k, &k2
`, args)
	genFor(b.t.Key)(sw)
	sw.Do(`}
		var v2 $.type.Elem|raw$
		{
			in, out := &v, &v2
`, args)
	genFor(b.t.Elem)(sw)
	sw.Do(`}
	(*out)[k2] = v2
	}
`, args)
}

func (b bodyGen) doSlice(sw *generator.SnippetWriter) {
	if b.t.Elem.Kind == types.Builtin {
		sw.Do(`*out = make($.|raw$, len(*in))
		copy(*out, *in)
		`, b.t)
		return
	}
	sw.Do(`*out = make($.|raw$, len(*in))
	for i := range *in {
		{
			in, out := &(*in[i]), &(*out[i])
`, b.t)
	genFor(b.t.Elem)(sw)
	sw.Do("}\n}\n", nil)
}

func (b bodyGen) doStruct(sw *generator.SnippetWriter) {
	sw.Do(`*out = *in
`, nil)
	for _, m := range b.t.Members {
		if m.Type.Kind == types.Builtin {
			continue
		}
		sw.Do(`{
	in, out := &(*in).$.Name$, &(*out).$.Name$
`, m)
		genFor(m.Type)(sw)
		sw.Do("}\n", nil)
	}
}

func (b bodyGen) doInterface(sw *generator.SnippetWriter) {
	sw.Do("// TODO: should call in to figure out the dynamic type of *in and *out\n", nil)
}

func (b bodyGen) doPointer(sw *generator.SnippetWriter) {
	sw.Do(`*out = new($.Elem|raw$)
{
	in, out := *in, *out
`, b.t)
	genFor(b.t.Elem)(sw)
	sw.Do("}\n", nil)
}

func (b bodyGen) doAlias(sw *generator.SnippetWriter) {
	sw.Do(`{
	in, out := *$.Underlying|raw$(in), *$.Underlying|raw$(*out)
`, b.t)
	genFor(b.t.Underlying)(sw)
	sw.Do("}\n", nil)
}
