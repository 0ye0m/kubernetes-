/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"fmt"
	"io"
	"path/filepath"
	"strings"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"
	"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/normalization"
	listergenargs "k8s.io/kubernetes/cmd/libs/go2idl/lister-gen/args"
	"k8s.io/kubernetes/pkg/api/unversioned"

	"github.com/golang/glog"
	"github.com/spf13/pflag"
)

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	pluralExceptions := map[string]string{
		"Endpoints": "Endpoints",
	}
	return namer.NameSystems{
		"public":             namer.NewPublicNamer(0),
		"raw":                namer.NewRawNamer("", nil),
		"publicPlural":       namer.NewPublicPluralNamer(pluralExceptions),
		"allLowercasePlural": namer.NewAllLowercasePluralNamer(pluralExceptions),
		"lowercaseSingular":  &lowercaseSingularNamer{},
	}
}

type lowercaseSingularNamer struct{}

func (n *lowercaseSingularNamer) Name(t *types.Type) string {
	return strings.ToLower(t.Name.Name)
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func generatedBy(customArgs listergenargs.Args) string {
	if len(customArgs.CmdArgs) != 0 {
		return fmt.Sprintf("\n// This file was automatically generated by lister-gen with arguments: %s\n\n", customArgs.CmdArgs)
	}
	return fmt.Sprintf("\n// This file was automatically generated by lister-gen with the default arguments.\n\n")
}

// Packages makes the client package definition.
func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	customArgs, ok := arguments.CustomArgs.(listergenargs.Args)
	if !ok {
		glog.Fatalf("cannot convert arguments.CustomArgs to clientgenargs.Args")
	}

	pflag.VisitAll(func(f *pflag.Flag) {
		if !f.Changed {
			return
		}
		customArgs.CmdArgs = customArgs.CmdArgs + fmt.Sprintf("--%s=%s ", f.Name, f.Value)
	})

	includedTypesOverrides := customArgs.IncludedTypesOverrides

	generatedBy := generatedBy(customArgs)
	boilerplate = append(boilerplate, []byte(generatedBy)...)

	gvToTypes := map[unversioned.GroupVersion][]*types.Type{}
	for gv, inputDir := range customArgs.GroupVersionToInputPath {
		p := context.Universe.Package(inputDir)
		for n, t := range p.Types {
			// filter out types which are not included in user specified overrides.
			typesOverride, ok := includedTypesOverrides[gv]
			if ok {
				found := false
				for _, typeStr := range typesOverride {
					if typeStr == n {
						found = true
						break
					}
				}
				if !found {
					continue
				}
			} else {
				// User has not specified any override for this group version.
				// filter out types which dont have genclient=true.
				if extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == false {
					continue
				}
			}
			if _, found := gvToTypes[gv]; !found {
				gvToTypes[gv] = []*types.Type{}
			}
			gvToTypes[gv] = append(gvToTypes[gv], t)
		}
	}

	var packageList generator.Packages

	orderer := namer.Orderer{Namer: namer.NewPrivateNamer(0)}
	for i := range customArgs.GroupVersions {
		gv := customArgs.GroupVersions[i]

		packageList = append(packageList, &generator.DefaultPackage{
			PackageName: filepath.Base(arguments.OutputPackagePath),
			PackagePath: arguments.OutputPackagePath,
			HeaderText:  boilerplate,
			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
				return []generator.Generator{
					&genListers{
						DefaultGen: generator.DefaultGen{
							OptionalName: arguments.OutputFileBaseName + "." + normalization.BeforeFirstDot(gv.Group),
						},
						outputPackage: arguments.OutputPackagePath,
						groupVersion:  gv,
						types:         orderer.OrderTypes(gvToTypes[gv]),
						imports:       generator.NewImportTracker(),
					},
				}
			},
			FilterFunc: func(c *generator.Context, t *types.Type) bool {
				// piggy-back on types that are tagged for client-gen
				return extractBoolTagOrDie("genclient", t.SecondClosestCommentLines) == true
			},
		})
	}

	return packageList
}

// genListers produces a file of listers for a group.
type genListers struct {
	generator.DefaultGen
	outputPackage string
	groupVersion  unversioned.GroupVersion
	// types in this group
	types   []*types.Type
	imports namer.ImportTracker
	// if true, we need to import k8s.io/kubernetes/pkg/api
	hasNonNamespaced bool
}

var _ generator.Generator = &genListers{}

func (g *genListers) Filter(c *generator.Context, t *types.Type) bool {
	return t == g.types[0]
}

func (g *genListers) Namers(c *generator.Context) namer.NameSystems {
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.outputPackage, g.imports),
	}
}

func (g *genListers) Imports(c *generator.Context) (imports []string) {
	if g.hasNonNamespaced {
		objectMeta := c.Universe.Type(types.Name{Package: "k8s.io/kubernetes/pkg/api", Name: "ObjectMeta"})
		g.imports.AddType(objectMeta)
	}
	imports = append(imports, g.imports.ImportLines()...)
	imports = append(imports, "k8s.io/kubernetes/pkg/api/errors")
	imports = append(imports, "k8s.io/kubernetes/pkg/labels")
	return
}

func (g *genListers) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	glog.Infof("ANDY OptionalName=%s", g.DefaultGen.OptionalName)
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	groupName := g.groupVersion.Group
	if g.groupVersion.Group == "core" {
		groupName = "api"
	}

	sw.Do(example, nil)

	for _, t := range g.types {
		glog.V(5).Infof("processing type %v", t)
		m := map[string]interface{}{
			"group": groupName,
			"type":  t,
		}
		sw.Do(storeToTypeLister, m)
		sw.Do(storeToTypeLister_List, m)
		namespaced := !extractBoolTagOrDie("nonNamespaced", t.SecondClosestCommentLines)
		if namespaced {
			sw.Do(storeToTypeLister_Namespacer, m)
			sw.Do(namespacer, m)
			sw.Do(namespacer_List, m)
			sw.Do(namespacer_Get, m)
		} else {
			g.hasNonNamespaced = true
			sw.Do(storeToTypeLister_NonNamespacedGet, m)
		}
	}

	return sw.Error()
}

var example = `
// Lister makes an Index have the List method.  The Stores must contain only the expected type
// Example:
// s := cache.NewStore()
// lw := cache.ListWatch{Client: c, FieldSelector: sel, Resource: "pods"}
// r := cache.NewReflector(lw, &api.Pod{}, s).Run()
// l := StoreToPodLister{s}
// l.List()

`

var storeToTypeLister = `
// StoreTo$.type|public$Lister makes a Store that lists $.type|publicPlural$.
type StoreTo$.type|public$Lister struct {
	Indexer Indexer
}
`

var storeToTypeLister_List = `
// List lists all $.type|publicPlural$ in the store.
func (s *StoreTo$.type|public$Lister) List(selector labels.Selector) (ret []*$.type|raw$, err error) {
	err = ListAll(s.Indexer, selector, func(m interface{}) {
		ret = append(ret, m.(*$.type|raw$))
	})
	return ret, err
}
`

var storeToTypeLister_Namespacer = `
// $.type|publicPlural$ returns an object that can List and Get $.type|publicPlural$.
func (s *StoreTo$.type|public$Lister) $.type|publicPlural$(namespace string) store$.type|publicPlural$Namespacer {
	return store$.type|publicPlural$Namespacer{Indexer: s.Indexer, namespace: namespace}
}
`

var storeToTypeLister_NonNamespacedGet = `
// Get retrieves the $.type|public$ from the store for a given name.
func (s *StoreTo$.type|public$Lister) Get(name string) (*$.type|raw$, error) {
  key := &$.type|raw${ObjectMeta: api.ObjectMeta{Name: name}}
  obj, exists, err := s.Indexer.Get(key)
  if err != nil {
    return nil, err
  }
  if !exists {
    return nil, errors.NewNotFound($.group$.Resource("$.type|lowercaseSingular$"), name)
  }
  return obj.(*$.type|raw$), nil
}
`

var namespacer = `
type store$.type|publicPlural$Namespacer struct {
	Indexer Indexer
	namespace string
}
`

var namespacer_List = `
// List lists all $.type|publicPlural$ in the store for a given namespace.
func (s store$.type|publicPlural$Namespacer) List(selector labels.Selector) (ret []*$.type|raw$, err error) {
	err = ListAllByNamespace(s.Indexer, s.namespace, selector, func(m interface{}) {
		ret = append(ret, m.(*$.type|raw$))
	})
	return ret, err
}
`

var namespacer_Get = `
// Get retrieves the $.type|public$ from the store for a given namespace and name.
func (s store$.type|publicPlural$Namespacer) Get(name string) (*$.type|raw$, error) {
	obj, exists, err := s.Indexer.GetByKey(s.namespace + "/" + name)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound($.group$.Resource("$.type|lowercaseSingular$"), name)
	}
	return obj.(*$.type|raw$), nil
}
`
