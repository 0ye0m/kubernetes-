/*
Copyright 2014 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	compute "code.google.com/p/google-api-go-client/compute/v1"
	"encoding/json"
	"github.com/GoogleCloudPlatform/kubernetes/pkg/util/iptables"
	"github.com/golang/glog"
	"google.golang.org/cloud/compute/metadata"
	"strings"
)

func applyFirewallRules(firewallRules []*compute.Firewall) error {
	selfTags, err := getTags()
	if err != nil {
		return err
	}

	var k8FirewallRules []*compute.Firewall
	var k8DestIPs []string
	var userFirewallRules []*compute.Firewall

	for _, firewallRule := range firewallRules {
		glog.V(0).Infof("\n Evaluating Rule: %+v", firewallRule.Name)
		if firewallRule.SourceRanges == nil || len(firewallRule.SourceRanges) == 0 {
			continue
		}
		if !tagsMatch(firewallRule.TargetTags, selfTags) {
			glog.V(0).Infof("Rule does not apply to instance: %+v", firewallRule.Name)
			continue
		}
		glog.V(0).Infof("Rule tags match instance tags: %+v", firewallRule.Name)
		destinationIP := parseDestinationIP(firewallRule.Description)

		if destinationIP != "" {
			// isKubeSvcRule
			glog.V(0).Infof("Will only allow public traffic for KubeFirewallRule from LB %v.", destinationIP)
			k8FirewallRules = append(k8FirewallRules, firewallRule)
			k8DestIPs = append(k8DestIPs, destinationIP)
		} else {
			// is user rule
			glog.V(0).Infof("Found User Firewall to mirror. %+v", firewallRule.Name)
			userFirewallRules = append(userFirewallRules, firewallRule)
		}
	}

	iptablesExecutor := NewIpTablesExecutor()

	if len(k8FirewallRules) == 0 {
		// nothing to do
		// clear all custom rules and return
		glog.Infof("Customer firewall rules not found. Will remove custom iptable rules")
		removeAllCustomRules(iptablesExecutor)
		return nil
	}

	newChain, err := iptablesExecutor.CreateNewChainWithRandomName()
	if err != nil {
		glog.Errorf("Could not create new chain: %v", err)
		return err
	} else {
		glog.Infof("Created new chain: %v", newChain)
	}
	err = iptablesExecutor.AppendAllowLocalTrafficRule(newChain)
	if err != nil {
		glog.Errorf("Could not add AllowLocalTrafficRule: %v", err)
		return err
	} else {
		glog.Infof("Added AllowLocalTrafficRule to chain:%v", newChain)
	}

	err = applyUserFirewallRules(iptablesExecutor, newChain, userFirewallRules)
	if err != nil {
		glog.Errorf("Error applying UserFirewall rules. %+v", err)
		return err
	}

	err = applyK8FirewallRules(iptablesExecutor, newChain, k8FirewallRules, k8DestIPs)
	if err != nil {
		glog.Errorf("Error applying Kubernetes Firewall rules. %+v", err)
		return err
	}

	// add new chain to firewall
	_, err = iptablesExecutor.EnsureFirewallChain()
	if err != nil {
		glog.Errorf("Could not create firewall chain: %v", err)
		return err
	} else {
		glog.Infof("Ensured that connected firewall chain exists")
	}

	_, err = iptablesExecutor.AppendDenyAllRule(newChain)
	if err != nil {
		glog.Errorf("Could not append deny all rule: %v", err)
		return err
	} else {
		glog.Infof("Appended Deny All rule.")
	}

	done, err := iptablesExecutor.ExculsiveChainToFirewallChain(newChain)
	if !done {
		glog.Errorf("Could not prepend newly created custom chain to firewall chain: %v", err)
		return err
	} else {
		glog.Infof("Attached chain:%v to firewall chain. err:%v", newChain, err)
		return nil
	}
}

func parseDestinationIP(text string) string {
	lines := strings.Split(text, "\n")
	for _, line := range lines {
		substrings := strings.SplitN(line, "_", 3)
		glog.Infof("Dest IP Regex %s", substrings[0])
		if len(substrings) != 3 {
			continue
		}
		if substrings[0] != "KubernetesAutoGenerated" {
			continue
		}
		if substrings[1] != "OnlyAllowTrafficForDestinationIP" {
			continue
		}
		return substrings[2]
	}
	return ""
}

func removeAllCustomRules(iptablesExecutor IptablesExecutor) error {
	return iptablesExecutor.FlushFirewallChain()
}

func applyUserFirewallRules(iptablesExecutor IptablesExecutor, chain iptables.Chain, userFirewallRules []*compute.Firewall) error {
	for _, firewall := range userFirewallRules {
		for _, allowed := range firewall.Allowed {
			protocol := allowed.IPProtocol
			ports := allowed.Ports
			err := iptablesExecutor.AppendAllowTrafficRule(chain, firewall.Name, firewall.SourceRanges, protocol, ports)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func applyK8FirewallRules(iptablesExecutor IptablesExecutor, chain iptables.Chain, k8FirewallRules []*compute.Firewall, k8DestIPs []string) error {
	for i, firewall := range k8FirewallRules {
		destIPAddress := k8DestIPs[i]
		for _, allowed := range firewall.Allowed {
			protocol := allowed.IPProtocol
			ports := allowed.Ports
			glog.Infof("\nCreating k8S rule %s", firewall.Name)
			err := iptablesExecutor.AppendAllowTrafficByDestIPRule(chain, firewall.Name, firewall.SourceRanges, destIPAddress, protocol, ports)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func tagsMatch(ruleTags, instanceTags []string) bool {
	if len(ruleTags) == 0 {
		return true
	}
	glog.Infof("Matching tags ruleTags: %+v, instanceTags: %+v", ruleTags, instanceTags)
	for _, ruleTag := range ruleTags {
		for _, instanceTag := range instanceTags {
			if ruleTag == instanceTag {
				return true
			}
		}
	}
	return false
}

func getTags() ([]string, error) {
	result, err := metadata.Get("instance/tags")
	if err != nil {
		return nil, err
	}
	var tags []interface{}
	json.Unmarshal([]byte(result), &tags)
	glog.Infof("Tags are %+v", tags)
	var retval []string
	for _, val := range tags {
		retval = append(retval, val.(string))
	}
	return retval, nil
}
