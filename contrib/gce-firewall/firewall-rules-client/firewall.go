/*
Copyright 2014 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bytes"
	compute "code.google.com/p/google-api-go-client/compute/v1"
	"encoding/json"
	"fmt"
	"github.com/golang/glog"
	"google.golang.org/cloud/compute/metadata"
	"strings"
)

const (
	K8S_FORWARDED_TRAFFIC_MARK int = 0x70617373 // 'pass' is ascii
)

func applyFirewallRules(firewallRules []*compute.Firewall) error {
	selfTags, err := getTags()
	if err != nil {
		return err
	}

	var k8FirewallRules []*compute.Firewall
	var k8DestIPs []string
	var userFirewallRules []*compute.Firewall

	for _, firewallRule := range firewallRules {
		glog.V(0).Infof("\n Evaluating Rule: %+v", firewallRule.Name)
		if firewallRule.SourceRanges == nil || len(firewallRule.SourceRanges) == 0 {
			continue
		}
		if !tagsMatch(firewallRule.TargetTags, selfTags) {
			glog.V(0).Infof("Rule does not apply to instance: %+v", firewallRule.Name)
			continue
		}
		glog.V(0).Infof("Rule tags match instance tags: %+v", firewallRule.Name)
		destinationIP := parseDestinationIP(firewallRule.Description)

		if destinationIP != "" {
			// isKubeSvcRule
			glog.V(0).Infof("Will only allow public traffic for KubeFirewallRule from LB %v.", destinationIP)
			k8FirewallRules = append(k8FirewallRules, firewallRule)
			k8DestIPs = append(k8DestIPs, destinationIP)
		} else {
			// is user rule
			glog.V(0).Infof("Found User Firewall to mirror. %+v", firewallRule.Name)
			userFirewallRules = append(userFirewallRules, firewallRule)
		}
	}

	iptablesExecutor := NewIpTablesExecutor()
	err = iptablesExecutor.EnsureConnectedFirewallChains()
	if err != nil {
		return err
	}
	if len(k8FirewallRules) == 0 {
		// nothing to do
		// clear all custom rules and return
		glog.Infof("Customer firewall rules not found. Will remove custom iptable rules")
		return iptablesExecutor.FlushFirewallChains()
	}

	mangleRules := createMangleTableRules(k8FirewallRules, k8DestIPs)
	filterRules := createFilterTableRules(userFirewallRules)

	// apply mangle:prerouting:firewall rules
	err = iptablesExecutor.RestoreAll(mangleRules)
	if err != nil {
		return err
	}

	// apply filter:input:firewall rules
	err = iptablesExecutor.RestoreAll(filterRules)
	if err != nil {
		return err
	}
	return nil
}

// create mangle table:prerouting:firewall chain rules
func createMangleTableRules(k8FirewallRules []*compute.Firewall, k8DestIPs []string) []byte {
	mangleLines := bytes.NewBuffer(nil)
	writeLine(mangleLines, "*mangle")
	flushFirewallChain(mangleLines)
	markKubernetesForwardingRuleTraffic(mangleLines, k8FirewallRules, k8DestIPs)
	writeLine(mangleLines, "COMMIT")
	return mangleLines.Bytes()
}

// create filter table:input:firewall chain rules
func createFilterTableRules(userFirewallRules []*compute.Firewall) []byte {
	filterLines := bytes.NewBuffer(nil)
	writeLine(filterLines, "*filter")
	flushFirewallChain(filterLines)
	appendAllowLocalTrafficRule(filterLines)
	applyUserFirewallRules(filterLines, userFirewallRules)
	allowMarkedTraffic(filterLines)
	appendDenyAllRule(filterLines)
	writeLine(filterLines, "COMMIT")
	return filterLines.Bytes()
}

func parseDestinationIP(text string) string {
	lines := strings.Split(text, "\n")
	for _, line := range lines {
		substrings := strings.SplitN(line, "_", 3)
		glog.Infof("Dest IP Regex %s", substrings[0])
		if len(substrings) != 3 {
			continue
		}
		if substrings[0] != "KubernetesAutoGenerated" {
			continue
		}
		if substrings[1] != "OnlyAllowTrafficForDestinationIP" {
			continue
		}
		return substrings[2]
	}
	return ""
}

func flushFirewallChain(lines *bytes.Buffer) {
	writeLine(lines, fmt.Sprintf("-F %s", ChainFirewallName))
}

func appendDenyAllRule(filterLines *bytes.Buffer) {
	writeLine(filterLines, fmt.Sprintf("-A %s -j DROP", ChainFirewallName))
}

func appendAllowLocalTrafficRule(filterLines *bytes.Buffer) {
	line := fmt.Sprintf("-A %s -m comment --comment allow-outbound-traffic -m state --state ESTABLISHED,RELATED -j RETURN", ChainFirewallName)
	writeLine(filterLines, line)

	line = fmt.Sprintf("-A %s -m comment --comment allow-local-src-addreses -m addrtype --src-type LOCAL -j RETURN", ChainFirewallName)
	writeLine(filterLines, line)

	localCIDRs := []string{"10.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.168.0.0/16"}
	for _, localCIDR := range localCIDRs {
		line = fmt.Sprintf("-A %s -m comment --comment allow-%s-addresses -s %s -j RETURN", ChainFirewallName, localCIDR, localCIDR)
		writeLine(filterLines, line)
	}
}

func applyUserFirewallRules(filterLines *bytes.Buffer, userFirewallRules []*compute.Firewall) {
	for _, firewall := range userFirewallRules {
		for _, allowed := range firewall.Allowed {
			protocol := allowed.IPProtocol
			ports := allowed.Ports
			appendAllowTrafficRule(filterLines, firewall.Name, firewall.SourceRanges, protocol, ports)
		}
	}
	return
}

func appendAllowTrafficRule(filterLines *bytes.Buffer, comment string, sourceIPs []string, protocol string, ports []string) {
	if ports == nil || len(ports) == 0 {
		for _, sourceIP := range sourceIPs {
			line := fmt.Sprintf("-A %s -m comment --comment %s -p %s -s %s -j RETURN", ChainFirewallName, comment, protocol, sourceIP)
			writeLine(filterLines, line)
		}
		return
	}

	for _, port := range ports {
		port = strings.Replace(port, "-", ":", 1)
		for _, sourceIP := range sourceIPs {
			line := fmt.Sprintf("-A %s -m comment --comment %s -p %s -s %s -m %s --dport %s -j RETURN", ChainFirewallName, comment, protocol, sourceIP, protocol, port)
			writeLine(filterLines, line)
		}
	}
}

func markKubernetesForwardingRuleTraffic(mangleLines *bytes.Buffer, k8FirewallRules []*compute.Firewall, k8DestIPs []string) {
	for i, firewall := range k8FirewallRules {
		destIPAddress := k8DestIPs[i]
		for _, allowed := range firewall.Allowed {
			protocol := allowed.IPProtocol
			ports := allowed.Ports
			glog.Infof("\nCreating k8S rule %s", firewall.Name)
			markTrafficByDestIPRule(mangleLines, firewall.Name, firewall.SourceRanges, destIPAddress, protocol, ports, K8S_FORWARDED_TRAFFIC_MARK)
		}
	}
}

func allowMarkedTraffic(filterLines *bytes.Buffer) {
	line := fmt.Sprintf("-A %s -m comment --comment k8s-forwarding-rule-traffic -m mark --mark %d -j RETURN", ChainFirewallName, K8S_FORWARDED_TRAFFIC_MARK)
	writeLine(filterLines, line)
}

func markTrafficByDestIPRule(mangleLines *bytes.Buffer, comment string, sourceIPs []string, destIPAddress, protocol string, ports []string, mark int) {
	if ports == nil || len(ports) == 0 {
		for _, sourceIP := range sourceIPs {
			line := fmt.Sprintf("-A %s -m comment --comment %s -p %s -s %s -m %s -d %s -j MARK  --set-mark %d", ChainFirewallName, comment, protocol, sourceIP, protocol, destIPAddress, mark)
			writeLine(mangleLines, line)
		}
		return
	}
	for _, port := range ports {
		port = strings.Replace(port, "-", ":", 1)
		for _, sourceIP := range sourceIPs {
			line := fmt.Sprintf("-A %s -m comment --comment %s -p %s -s %s -d %s -m %s --dport %s -j MARK --set-mark %d", ChainFirewallName, comment, protocol, sourceIP, destIPAddress, protocol, port, mark)
			writeLine(mangleLines, line)
		}
	}
	return
}

func tagsMatch(ruleTags, instanceTags []string) bool {
	if len(ruleTags) == 0 {
		return true
	}
	glog.Infof("Matching tags ruleTags: %+v, instanceTags: %+v", ruleTags, instanceTags)
	for _, ruleTag := range ruleTags {
		for _, instanceTag := range instanceTags {
			if ruleTag == instanceTag {
				return true
			}
		}
	}
	return false
}

func getTags() ([]string, error) {
	result, err := metadata.Get("instance/tags")
	if err != nil {
		return nil, err
	}
	var tags []interface{}
	json.Unmarshal([]byte(result), &tags)
	glog.Infof("Tags are %+v", tags)
	var retval []string
	for _, val := range tags {
		retval = append(retval, val.(string))
	}
	return retval, nil
}

// Join all words with spaces, terminate with newline and write to buf.
func writeLine(buf *bytes.Buffer, words ...string) {
	buf.WriteString(strings.Join(words, " ") + "\n")
}
