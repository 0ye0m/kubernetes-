// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	sync "sync"

	csi "github.com/container-storage-interface/spec/lib/go/csi"
	v1alpha1 "k8s.io/csi-api/pkg/apis/csi/v1alpha1"
	nodeinfomanager "k8s.io/kubernetes/pkg/volume/csi/nodeinfomanager"
)

type FakeNodeInfoManager struct {
	CreateCSINodeInfoStub        func() (*v1alpha1.CSINodeInfo, error)
	createCSINodeInfoMutex       sync.RWMutex
	createCSINodeInfoArgsForCall []struct {
	}
	createCSINodeInfoReturns struct {
		result1 *v1alpha1.CSINodeInfo
		result2 error
	}
	createCSINodeInfoReturnsOnCall map[int]struct {
		result1 *v1alpha1.CSINodeInfo
		result2 error
	}
	InstallCSIDriverStub        func(string, string, int64, *csi.Topology) error
	installCSIDriverMutex       sync.RWMutex
	installCSIDriverArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int64
		arg4 *csi.Topology
	}
	installCSIDriverReturns struct {
		result1 error
	}
	installCSIDriverReturnsOnCall map[int]struct {
		result1 error
	}
	UninstallCSIDriverStub        func(string) error
	uninstallCSIDriverMutex       sync.RWMutex
	uninstallCSIDriverArgsForCall []struct {
		arg1 string
	}
	uninstallCSIDriverReturns struct {
		result1 error
	}
	uninstallCSIDriverReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeInfoManager) CreateCSINodeInfo() (*v1alpha1.CSINodeInfo, error) {
	fake.createCSINodeInfoMutex.Lock()
	ret, specificReturn := fake.createCSINodeInfoReturnsOnCall[len(fake.createCSINodeInfoArgsForCall)]
	fake.createCSINodeInfoArgsForCall = append(fake.createCSINodeInfoArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateCSINodeInfo", []interface{}{})
	fake.createCSINodeInfoMutex.Unlock()
	if fake.CreateCSINodeInfoStub != nil {
		return fake.CreateCSINodeInfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createCSINodeInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInfoManager) CreateCSINodeInfoCallCount() int {
	fake.createCSINodeInfoMutex.RLock()
	defer fake.createCSINodeInfoMutex.RUnlock()
	return len(fake.createCSINodeInfoArgsForCall)
}

func (fake *FakeNodeInfoManager) CreateCSINodeInfoCalls(stub func() (*v1alpha1.CSINodeInfo, error)) {
	fake.createCSINodeInfoMutex.Lock()
	defer fake.createCSINodeInfoMutex.Unlock()
	fake.CreateCSINodeInfoStub = stub
}

func (fake *FakeNodeInfoManager) CreateCSINodeInfoReturns(result1 *v1alpha1.CSINodeInfo, result2 error) {
	fake.createCSINodeInfoMutex.Lock()
	defer fake.createCSINodeInfoMutex.Unlock()
	fake.CreateCSINodeInfoStub = nil
	fake.createCSINodeInfoReturns = struct {
		result1 *v1alpha1.CSINodeInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInfoManager) CreateCSINodeInfoReturnsOnCall(i int, result1 *v1alpha1.CSINodeInfo, result2 error) {
	fake.createCSINodeInfoMutex.Lock()
	defer fake.createCSINodeInfoMutex.Unlock()
	fake.CreateCSINodeInfoStub = nil
	if fake.createCSINodeInfoReturnsOnCall == nil {
		fake.createCSINodeInfoReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.CSINodeInfo
			result2 error
		})
	}
	fake.createCSINodeInfoReturnsOnCall[i] = struct {
		result1 *v1alpha1.CSINodeInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInfoManager) InstallCSIDriver(arg1 string, arg2 string, arg3 int64, arg4 *csi.Topology) error {
	fake.installCSIDriverMutex.Lock()
	ret, specificReturn := fake.installCSIDriverReturnsOnCall[len(fake.installCSIDriverArgsForCall)]
	fake.installCSIDriverArgsForCall = append(fake.installCSIDriverArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int64
		arg4 *csi.Topology
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("InstallCSIDriver", []interface{}{arg1, arg2, arg3, arg4})
	fake.installCSIDriverMutex.Unlock()
	if fake.InstallCSIDriverStub != nil {
		return fake.InstallCSIDriverStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.installCSIDriverReturns
	return fakeReturns.result1
}

func (fake *FakeNodeInfoManager) InstallCSIDriverCallCount() int {
	fake.installCSIDriverMutex.RLock()
	defer fake.installCSIDriverMutex.RUnlock()
	return len(fake.installCSIDriverArgsForCall)
}

func (fake *FakeNodeInfoManager) InstallCSIDriverCalls(stub func(string, string, int64, *csi.Topology) error) {
	fake.installCSIDriverMutex.Lock()
	defer fake.installCSIDriverMutex.Unlock()
	fake.InstallCSIDriverStub = stub
}

func (fake *FakeNodeInfoManager) InstallCSIDriverArgsForCall(i int) (string, string, int64, *csi.Topology) {
	fake.installCSIDriverMutex.RLock()
	defer fake.installCSIDriverMutex.RUnlock()
	argsForCall := fake.installCSIDriverArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNodeInfoManager) InstallCSIDriverReturns(result1 error) {
	fake.installCSIDriverMutex.Lock()
	defer fake.installCSIDriverMutex.Unlock()
	fake.InstallCSIDriverStub = nil
	fake.installCSIDriverReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) InstallCSIDriverReturnsOnCall(i int, result1 error) {
	fake.installCSIDriverMutex.Lock()
	defer fake.installCSIDriverMutex.Unlock()
	fake.InstallCSIDriverStub = nil
	if fake.installCSIDriverReturnsOnCall == nil {
		fake.installCSIDriverReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installCSIDriverReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) UninstallCSIDriver(arg1 string) error {
	fake.uninstallCSIDriverMutex.Lock()
	ret, specificReturn := fake.uninstallCSIDriverReturnsOnCall[len(fake.uninstallCSIDriverArgsForCall)]
	fake.uninstallCSIDriverArgsForCall = append(fake.uninstallCSIDriverArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UninstallCSIDriver", []interface{}{arg1})
	fake.uninstallCSIDriverMutex.Unlock()
	if fake.UninstallCSIDriverStub != nil {
		return fake.UninstallCSIDriverStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uninstallCSIDriverReturns
	return fakeReturns.result1
}

func (fake *FakeNodeInfoManager) UninstallCSIDriverCallCount() int {
	fake.uninstallCSIDriverMutex.RLock()
	defer fake.uninstallCSIDriverMutex.RUnlock()
	return len(fake.uninstallCSIDriverArgsForCall)
}

func (fake *FakeNodeInfoManager) UninstallCSIDriverCalls(stub func(string) error) {
	fake.uninstallCSIDriverMutex.Lock()
	defer fake.uninstallCSIDriverMutex.Unlock()
	fake.UninstallCSIDriverStub = stub
}

func (fake *FakeNodeInfoManager) UninstallCSIDriverArgsForCall(i int) string {
	fake.uninstallCSIDriverMutex.RLock()
	defer fake.uninstallCSIDriverMutex.RUnlock()
	argsForCall := fake.uninstallCSIDriverArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeInfoManager) UninstallCSIDriverReturns(result1 error) {
	fake.uninstallCSIDriverMutex.Lock()
	defer fake.uninstallCSIDriverMutex.Unlock()
	fake.UninstallCSIDriverStub = nil
	fake.uninstallCSIDriverReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) UninstallCSIDriverReturnsOnCall(i int, result1 error) {
	fake.uninstallCSIDriverMutex.Lock()
	defer fake.uninstallCSIDriverMutex.Unlock()
	fake.UninstallCSIDriverStub = nil
	if fake.uninstallCSIDriverReturnsOnCall == nil {
		fake.uninstallCSIDriverReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uninstallCSIDriverReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCSINodeInfoMutex.RLock()
	defer fake.createCSINodeInfoMutex.RUnlock()
	fake.installCSIDriverMutex.RLock()
	defer fake.installCSIDriverMutex.RUnlock()
	fake.uninstallCSIDriverMutex.RLock()
	defer fake.uninstallCSIDriverMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeInfoManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ nodeinfomanager.Interface = new(FakeNodeInfoManager)
