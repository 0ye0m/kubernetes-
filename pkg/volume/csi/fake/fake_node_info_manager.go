/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	csipb "github.com/container-storage-interface/spec/lib/go/csi/v0"
	"k8s.io/kubernetes/pkg/volume/csi/nodeinfomanager"
)

type FakeNodeInfoManager struct {
	AddNodeInfoStub        func(driverName string, driverNodeID string, maxVolumeLimit int64, topology *csipb.Topology) error
	addNodeInfoMutex       sync.RWMutex
	addNodeInfoArgsForCall []struct {
		driverName     string
		driverNodeID   string
		maxVolumeLimit int64
		topology       *csipb.Topology
	}
	addNodeInfoReturns struct {
		result1 error
	}
	addNodeInfoReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveNodeInfoStub        func(driverName string) error
	removeNodeInfoMutex       sync.RWMutex
	removeNodeInfoArgsForCall []struct {
		driverName string
	}
	removeNodeInfoReturns struct {
		result1 error
	}
	removeNodeInfoReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeInfoManager) AddNodeInfo(driverName string, driverNodeID string, maxVolumeLimit int64, topology *csipb.Topology) error {
	fake.addNodeInfoMutex.Lock()
	ret, specificReturn := fake.addNodeInfoReturnsOnCall[len(fake.addNodeInfoArgsForCall)]
	fake.addNodeInfoArgsForCall = append(fake.addNodeInfoArgsForCall, struct {
		driverName     string
		driverNodeID   string
		maxVolumeLimit int64
		topology       *csipb.Topology
	}{driverName, driverNodeID, maxVolumeLimit, topology})
	fake.recordInvocation("AddNodeInfo", []interface{}{driverName, driverNodeID, maxVolumeLimit, topology})
	fake.addNodeInfoMutex.Unlock()
	if fake.AddNodeInfoStub != nil {
		return fake.AddNodeInfoStub(driverName, driverNodeID, maxVolumeLimit, topology)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addNodeInfoReturns.result1
}

func (fake *FakeNodeInfoManager) AddNodeInfoCallCount() int {
	fake.addNodeInfoMutex.RLock()
	defer fake.addNodeInfoMutex.RUnlock()
	return len(fake.addNodeInfoArgsForCall)
}

func (fake *FakeNodeInfoManager) AddNodeInfoArgsForCall(i int) (string, string, int64, *csipb.Topology) {
	fake.addNodeInfoMutex.RLock()
	defer fake.addNodeInfoMutex.RUnlock()
	return fake.addNodeInfoArgsForCall[i].driverName, fake.addNodeInfoArgsForCall[i].driverNodeID, fake.addNodeInfoArgsForCall[i].maxVolumeLimit, fake.addNodeInfoArgsForCall[i].topology
}

func (fake *FakeNodeInfoManager) AddNodeInfoReturns(result1 error) {
	fake.AddNodeInfoStub = nil
	fake.addNodeInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) AddNodeInfoReturnsOnCall(i int, result1 error) {
	fake.AddNodeInfoStub = nil
	if fake.addNodeInfoReturnsOnCall == nil {
		fake.addNodeInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addNodeInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) RemoveNodeInfo(driverName string) error {
	fake.removeNodeInfoMutex.Lock()
	ret, specificReturn := fake.removeNodeInfoReturnsOnCall[len(fake.removeNodeInfoArgsForCall)]
	fake.removeNodeInfoArgsForCall = append(fake.removeNodeInfoArgsForCall, struct {
		driverName string
	}{driverName})
	fake.recordInvocation("RemoveNodeInfo", []interface{}{driverName})
	fake.removeNodeInfoMutex.Unlock()
	if fake.RemoveNodeInfoStub != nil {
		return fake.RemoveNodeInfoStub(driverName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeNodeInfoReturns.result1
}

func (fake *FakeNodeInfoManager) RemoveNodeInfoCallCount() int {
	fake.removeNodeInfoMutex.RLock()
	defer fake.removeNodeInfoMutex.RUnlock()
	return len(fake.removeNodeInfoArgsForCall)
}

func (fake *FakeNodeInfoManager) RemoveNodeInfoArgsForCall(i int) string {
	fake.removeNodeInfoMutex.RLock()
	defer fake.removeNodeInfoMutex.RUnlock()
	return fake.removeNodeInfoArgsForCall[i].driverName
}

func (fake *FakeNodeInfoManager) RemoveNodeInfoReturns(result1 error) {
	fake.RemoveNodeInfoStub = nil
	fake.removeNodeInfoReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) RemoveNodeInfoReturnsOnCall(i int, result1 error) {
	fake.RemoveNodeInfoStub = nil
	if fake.removeNodeInfoReturnsOnCall == nil {
		fake.removeNodeInfoReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeNodeInfoReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInfoManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addNodeInfoMutex.RLock()
	defer fake.addNodeInfoMutex.RUnlock()
	fake.removeNodeInfoMutex.RLock()
	defer fake.removeNodeInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeInfoManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ nodeinfomanager.Interface = new(FakeNodeInfoManager)
