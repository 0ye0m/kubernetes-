/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	csi "github.com/container-storage-interface/spec/lib/go/csi/v0"
	"golang.org/x/net/context"
)

type FakeNodeServer struct {
	NodeStageVolumeStub        func(context.Context, *csi.NodeStageVolumeRequest) (*csi.NodeStageVolumeResponse, error)
	nodeStageVolumeMutex       sync.RWMutex
	nodeStageVolumeArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodeStageVolumeRequest
	}
	nodeStageVolumeReturns struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}
	nodeStageVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}
	NodeUnstageVolumeStub        func(context.Context, *csi.NodeUnstageVolumeRequest) (*csi.NodeUnstageVolumeResponse, error)
	nodeUnstageVolumeMutex       sync.RWMutex
	nodeUnstageVolumeArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodeUnstageVolumeRequest
	}
	nodeUnstageVolumeReturns struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}
	nodeUnstageVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}
	NodePublishVolumeStub        func(context.Context, *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error)
	nodePublishVolumeMutex       sync.RWMutex
	nodePublishVolumeArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodePublishVolumeRequest
	}
	nodePublishVolumeReturns struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}
	nodePublishVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}
	NodeUnpublishVolumeStub        func(context.Context, *csi.NodeUnpublishVolumeRequest) (*csi.NodeUnpublishVolumeResponse, error)
	nodeUnpublishVolumeMutex       sync.RWMutex
	nodeUnpublishVolumeArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodeUnpublishVolumeRequest
	}
	nodeUnpublishVolumeReturns struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}
	nodeUnpublishVolumeReturnsOnCall map[int]struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}
	NodeGetIdStub        func(context.Context, *csi.NodeGetIdRequest) (*csi.NodeGetIdResponse, error)
	nodeGetIdMutex       sync.RWMutex
	nodeGetIdArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodeGetIdRequest
	}
	nodeGetIdReturns struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}
	nodeGetIdReturnsOnCall map[int]struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}
	NodeGetCapabilitiesStub        func(context.Context, *csi.NodeGetCapabilitiesRequest) (*csi.NodeGetCapabilitiesResponse, error)
	nodeGetCapabilitiesMutex       sync.RWMutex
	nodeGetCapabilitiesArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodeGetCapabilitiesRequest
	}
	nodeGetCapabilitiesReturns struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}
	nodeGetCapabilitiesReturnsOnCall map[int]struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}
	NodeGetInfoStub        func(context.Context, *csi.NodeGetInfoRequest) (*csi.NodeGetInfoResponse, error)
	nodeGetInfoMutex       sync.RWMutex
	nodeGetInfoArgsForCall []struct {
		arg1 context.Context
		arg2 *csi.NodeGetInfoRequest
	}
	nodeGetInfoReturns struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}
	nodeGetInfoReturnsOnCall map[int]struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeServer) NodeStageVolume(arg1 context.Context, arg2 *csi.NodeStageVolumeRequest) (*csi.NodeStageVolumeResponse, error) {
	fake.nodeStageVolumeMutex.Lock()
	ret, specificReturn := fake.nodeStageVolumeReturnsOnCall[len(fake.nodeStageVolumeArgsForCall)]
	fake.nodeStageVolumeArgsForCall = append(fake.nodeStageVolumeArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodeStageVolumeRequest
	}{arg1, arg2})
	fake.recordInvocation("NodeStageVolume", []interface{}{arg1, arg2})
	fake.nodeStageVolumeMutex.Unlock()
	if fake.NodeStageVolumeStub != nil {
		return fake.NodeStageVolumeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeStageVolumeReturns.result1, fake.nodeStageVolumeReturns.result2
}

func (fake *FakeNodeServer) NodeStageVolumeCallCount() int {
	fake.nodeStageVolumeMutex.RLock()
	defer fake.nodeStageVolumeMutex.RUnlock()
	return len(fake.nodeStageVolumeArgsForCall)
}

func (fake *FakeNodeServer) NodeStageVolumeArgsForCall(i int) (context.Context, *csi.NodeStageVolumeRequest) {
	fake.nodeStageVolumeMutex.RLock()
	defer fake.nodeStageVolumeMutex.RUnlock()
	return fake.nodeStageVolumeArgsForCall[i].arg1, fake.nodeStageVolumeArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodeStageVolumeReturns(result1 *csi.NodeStageVolumeResponse, result2 error) {
	fake.NodeStageVolumeStub = nil
	fake.nodeStageVolumeReturns = struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeStageVolumeReturnsOnCall(i int, result1 *csi.NodeStageVolumeResponse, result2 error) {
	fake.NodeStageVolumeStub = nil
	if fake.nodeStageVolumeReturnsOnCall == nil {
		fake.nodeStageVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeStageVolumeResponse
			result2 error
		})
	}
	fake.nodeStageVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodeStageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeUnstageVolume(arg1 context.Context, arg2 *csi.NodeUnstageVolumeRequest) (*csi.NodeUnstageVolumeResponse, error) {
	fake.nodeUnstageVolumeMutex.Lock()
	ret, specificReturn := fake.nodeUnstageVolumeReturnsOnCall[len(fake.nodeUnstageVolumeArgsForCall)]
	fake.nodeUnstageVolumeArgsForCall = append(fake.nodeUnstageVolumeArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodeUnstageVolumeRequest
	}{arg1, arg2})
	fake.recordInvocation("NodeUnstageVolume", []interface{}{arg1, arg2})
	fake.nodeUnstageVolumeMutex.Unlock()
	if fake.NodeUnstageVolumeStub != nil {
		return fake.NodeUnstageVolumeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeUnstageVolumeReturns.result1, fake.nodeUnstageVolumeReturns.result2
}

func (fake *FakeNodeServer) NodeUnstageVolumeCallCount() int {
	fake.nodeUnstageVolumeMutex.RLock()
	defer fake.nodeUnstageVolumeMutex.RUnlock()
	return len(fake.nodeUnstageVolumeArgsForCall)
}

func (fake *FakeNodeServer) NodeUnstageVolumeArgsForCall(i int) (context.Context, *csi.NodeUnstageVolumeRequest) {
	fake.nodeUnstageVolumeMutex.RLock()
	defer fake.nodeUnstageVolumeMutex.RUnlock()
	return fake.nodeUnstageVolumeArgsForCall[i].arg1, fake.nodeUnstageVolumeArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodeUnstageVolumeReturns(result1 *csi.NodeUnstageVolumeResponse, result2 error) {
	fake.NodeUnstageVolumeStub = nil
	fake.nodeUnstageVolumeReturns = struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeUnstageVolumeReturnsOnCall(i int, result1 *csi.NodeUnstageVolumeResponse, result2 error) {
	fake.NodeUnstageVolumeStub = nil
	if fake.nodeUnstageVolumeReturnsOnCall == nil {
		fake.nodeUnstageVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeUnstageVolumeResponse
			result2 error
		})
	}
	fake.nodeUnstageVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodeUnstageVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodePublishVolume(arg1 context.Context, arg2 *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error) {
	fake.nodePublishVolumeMutex.Lock()
	ret, specificReturn := fake.nodePublishVolumeReturnsOnCall[len(fake.nodePublishVolumeArgsForCall)]
	fake.nodePublishVolumeArgsForCall = append(fake.nodePublishVolumeArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodePublishVolumeRequest
	}{arg1, arg2})
	fake.recordInvocation("NodePublishVolume", []interface{}{arg1, arg2})
	fake.nodePublishVolumeMutex.Unlock()
	if fake.NodePublishVolumeStub != nil {
		return fake.NodePublishVolumeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodePublishVolumeReturns.result1, fake.nodePublishVolumeReturns.result2
}

func (fake *FakeNodeServer) NodePublishVolumeCallCount() int {
	fake.nodePublishVolumeMutex.RLock()
	defer fake.nodePublishVolumeMutex.RUnlock()
	return len(fake.nodePublishVolumeArgsForCall)
}

func (fake *FakeNodeServer) NodePublishVolumeArgsForCall(i int) (context.Context, *csi.NodePublishVolumeRequest) {
	fake.nodePublishVolumeMutex.RLock()
	defer fake.nodePublishVolumeMutex.RUnlock()
	return fake.nodePublishVolumeArgsForCall[i].arg1, fake.nodePublishVolumeArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodePublishVolumeReturns(result1 *csi.NodePublishVolumeResponse, result2 error) {
	fake.NodePublishVolumeStub = nil
	fake.nodePublishVolumeReturns = struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodePublishVolumeReturnsOnCall(i int, result1 *csi.NodePublishVolumeResponse, result2 error) {
	fake.NodePublishVolumeStub = nil
	if fake.nodePublishVolumeReturnsOnCall == nil {
		fake.nodePublishVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodePublishVolumeResponse
			result2 error
		})
	}
	fake.nodePublishVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodePublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeUnpublishVolume(arg1 context.Context, arg2 *csi.NodeUnpublishVolumeRequest) (*csi.NodeUnpublishVolumeResponse, error) {
	fake.nodeUnpublishVolumeMutex.Lock()
	ret, specificReturn := fake.nodeUnpublishVolumeReturnsOnCall[len(fake.nodeUnpublishVolumeArgsForCall)]
	fake.nodeUnpublishVolumeArgsForCall = append(fake.nodeUnpublishVolumeArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodeUnpublishVolumeRequest
	}{arg1, arg2})
	fake.recordInvocation("NodeUnpublishVolume", []interface{}{arg1, arg2})
	fake.nodeUnpublishVolumeMutex.Unlock()
	if fake.NodeUnpublishVolumeStub != nil {
		return fake.NodeUnpublishVolumeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeUnpublishVolumeReturns.result1, fake.nodeUnpublishVolumeReturns.result2
}

func (fake *FakeNodeServer) NodeUnpublishVolumeCallCount() int {
	fake.nodeUnpublishVolumeMutex.RLock()
	defer fake.nodeUnpublishVolumeMutex.RUnlock()
	return len(fake.nodeUnpublishVolumeArgsForCall)
}

func (fake *FakeNodeServer) NodeUnpublishVolumeArgsForCall(i int) (context.Context, *csi.NodeUnpublishVolumeRequest) {
	fake.nodeUnpublishVolumeMutex.RLock()
	defer fake.nodeUnpublishVolumeMutex.RUnlock()
	return fake.nodeUnpublishVolumeArgsForCall[i].arg1, fake.nodeUnpublishVolumeArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodeUnpublishVolumeReturns(result1 *csi.NodeUnpublishVolumeResponse, result2 error) {
	fake.NodeUnpublishVolumeStub = nil
	fake.nodeUnpublishVolumeReturns = struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeUnpublishVolumeReturnsOnCall(i int, result1 *csi.NodeUnpublishVolumeResponse, result2 error) {
	fake.NodeUnpublishVolumeStub = nil
	if fake.nodeUnpublishVolumeReturnsOnCall == nil {
		fake.nodeUnpublishVolumeReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeUnpublishVolumeResponse
			result2 error
		})
	}
	fake.nodeUnpublishVolumeReturnsOnCall[i] = struct {
		result1 *csi.NodeUnpublishVolumeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeGetId(arg1 context.Context, arg2 *csi.NodeGetIdRequest) (*csi.NodeGetIdResponse, error) {
	fake.nodeGetIdMutex.Lock()
	ret, specificReturn := fake.nodeGetIdReturnsOnCall[len(fake.nodeGetIdArgsForCall)]
	fake.nodeGetIdArgsForCall = append(fake.nodeGetIdArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodeGetIdRequest
	}{arg1, arg2})
	fake.recordInvocation("NodeGetId", []interface{}{arg1, arg2})
	fake.nodeGetIdMutex.Unlock()
	if fake.NodeGetIdStub != nil {
		return fake.NodeGetIdStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeGetIdReturns.result1, fake.nodeGetIdReturns.result2
}

func (fake *FakeNodeServer) NodeGetIdCallCount() int {
	fake.nodeGetIdMutex.RLock()
	defer fake.nodeGetIdMutex.RUnlock()
	return len(fake.nodeGetIdArgsForCall)
}

func (fake *FakeNodeServer) NodeGetIdArgsForCall(i int) (context.Context, *csi.NodeGetIdRequest) {
	fake.nodeGetIdMutex.RLock()
	defer fake.nodeGetIdMutex.RUnlock()
	return fake.nodeGetIdArgsForCall[i].arg1, fake.nodeGetIdArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodeGetIdReturns(result1 *csi.NodeGetIdResponse, result2 error) {
	fake.NodeGetIdStub = nil
	fake.nodeGetIdReturns = struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeGetIdReturnsOnCall(i int, result1 *csi.NodeGetIdResponse, result2 error) {
	fake.NodeGetIdStub = nil
	if fake.nodeGetIdReturnsOnCall == nil {
		fake.nodeGetIdReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeGetIdResponse
			result2 error
		})
	}
	fake.nodeGetIdReturnsOnCall[i] = struct {
		result1 *csi.NodeGetIdResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeGetCapabilities(arg1 context.Context, arg2 *csi.NodeGetCapabilitiesRequest) (*csi.NodeGetCapabilitiesResponse, error) {
	fake.nodeGetCapabilitiesMutex.Lock()
	ret, specificReturn := fake.nodeGetCapabilitiesReturnsOnCall[len(fake.nodeGetCapabilitiesArgsForCall)]
	fake.nodeGetCapabilitiesArgsForCall = append(fake.nodeGetCapabilitiesArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodeGetCapabilitiesRequest
	}{arg1, arg2})
	fake.recordInvocation("NodeGetCapabilities", []interface{}{arg1, arg2})
	fake.nodeGetCapabilitiesMutex.Unlock()
	if fake.NodeGetCapabilitiesStub != nil {
		return fake.NodeGetCapabilitiesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeGetCapabilitiesReturns.result1, fake.nodeGetCapabilitiesReturns.result2
}

func (fake *FakeNodeServer) NodeGetCapabilitiesCallCount() int {
	fake.nodeGetCapabilitiesMutex.RLock()
	defer fake.nodeGetCapabilitiesMutex.RUnlock()
	return len(fake.nodeGetCapabilitiesArgsForCall)
}

func (fake *FakeNodeServer) NodeGetCapabilitiesArgsForCall(i int) (context.Context, *csi.NodeGetCapabilitiesRequest) {
	fake.nodeGetCapabilitiesMutex.RLock()
	defer fake.nodeGetCapabilitiesMutex.RUnlock()
	return fake.nodeGetCapabilitiesArgsForCall[i].arg1, fake.nodeGetCapabilitiesArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodeGetCapabilitiesReturns(result1 *csi.NodeGetCapabilitiesResponse, result2 error) {
	fake.NodeGetCapabilitiesStub = nil
	fake.nodeGetCapabilitiesReturns = struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeGetCapabilitiesReturnsOnCall(i int, result1 *csi.NodeGetCapabilitiesResponse, result2 error) {
	fake.NodeGetCapabilitiesStub = nil
	if fake.nodeGetCapabilitiesReturnsOnCall == nil {
		fake.nodeGetCapabilitiesReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeGetCapabilitiesResponse
			result2 error
		})
	}
	fake.nodeGetCapabilitiesReturnsOnCall[i] = struct {
		result1 *csi.NodeGetCapabilitiesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeGetInfo(arg1 context.Context, arg2 *csi.NodeGetInfoRequest) (*csi.NodeGetInfoResponse, error) {
	fake.nodeGetInfoMutex.Lock()
	ret, specificReturn := fake.nodeGetInfoReturnsOnCall[len(fake.nodeGetInfoArgsForCall)]
	fake.nodeGetInfoArgsForCall = append(fake.nodeGetInfoArgsForCall, struct {
		arg1 context.Context
		arg2 *csi.NodeGetInfoRequest
	}{arg1, arg2})
	fake.recordInvocation("NodeGetInfo", []interface{}{arg1, arg2})
	fake.nodeGetInfoMutex.Unlock()
	if fake.NodeGetInfoStub != nil {
		return fake.NodeGetInfoStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.nodeGetInfoReturns.result1, fake.nodeGetInfoReturns.result2
}

func (fake *FakeNodeServer) NodeGetInfoCallCount() int {
	fake.nodeGetInfoMutex.RLock()
	defer fake.nodeGetInfoMutex.RUnlock()
	return len(fake.nodeGetInfoArgsForCall)
}

func (fake *FakeNodeServer) NodeGetInfoArgsForCall(i int) (context.Context, *csi.NodeGetInfoRequest) {
	fake.nodeGetInfoMutex.RLock()
	defer fake.nodeGetInfoMutex.RUnlock()
	return fake.nodeGetInfoArgsForCall[i].arg1, fake.nodeGetInfoArgsForCall[i].arg2
}

func (fake *FakeNodeServer) NodeGetInfoReturns(result1 *csi.NodeGetInfoResponse, result2 error) {
	fake.NodeGetInfoStub = nil
	fake.nodeGetInfoReturns = struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) NodeGetInfoReturnsOnCall(i int, result1 *csi.NodeGetInfoResponse, result2 error) {
	fake.NodeGetInfoStub = nil
	if fake.nodeGetInfoReturnsOnCall == nil {
		fake.nodeGetInfoReturnsOnCall = make(map[int]struct {
			result1 *csi.NodeGetInfoResponse
			result2 error
		})
	}
	fake.nodeGetInfoReturnsOnCall[i] = struct {
		result1 *csi.NodeGetInfoResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeServer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nodeStageVolumeMutex.RLock()
	defer fake.nodeStageVolumeMutex.RUnlock()
	fake.nodeUnstageVolumeMutex.RLock()
	defer fake.nodeUnstageVolumeMutex.RUnlock()
	fake.nodePublishVolumeMutex.RLock()
	defer fake.nodePublishVolumeMutex.RUnlock()
	fake.nodeUnpublishVolumeMutex.RLock()
	defer fake.nodeUnpublishVolumeMutex.RUnlock()
	fake.nodeGetIdMutex.RLock()
	defer fake.nodeGetIdMutex.RUnlock()
	fake.nodeGetCapabilitiesMutex.RLock()
	defer fake.nodeGetCapabilitiesMutex.RUnlock()
	fake.nodeGetInfoMutex.RLock()
	defer fake.nodeGetInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeServer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ csi.NodeServer = new(FakeNodeServer)
