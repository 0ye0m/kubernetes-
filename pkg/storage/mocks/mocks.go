/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was generated by counterfeiter
package mocks

import (
	"sync"

	"k8s.io/kubernetes/pkg/runtime"
	"k8s.io/kubernetes/pkg/storage"
	"k8s.io/kubernetes/pkg/watch"
)

type MockInterface struct {
	BackendsStub        func() []string
	backendsMutex       sync.RWMutex
	backendsArgsForCall []struct{}
	backendsReturns     struct {
		result1 []string
	}
	VersionerStub        func() storage.Versioner
	versionerMutex       sync.RWMutex
	versionerArgsForCall []struct{}
	versionerReturns     struct {
		result1 storage.Versioner
	}
	CreateStub        func(key string, obj, out runtime.Object, ttl uint64) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		key string
		obj runtime.Object
		out runtime.Object
		ttl uint64
	}
	createReturns struct {
		result1 error
	}
	SetStub        func(key string, obj, out runtime.Object, ttl uint64) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		key string
		obj runtime.Object
		out runtime.Object
		ttl uint64
	}
	setReturns struct {
		result1 error
	}
	DeleteStub        func(key string, out runtime.Object) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		key string
		out runtime.Object
	}
	deleteReturns struct {
		result1 error
	}
	RecursiveDeleteStub        func(key string, recursive bool) error
	recursiveDeleteMutex       sync.RWMutex
	recursiveDeleteArgsForCall []struct {
		key       string
		recursive bool
	}
	recursiveDeleteReturns struct {
		result1 error
	}
	WatchStub        func(key string, resourceVersion uint64, filter storage.FilterFunc) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		key             string
		resourceVersion uint64
		filter          storage.FilterFunc
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	WatchListStub        func(key string, resourceVersion uint64, filter storage.FilterFunc) (watch.Interface, error)
	watchListMutex       sync.RWMutex
	watchListArgsForCall []struct {
		key             string
		resourceVersion uint64
		filter          storage.FilterFunc
	}
	watchListReturns struct {
		result1 watch.Interface
		result2 error
	}
	GetStub        func(key string, objPtr runtime.Object, ignoreNotFound bool) error
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		key            string
		objPtr         runtime.Object
		ignoreNotFound bool
	}
	getReturns struct {
		result1 error
	}
	GetToListStub        func(key string, listObj runtime.Object) error
	getToListMutex       sync.RWMutex
	getToListArgsForCall []struct {
		key     string
		listObj runtime.Object
	}
	getToListReturns struct {
		result1 error
	}
	ListStub        func(key string, listObj runtime.Object) error
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		key     string
		listObj runtime.Object
	}
	listReturns struct {
		result1 error
	}
	GuaranteedUpdateStub        func(key string, ptrToType runtime.Object, ignoreNotFound bool, tryUpdate storage.UpdateFunc) error
	guaranteedUpdateMutex       sync.RWMutex
	guaranteedUpdateArgsForCall []struct {
		key            string
		ptrToType      runtime.Object
		ignoreNotFound bool
		tryUpdate      storage.UpdateFunc
	}
	guaranteedUpdateReturns struct {
		result1 error
	}
	CodecStub        func() runtime.Codec
	codecMutex       sync.RWMutex
	codecArgsForCall []struct{}
	codecReturns     struct {
		result1 runtime.Codec
	}
}

func (fake *MockInterface) Backends() []string {
	fake.backendsMutex.Lock()
	fake.backendsArgsForCall = append(fake.backendsArgsForCall, struct{}{})
	fake.backendsMutex.Unlock()
	if fake.BackendsStub != nil {
		return fake.BackendsStub()
	} else {
		return fake.backendsReturns.result1
	}
}

func (fake *MockInterface) BackendsCallCount() int {
	fake.backendsMutex.RLock()
	defer fake.backendsMutex.RUnlock()
	return len(fake.backendsArgsForCall)
}

func (fake *MockInterface) BackendsReturns(result1 []string) {
	fake.BackendsStub = nil
	fake.backendsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *MockInterface) Versioner() storage.Versioner {
	fake.versionerMutex.Lock()
	fake.versionerArgsForCall = append(fake.versionerArgsForCall, struct{}{})
	fake.versionerMutex.Unlock()
	if fake.VersionerStub != nil {
		return fake.VersionerStub()
	} else {
		return fake.versionerReturns.result1
	}
}

func (fake *MockInterface) VersionerCallCount() int {
	fake.versionerMutex.RLock()
	defer fake.versionerMutex.RUnlock()
	return len(fake.versionerArgsForCall)
}

func (fake *MockInterface) VersionerReturns(result1 storage.Versioner) {
	fake.VersionerStub = nil
	fake.versionerReturns = struct {
		result1 storage.Versioner
	}{result1}
}

func (fake *MockInterface) Create(key string, obj runtime.Object, out runtime.Object, ttl uint64) error {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		key string
		obj runtime.Object
		out runtime.Object
		ttl uint64
	}{key, obj, out, ttl})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(key, obj, out, ttl)
	} else {
		return fake.createReturns.result1
	}
}

func (fake *MockInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *MockInterface) CreateArgsForCall(i int) (string, runtime.Object, runtime.Object, uint64) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].key, fake.createArgsForCall[i].obj, fake.createArgsForCall[i].out, fake.createArgsForCall[i].ttl
}

func (fake *MockInterface) CreateReturns(result1 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) Set(key string, obj runtime.Object, out runtime.Object, ttl uint64) error {
	fake.setMutex.Lock()
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		key string
		obj runtime.Object
		out runtime.Object
		ttl uint64
	}{key, obj, out, ttl})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(key, obj, out, ttl)
	} else {
		return fake.setReturns.result1
	}
}

func (fake *MockInterface) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *MockInterface) SetArgsForCall(i int) (string, runtime.Object, runtime.Object, uint64) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return fake.setArgsForCall[i].key, fake.setArgsForCall[i].obj, fake.setArgsForCall[i].out, fake.setArgsForCall[i].ttl
}

func (fake *MockInterface) SetReturns(result1 error) {
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) Delete(key string, out runtime.Object) error {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		key string
		out runtime.Object
	}{key, out})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(key, out)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *MockInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *MockInterface) DeleteArgsForCall(i int) (string, runtime.Object) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].key, fake.deleteArgsForCall[i].out
}

func (fake *MockInterface) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) RecursiveDelete(key string, recursive bool) error {
	fake.recursiveDeleteMutex.Lock()
	fake.recursiveDeleteArgsForCall = append(fake.recursiveDeleteArgsForCall, struct {
		key       string
		recursive bool
	}{key, recursive})
	fake.recursiveDeleteMutex.Unlock()
	if fake.RecursiveDeleteStub != nil {
		return fake.RecursiveDeleteStub(key, recursive)
	} else {
		return fake.recursiveDeleteReturns.result1
	}
}

func (fake *MockInterface) RecursiveDeleteCallCount() int {
	fake.recursiveDeleteMutex.RLock()
	defer fake.recursiveDeleteMutex.RUnlock()
	return len(fake.recursiveDeleteArgsForCall)
}

func (fake *MockInterface) RecursiveDeleteArgsForCall(i int) (string, bool) {
	fake.recursiveDeleteMutex.RLock()
	defer fake.recursiveDeleteMutex.RUnlock()
	return fake.recursiveDeleteArgsForCall[i].key, fake.recursiveDeleteArgsForCall[i].recursive
}

func (fake *MockInterface) RecursiveDeleteReturns(result1 error) {
	fake.RecursiveDeleteStub = nil
	fake.recursiveDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) Watch(key string, resourceVersion uint64, filter storage.FilterFunc) (watch.Interface, error) {
	fake.watchMutex.Lock()
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		key             string
		resourceVersion uint64
		filter          storage.FilterFunc
	}{key, resourceVersion, filter})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(key, resourceVersion, filter)
	} else {
		return fake.watchReturns.result1, fake.watchReturns.result2
	}
}

func (fake *MockInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *MockInterface) WatchArgsForCall(i int) (string, uint64, storage.FilterFunc) {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].key, fake.watchArgsForCall[i].resourceVersion, fake.watchArgsForCall[i].filter
}

func (fake *MockInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *MockInterface) WatchList(key string, resourceVersion uint64, filter storage.FilterFunc) (watch.Interface, error) {
	fake.watchListMutex.Lock()
	fake.watchListArgsForCall = append(fake.watchListArgsForCall, struct {
		key             string
		resourceVersion uint64
		filter          storage.FilterFunc
	}{key, resourceVersion, filter})
	fake.watchListMutex.Unlock()
	if fake.WatchListStub != nil {
		return fake.WatchListStub(key, resourceVersion, filter)
	} else {
		return fake.watchListReturns.result1, fake.watchListReturns.result2
	}
}

func (fake *MockInterface) WatchListCallCount() int {
	fake.watchListMutex.RLock()
	defer fake.watchListMutex.RUnlock()
	return len(fake.watchListArgsForCall)
}

func (fake *MockInterface) WatchListArgsForCall(i int) (string, uint64, storage.FilterFunc) {
	fake.watchListMutex.RLock()
	defer fake.watchListMutex.RUnlock()
	return fake.watchListArgsForCall[i].key, fake.watchListArgsForCall[i].resourceVersion, fake.watchListArgsForCall[i].filter
}

func (fake *MockInterface) WatchListReturns(result1 watch.Interface, result2 error) {
	fake.WatchListStub = nil
	fake.watchListReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *MockInterface) Get(key string, objPtr runtime.Object, ignoreNotFound bool) error {
	fake.getMutex.Lock()
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		key            string
		objPtr         runtime.Object
		ignoreNotFound bool
	}{key, objPtr, ignoreNotFound})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(key, objPtr, ignoreNotFound)
	} else {
		return fake.getReturns.result1
	}
}

func (fake *MockInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *MockInterface) GetArgsForCall(i int) (string, runtime.Object, bool) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].key, fake.getArgsForCall[i].objPtr, fake.getArgsForCall[i].ignoreNotFound
}

func (fake *MockInterface) GetReturns(result1 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) GetToList(key string, listObj runtime.Object) error {
	fake.getToListMutex.Lock()
	fake.getToListArgsForCall = append(fake.getToListArgsForCall, struct {
		key     string
		listObj runtime.Object
	}{key, listObj})
	fake.getToListMutex.Unlock()
	if fake.GetToListStub != nil {
		return fake.GetToListStub(key, listObj)
	} else {
		return fake.getToListReturns.result1
	}
}

func (fake *MockInterface) GetToListCallCount() int {
	fake.getToListMutex.RLock()
	defer fake.getToListMutex.RUnlock()
	return len(fake.getToListArgsForCall)
}

func (fake *MockInterface) GetToListArgsForCall(i int) (string, runtime.Object) {
	fake.getToListMutex.RLock()
	defer fake.getToListMutex.RUnlock()
	return fake.getToListArgsForCall[i].key, fake.getToListArgsForCall[i].listObj
}

func (fake *MockInterface) GetToListReturns(result1 error) {
	fake.GetToListStub = nil
	fake.getToListReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) List(key string, listObj runtime.Object) error {
	fake.listMutex.Lock()
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		key     string
		listObj runtime.Object
	}{key, listObj})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(key, listObj)
	} else {
		return fake.listReturns.result1
	}
}

func (fake *MockInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *MockInterface) ListArgsForCall(i int) (string, runtime.Object) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].key, fake.listArgsForCall[i].listObj
}

func (fake *MockInterface) ListReturns(result1 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) GuaranteedUpdate(key string, ptrToType runtime.Object, ignoreNotFound bool, tryUpdate storage.UpdateFunc) error {
	fake.guaranteedUpdateMutex.Lock()
	fake.guaranteedUpdateArgsForCall = append(fake.guaranteedUpdateArgsForCall, struct {
		key            string
		ptrToType      runtime.Object
		ignoreNotFound bool
		tryUpdate      storage.UpdateFunc
	}{key, ptrToType, ignoreNotFound, tryUpdate})
	fake.guaranteedUpdateMutex.Unlock()
	if fake.GuaranteedUpdateStub != nil {
		return fake.GuaranteedUpdateStub(key, ptrToType, ignoreNotFound, tryUpdate)
	} else {
		return fake.guaranteedUpdateReturns.result1
	}
}

func (fake *MockInterface) GuaranteedUpdateCallCount() int {
	fake.guaranteedUpdateMutex.RLock()
	defer fake.guaranteedUpdateMutex.RUnlock()
	return len(fake.guaranteedUpdateArgsForCall)
}

func (fake *MockInterface) GuaranteedUpdateArgsForCall(i int) (string, runtime.Object, bool, storage.UpdateFunc) {
	fake.guaranteedUpdateMutex.RLock()
	defer fake.guaranteedUpdateMutex.RUnlock()
	return fake.guaranteedUpdateArgsForCall[i].key, fake.guaranteedUpdateArgsForCall[i].ptrToType, fake.guaranteedUpdateArgsForCall[i].ignoreNotFound, fake.guaranteedUpdateArgsForCall[i].tryUpdate
}

func (fake *MockInterface) GuaranteedUpdateReturns(result1 error) {
	fake.GuaranteedUpdateStub = nil
	fake.guaranteedUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockInterface) Codec() runtime.Codec {
	fake.codecMutex.Lock()
	fake.codecArgsForCall = append(fake.codecArgsForCall, struct{}{})
	fake.codecMutex.Unlock()
	if fake.CodecStub != nil {
		return fake.CodecStub()
	} else {
		return fake.codecReturns.result1
	}
}

func (fake *MockInterface) CodecCallCount() int {
	fake.codecMutex.RLock()
	defer fake.codecMutex.RUnlock()
	return len(fake.codecArgsForCall)
}

func (fake *MockInterface) CodecReturns(result1 runtime.Codec) {
	fake.CodecStub = nil
	fake.codecReturns = struct {
		result1 runtime.Codec
	}{result1}
}

var _ storage.Interface = new(MockInterface)
