/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// ************************************************************
// DO NOT EDIT.
// THIS FILE IS AUTO-GENERATED BY codecgen.
// ************************************************************

package testing

import (
	"errors"
	"fmt"
	codec1978 "github.com/ugorji/go/codec"
	pkg2_api "k8s.io/kubernetes/pkg/api"
	pkg1_unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	pkg3_types "k8s.io/kubernetes/pkg/types"
	"reflect"
	"runtime"
	time "time"
)

const (
	codecSelferC_UTF81234         = 1
	codecSelferC_RAW1234          = 0
	codecSelferValueTypeArray1234 = 10
	codecSelferValueTypeMap1234   = 9
)

var (
	codecSelferBitsize1234                         = uint8(reflect.TypeOf(uint(0)).Bits())
	codecSelferOnlyMapOrArrayEncodeToStructErr1234 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer1234 struct{}

func init() {
	if codec1978.GenVersion != 4 {
		_, file, _, _ := runtime.Caller(0)
		err := fmt.Errorf("codecgen version mismatch: current: %v, need %v. Re-generate file: %v",
			4, codec1978.GenVersion, file)
		panic(err)
	}
	if false { // reference the types, but skip this branch at build/run time
		var v0 pkg2_api.ObjectMeta
		var v1 pkg1_unversioned.TypeMeta
		var v2 pkg3_types.UID
		var v3 time.Time
		_, _, _, _ = v0, v1, v2, v3
	}
}

func (x *TestResource) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym1 := z.EncBinary()
		_ = yym1
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			var yyq2 [4]bool
			_, _, _ = yysep2, yyq2, yy2arr2
			const yyr2 bool = false
			yyq2[0] = x.Kind != ""
			yyq2[1] = true
			if yyr2 || yy2arr2 {
				r.EncodeArrayStart(4)
			} else {
				var yynn2 int = 2
				for _, b := range yyq2 {
					if b {
						yynn2++
					}
				}
				r.EncodeMapStart(yynn2)
			}
			if yyr2 || yy2arr2 {
				if yyq2[0] {
					yym4 := z.EncBinary()
					_ = yym4
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq2[0] {
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					yym5 := z.EncBinary()
					_ = yym5
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr2 || yy2arr2 {
				if yyq2[1] {
					yy7 := &x.APIVersion
					yym8 := z.EncBinary()
					_ = yym8
					if false {
					} else if z.HasExtensions() && z.EncExt(yy7) {
					} else if !yym8 && z.IsJSONHandle() {
						z.EncJSONMarshal(yy7)
					} else {
						z.EncFallback(yy7)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq2[1] {
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					yy9 := &x.APIVersion
					yym10 := z.EncBinary()
					_ = yym10
					if false {
					} else if z.HasExtensions() && z.EncExt(yy9) {
					} else if !yym10 && z.IsJSONHandle() {
						z.EncJSONMarshal(yy9)
					} else {
						z.EncFallback(yy9)
					}
				}
			}
			if yyr2 || yy2arr2 {
				yy12 := &x.ObjectMeta
				yy12.CodecEncodeSelf(e)
			} else {
				r.EncodeString(codecSelferC_UTF81234, string("metadata"))
				yy13 := &x.ObjectMeta
				yy13.CodecEncodeSelf(e)
			}
			if yyr2 || yy2arr2 {
				yym15 := z.EncBinary()
				_ = yym15
				if false {
				} else {
					r.EncodeInt(int64(x.Value))
				}
			} else {
				r.EncodeString(codecSelferC_UTF81234, string("value"))
				yym16 := z.EncBinary()
				_ = yym16
				if false {
				} else {
					r.EncodeInt(int64(x.Value))
				}
			}
			if yysep2 {
				r.EncodeEnd()
			}
		}
	}
}

func (x *TestResource) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym17 := z.DecBinary()
	_ = yym17
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		if r.IsContainerType(codecSelferValueTypeMap1234) {
			yyl18 := r.ReadMapStart()
			if yyl18 == 0 {
				r.ReadEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl18, d)
			}
		} else if r.IsContainerType(codecSelferValueTypeArray1234) {
			yyl18 := r.ReadArrayStart()
			if yyl18 == 0 {
				r.ReadEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl18, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestResource) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys19Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys19Slc
	var yyhl19 bool = l >= 0
	for yyj19 := 0; ; yyj19++ {
		if yyhl19 {
			if yyj19 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		yys19Slc = r.DecodeBytes(yys19Slc, true, true)
		yys19 := string(yys19Slc)
		switch yys19 {
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = pkg1_unversioned.GroupVersion{}
			} else {
				yyv21 := &x.APIVersion
				yym22 := z.DecBinary()
				_ = yym22
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv21) {
				} else if !yym22 && z.IsJSONHandle() {
					z.DecJSONUnmarshal(yyv21)
				} else {
					z.DecFallback(yyv21, false)
				}
			}
		case "metadata":
			if r.TryDecodeAsNil() {
				x.ObjectMeta = pkg2_api.ObjectMeta{}
			} else {
				yyv23 := &x.ObjectMeta
				yyv23.CodecDecodeSelf(d)
			}
		case "value":
			if r.TryDecodeAsNil() {
				x.Value = 0
			} else {
				x.Value = int(r.DecodeInt(codecSelferBitsize1234))
			}
		default:
			z.DecStructFieldNotFound(-1, yys19)
		} // end switch yys19
	} // end for yyj19
	if !yyhl19 {
		r.ReadEnd()
	}
}

func (x *TestResource) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj25 int
	var yyb25 bool
	var yyhl25 bool = l >= 0
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.APIVersion = pkg1_unversioned.GroupVersion{}
	} else {
		yyv27 := &x.APIVersion
		yym28 := z.DecBinary()
		_ = yym28
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv27) {
		} else if !yym28 && z.IsJSONHandle() {
			z.DecJSONUnmarshal(yyv27)
		} else {
			z.DecFallback(yyv27, false)
		}
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.ObjectMeta = pkg2_api.ObjectMeta{}
	} else {
		yyv29 := &x.ObjectMeta
		yyv29.CodecDecodeSelf(d)
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.Value = 0
	} else {
		x.Value = int(r.DecodeInt(codecSelferBitsize1234))
	}
	for {
		yyj25++
		if yyhl25 {
			yyb25 = yyj25 > l
		} else {
			yyb25 = r.CheckBreak()
		}
		if yyb25 {
			break
		}
		z.DecStructFieldNotFound(yyj25-1, "")
	}
	r.ReadEnd()
}
