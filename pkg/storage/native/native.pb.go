/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo.
// source: native.proto
// DO NOT EDIT!

/*
Package native is a generated protocol buffer package.

It is generated from these files:
	native.proto

It has these top-level messages:
	WatchRequest
	WatchEvent
	ErrorInfo
	RaftLogEntry
	RaftLogEntryResult
	StorageOperation
	StorageOperationResult
	ItemData
	SnapshotInfo
	BitSetInfo
	BitSetChunkInfo
*/
package native

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type StorageOperationType int32

const (
	StorageOperationType_UNKNOWN StorageOperationType = 0
	StorageOperationType_GET     StorageOperationType = 1
	StorageOperationType_LIST    StorageOperationType = 2
	StorageOperationType_CREATE  StorageOperationType = 3
	StorageOperationType_DELETE  StorageOperationType = 4
	StorageOperationType_UPDATE  StorageOperationType = 5
)

var StorageOperationType_name = map[int32]string{
	0: "UNKNOWN",
	1: "GET",
	2: "LIST",
	3: "CREATE",
	4: "DELETE",
	5: "UPDATE",
}
var StorageOperationType_value = map[string]int32{
	"UNKNOWN": 0,
	"GET":     1,
	"LIST":    2,
	"CREATE":  3,
	"DELETE":  4,
	"UPDATE":  5,
}

func (x StorageOperationType) String() string {
	return proto.EnumName(StorageOperationType_name, int32(x))
}
func (StorageOperationType) EnumDescriptor() ([]byte, []int) { return fileDescriptorNative, []int{0} }

type ErrorCode int32

const (
	ErrorCode_NONE                     ErrorCode = 0
	ErrorCode_ALREADY_EXISTS           ErrorCode = 1
	ErrorCode_NOT_FOUND                ErrorCode = 2
	ErrorCode_PRECONDITION_NOT_MET_LSN ErrorCode = 10
	ErrorCode_PRECONDITION_NOT_MET_UID ErrorCode = 11
)

var ErrorCode_name = map[int32]string{
	0:  "NONE",
	1:  "ALREADY_EXISTS",
	2:  "NOT_FOUND",
	10: "PRECONDITION_NOT_MET_LSN",
	11: "PRECONDITION_NOT_MET_UID",
}
var ErrorCode_value = map[string]int32{
	"NONE":                     0,
	"ALREADY_EXISTS":           1,
	"NOT_FOUND":                2,
	"PRECONDITION_NOT_MET_LSN": 10,
	"PRECONDITION_NOT_MET_UID": 11,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorNative, []int{1} }

type WatchRequest struct {
	Path          string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Recursive     bool   `protobuf:"varint,2,opt,name=recursive,proto3" json:"recursive,omitempty"`
	StartPosition uint64 `protobuf:"varint,3,opt,name=start_position,json=startPosition,proto3" json:"start_position,omitempty"`
}

func (m *WatchRequest) Reset()                    { *m = WatchRequest{} }
func (m *WatchRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()               {}
func (*WatchRequest) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{0} }

type WatchEvent struct {
	Op    *StorageOperation `protobuf:"bytes,1,opt,name=op" json:"op,omitempty"`
	Error *ErrorInfo        `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *WatchEvent) Reset()                    { *m = WatchEvent{} }
func (m *WatchEvent) String() string            { return proto.CompactTextString(m) }
func (*WatchEvent) ProtoMessage()               {}
func (*WatchEvent) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{1} }

func (m *WatchEvent) GetOp() *StorageOperation {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *WatchEvent) GetError() *ErrorInfo {
	if m != nil {
		return m.Error
	}
	return nil
}

type ErrorInfo struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ErrorInfo) Reset()                    { *m = ErrorInfo{} }
func (m *ErrorInfo) String() string            { return proto.CompactTextString(m) }
func (*ErrorInfo) ProtoMessage()               {}
func (*ErrorInfo) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{2} }

type RaftLogEntry struct {
	Op *StorageOperation `protobuf:"bytes,1,opt,name=op" json:"op,omitempty"`
}

func (m *RaftLogEntry) Reset()                    { *m = RaftLogEntry{} }
func (m *RaftLogEntry) String() string            { return proto.CompactTextString(m) }
func (*RaftLogEntry) ProtoMessage()               {}
func (*RaftLogEntry) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{3} }

func (m *RaftLogEntry) GetOp() *StorageOperation {
	if m != nil {
		return m.Op
	}
	return nil
}

type RaftLogEntryResult struct {
	Result *StorageOperationResult `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *RaftLogEntryResult) Reset()                    { *m = RaftLogEntryResult{} }
func (m *RaftLogEntryResult) String() string            { return proto.CompactTextString(m) }
func (*RaftLogEntryResult) ProtoMessage()               {}
func (*RaftLogEntryResult) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{4} }

func (m *RaftLogEntryResult) GetResult() *StorageOperationResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type StorageOperation struct {
	OpType          StorageOperationType `protobuf:"varint,1,opt,name=op_type,json=opType,proto3,enum=native.StorageOperationType" json:"op_type,omitempty"`
	Path            string               `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	ItemData        *ItemData            `protobuf:"bytes,3,opt,name=item_data,json=itemData" json:"item_data,omitempty"`
	PreconditionLsn uint64               `protobuf:"varint,10,opt,name=precondition_lsn,json=preconditionLsn,proto3" json:"precondition_lsn,omitempty"`
	PreconditionUid string               `protobuf:"bytes,11,opt,name=precondition_uid,json=preconditionUid,proto3" json:"precondition_uid,omitempty"`
}

func (m *StorageOperation) Reset()                    { *m = StorageOperation{} }
func (m *StorageOperation) String() string            { return proto.CompactTextString(m) }
func (*StorageOperation) ProtoMessage()               {}
func (*StorageOperation) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{5} }

func (m *StorageOperation) GetItemData() *ItemData {
	if m != nil {
		return m.ItemData
	}
	return nil
}

type StorageOperationResult struct {
	ItemData   *ItemData `protobuf:"bytes,1,opt,name=item_data,json=itemData" json:"item_data,omitempty"`
	ErrorCode  ErrorCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=native.ErrorCode" json:"error_code,omitempty"`
	CurrentLsn uint64    `protobuf:"varint,3,opt,name=current_lsn,json=currentLsn,proto3" json:"current_lsn,omitempty"`
	// For the case of a list
	// TODO: Stream instead
	ItemList []*ItemData `protobuf:"bytes,4,rep,name=item_list,json=itemList" json:"item_list,omitempty"`
}

func (m *StorageOperationResult) Reset()                    { *m = StorageOperationResult{} }
func (m *StorageOperationResult) String() string            { return proto.CompactTextString(m) }
func (*StorageOperationResult) ProtoMessage()               {}
func (*StorageOperationResult) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{6} }

func (m *StorageOperationResult) GetItemData() *ItemData {
	if m != nil {
		return m.ItemData
	}
	return nil
}

func (m *StorageOperationResult) GetItemList() []*ItemData {
	if m != nil {
		return m.ItemList
	}
	return nil
}

type ItemData struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Uid  string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Lsn  uint64 `protobuf:"varint,3,opt,name=lsn,proto3" json:"lsn,omitempty"`
	Ttl  uint64 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// path will often not be populated if unambiguous
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ItemData) Reset()                    { *m = ItemData{} }
func (m *ItemData) String() string            { return proto.CompactTextString(m) }
func (*ItemData) ProtoMessage()               {}
func (*ItemData) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{7} }

type SnapshotInfo struct {
	ItemCount uint64 `protobuf:"varint,1,opt,name=item_count,json=itemCount,proto3" json:"item_count,omitempty"`
}

func (m *SnapshotInfo) Reset()                    { *m = SnapshotInfo{} }
func (m *SnapshotInfo) String() string            { return proto.CompactTextString(m) }
func (*SnapshotInfo) ProtoMessage()               {}
func (*SnapshotInfo) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{8} }

type BitSetInfo struct {
	ChunkCount uint32 `protobuf:"varint,1,opt,name=chunk_count,json=chunkCount,proto3" json:"chunk_count,omitempty"`
}

func (m *BitSetInfo) Reset()                    { *m = BitSetInfo{} }
func (m *BitSetInfo) String() string            { return proto.CompactTextString(m) }
func (*BitSetInfo) ProtoMessage()               {}
func (*BitSetInfo) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{9} }

type BitSetChunkInfo struct {
	Min  uint64 `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	Bits []byte `protobuf:"bytes,2,opt,name=bits,proto3" json:"bits,omitempty"`
}

func (m *BitSetChunkInfo) Reset()                    { *m = BitSetChunkInfo{} }
func (m *BitSetChunkInfo) String() string            { return proto.CompactTextString(m) }
func (*BitSetChunkInfo) ProtoMessage()               {}
func (*BitSetChunkInfo) Descriptor() ([]byte, []int) { return fileDescriptorNative, []int{10} }

func init() {
	proto.RegisterType((*WatchRequest)(nil), "native.WatchRequest")
	proto.RegisterType((*WatchEvent)(nil), "native.WatchEvent")
	proto.RegisterType((*ErrorInfo)(nil), "native.ErrorInfo")
	proto.RegisterType((*RaftLogEntry)(nil), "native.RaftLogEntry")
	proto.RegisterType((*RaftLogEntryResult)(nil), "native.RaftLogEntryResult")
	proto.RegisterType((*StorageOperation)(nil), "native.StorageOperation")
	proto.RegisterType((*StorageOperationResult)(nil), "native.StorageOperationResult")
	proto.RegisterType((*ItemData)(nil), "native.ItemData")
	proto.RegisterType((*SnapshotInfo)(nil), "native.SnapshotInfo")
	proto.RegisterType((*BitSetInfo)(nil), "native.BitSetInfo")
	proto.RegisterType((*BitSetChunkInfo)(nil), "native.BitSetChunkInfo")
	proto.RegisterEnum("native.StorageOperationType", StorageOperationType_name, StorageOperationType_value)
	proto.RegisterEnum("native.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for StorageService service

type StorageServiceClient interface {
	// DoOperation performs a StorageOperation
	DoOperation(ctx context.Context, in *StorageOperation, opts ...grpc.CallOption) (*StorageOperationResult, error)
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (StorageService_WatchClient, error)
}

type storageServiceClient struct {
	cc *grpc.ClientConn
}

func NewStorageServiceClient(cc *grpc.ClientConn) StorageServiceClient {
	return &storageServiceClient{cc}
}

func (c *storageServiceClient) DoOperation(ctx context.Context, in *StorageOperation, opts ...grpc.CallOption) (*StorageOperationResult, error) {
	out := new(StorageOperationResult)
	err := grpc.Invoke(ctx, "/native.StorageService/DoOperation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (StorageService_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StorageService_serviceDesc.Streams[0], c.cc, "/native.StorageService/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StorageService_WatchClient interface {
	Recv() (*WatchEvent, error)
	grpc.ClientStream
}

type storageServiceWatchClient struct {
	grpc.ClientStream
}

func (x *storageServiceWatchClient) Recv() (*WatchEvent, error) {
	m := new(WatchEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StorageService service

type StorageServiceServer interface {
	// DoOperation performs a StorageOperation
	DoOperation(context.Context, *StorageOperation) (*StorageOperationResult, error)
	Watch(*WatchRequest, StorageService_WatchServer) error
}

func RegisterStorageServiceServer(s *grpc.Server, srv StorageServiceServer) {
	s.RegisterService(&_StorageService_serviceDesc, srv)
}

func _StorageService_DoOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageOperation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).DoOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/native.StorageService/DoOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).DoOperation(ctx, req.(*StorageOperation))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServiceServer).Watch(m, &storageServiceWatchServer{stream})
}

type StorageService_WatchServer interface {
	Send(*WatchEvent) error
	grpc.ServerStream
}

type storageServiceWatchServer struct {
	grpc.ServerStream
}

func (x *storageServiceWatchServer) Send(m *WatchEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _StorageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "native.StorageService",
	HandlerType: (*StorageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DoOperation",
			Handler:    _StorageService_DoOperation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _StorageService_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptorNative,
}

var fileDescriptorNative = []byte{
	// 718 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0xed, 0x6e, 0xd3, 0x3c,
	0x18, 0x6d, 0xda, 0xf4, 0xeb, 0x49, 0xd7, 0xe5, 0xb5, 0xa6, 0x57, 0xd1, 0x34, 0xa0, 0x8a, 0x34,
	0x51, 0x26, 0x6d, 0x9a, 0x8a, 0x06, 0xfc, 0x1d, 0x4d, 0x40, 0x11, 0x21, 0x9d, 0x9c, 0x54, 0x03,
	0xfe, 0x44, 0x59, 0xeb, 0xb5, 0x11, 0x6d, 0x1c, 0x1c, 0xb7, 0xd2, 0x6e, 0x83, 0xbb, 0xe2, 0x36,
	0xb8, 0x12, 0x64, 0x27, 0xfd, 0xd8, 0x58, 0x35, 0x7e, 0xe5, 0xe4, 0xf8, 0xd8, 0x3e, 0x8f, 0xcf,
	0x63, 0x43, 0x2b, 0x89, 0x78, 0xbc, 0x24, 0x67, 0x29, 0xa3, 0x9c, 0xa2, 0x5a, 0xfe, 0x67, 0x4e,
	0xa0, 0x75, 0x1d, 0xf1, 0xd1, 0x14, 0x93, 0x1f, 0x0b, 0x92, 0x71, 0x84, 0x40, 0x4d, 0x23, 0x3e,
	0x35, 0x94, 0x8e, 0xd2, 0x6d, 0x62, 0x89, 0xd1, 0x11, 0x34, 0x19, 0x19, 0x2d, 0x58, 0x16, 0x2f,
	0x89, 0x51, 0xee, 0x28, 0xdd, 0x06, 0xde, 0x10, 0xe8, 0x18, 0xda, 0x19, 0x8f, 0x18, 0x0f, 0x53,
	0x9a, 0xc5, 0x3c, 0xa6, 0x89, 0x51, 0xe9, 0x28, 0x5d, 0x15, 0xef, 0x49, 0xf6, 0xaa, 0x20, 0xcd,
	0x10, 0x40, 0x6e, 0x64, 0x2f, 0x49, 0xc2, 0x51, 0x17, 0xca, 0x34, 0x95, 0x9b, 0x68, 0x3d, 0xe3,
	0xac, 0x70, 0xe6, 0x73, 0xca, 0xa2, 0x09, 0x19, 0xa4, 0x84, 0x45, 0x62, 0x0e, 0x2e, 0xd3, 0x14,
	0xbd, 0x84, 0x2a, 0x61, 0x8c, 0x32, 0xb9, 0xb1, 0xd6, 0xfb, 0x6f, 0x25, 0xb6, 0x05, 0xe9, 0x24,
	0xb7, 0x14, 0xe7, 0xe3, 0xe6, 0x31, 0x34, 0xd7, 0x1c, 0x32, 0xa0, 0x3e, 0x27, 0x59, 0x16, 0x4d,
	0x48, 0x51, 0xc9, 0xea, 0xd7, 0x7c, 0x07, 0x2d, 0x1c, 0xdd, 0x72, 0x97, 0x4e, 0xec, 0x84, 0xb3,
	0xbb, 0x7f, 0x77, 0x62, 0xba, 0x80, 0xb6, 0x67, 0x62, 0x92, 0x2d, 0x66, 0x1c, 0xbd, 0x81, 0x1a,
	0x93, 0xa8, 0x58, 0xe3, 0xf9, 0xce, 0x35, 0xa4, 0x0a, 0x17, 0x6a, 0xf3, 0xb7, 0x02, 0xfa, 0x43,
	0x09, 0xba, 0x80, 0x3a, 0x4d, 0x43, 0x7e, 0x97, 0xe6, 0xb6, 0xdb, 0xbd, 0xa3, 0x5d, 0xab, 0x05,
	0x77, 0x29, 0xc1, 0x35, 0x9a, 0x8a, 0xef, 0x3a, 0xb4, 0xf2, 0x56, 0x68, 0xa7, 0xd0, 0x8c, 0x39,
	0x99, 0x87, 0xe3, 0x88, 0x47, 0x32, 0x11, 0xad, 0xa7, 0xaf, 0x16, 0x73, 0x38, 0x99, 0x5b, 0x11,
	0x8f, 0x70, 0x23, 0x2e, 0x10, 0x7a, 0x05, 0x7a, 0xca, 0xc8, 0x88, 0x26, 0x63, 0x19, 0x57, 0x38,
	0xcb, 0x12, 0x03, 0x64, 0x8e, 0xfb, 0xdb, 0xbc, 0x9b, 0x25, 0x7f, 0x49, 0x17, 0xf1, 0xd8, 0xd0,
	0xe4, 0xce, 0xf7, 0xa4, 0xc3, 0x78, 0x6c, 0xfe, 0x52, 0xe0, 0xff, 0xc7, 0xcf, 0xe1, 0xbe, 0x3f,
	0xe5, 0x49, 0x7f, 0xe7, 0x00, 0x32, 0xe6, 0x70, 0x44, 0xc7, 0x79, 0x13, 0xb6, 0x1f, 0xf4, 0x42,
	0x9f, 0x8e, 0x09, 0x6e, 0x92, 0x15, 0x44, 0x2f, 0x40, 0x1b, 0x2d, 0x18, 0x23, 0x09, 0x97, 0xc5,
	0xe4, 0x4d, 0x09, 0x05, 0x25, 0xea, 0x58, 0x39, 0x98, 0xc5, 0x19, 0x37, 0xd4, 0x4e, 0x65, 0xb7,
	0x03, 0x37, 0xce, 0xb8, 0x39, 0x85, 0xc6, 0x8a, 0x15, 0x07, 0xbe, 0xf6, 0xdd, 0xc2, 0x12, 0x23,
	0x1d, 0x2a, 0xe2, 0x24, 0xf2, 0x0c, 0x04, 0x14, 0xcc, 0x66, 0x67, 0x01, 0x05, 0xc3, 0xf9, 0xcc,
	0x50, 0x73, 0x86, 0xf3, 0xd9, 0x3a, 0xba, 0xea, 0x26, 0x3a, 0xf3, 0x14, 0x5a, 0x7e, 0x12, 0xa5,
	0xd9, 0x94, 0x72, 0xd9, 0xcc, 0xcf, 0x00, 0xa4, 0xd1, 0x11, 0x5d, 0x24, 0x79, 0x9b, 0xa9, 0x58,
	0x5a, 0xef, 0x0b, 0xc2, 0x3c, 0x05, 0x78, 0x1f, 0x73, 0x9f, 0xe4, 0x62, 0x51, 0xf6, 0x74, 0x91,
	0x7c, 0xdf, 0x52, 0xef, 0x61, 0x90, 0x54, 0x2e, 0x7f, 0x0b, 0xfb, 0xb9, 0xbc, 0x2f, 0x38, 0x39,
	0x47, 0x87, 0xca, 0x3c, 0x4e, 0x8a, 0x95, 0x05, 0x14, 0xb6, 0x6e, 0x62, 0x9e, 0xc9, 0x6a, 0x5a,
	0x58, 0xe2, 0x93, 0x6f, 0x70, 0xf0, 0x58, 0x17, 0x22, 0x0d, 0xea, 0x43, 0xef, 0x93, 0x37, 0xb8,
	0xf6, 0xf4, 0x12, 0xaa, 0x43, 0xe5, 0xa3, 0x1d, 0xe8, 0x0a, 0x6a, 0x80, 0xea, 0x3a, 0x7e, 0xa0,
	0x97, 0x11, 0x40, 0xad, 0x8f, 0xed, 0xcb, 0xc0, 0xd6, 0x2b, 0x02, 0x5b, 0xb6, 0x6b, 0x07, 0xb6,
	0xae, 0x0a, 0x3c, 0xbc, 0xb2, 0x04, 0x5f, 0x3d, 0xe1, 0xc5, 0xe5, 0x95, 0xc9, 0x35, 0x40, 0xf5,
	0x06, 0x9e, 0xad, 0x97, 0x10, 0x82, 0xf6, 0xa5, 0x8b, 0xed, 0x4b, 0xeb, 0x6b, 0x68, 0x7f, 0x71,
	0xfc, 0xc0, 0xd7, 0x15, 0xb4, 0x07, 0x4d, 0x6f, 0x10, 0x84, 0x1f, 0x06, 0x43, 0xcf, 0xd2, 0xcb,
	0xe8, 0x08, 0x8c, 0x2b, 0x6c, 0xf7, 0x07, 0x9e, 0xe5, 0x04, 0xce, 0xc0, 0x0b, 0xc5, 0xd8, 0x67,
	0x3b, 0x08, 0x5d, 0xdf, 0xd3, 0x61, 0xe7, 0xe8, 0xd0, 0xb1, 0x74, 0xad, 0xf7, 0x53, 0x81, 0x76,
	0x51, 0x92, 0x4f, 0xd8, 0x32, 0x1e, 0x11, 0xe4, 0x80, 0x66, 0xd1, 0xcd, 0x85, 0xdc, 0xf9, 0x22,
	0x1c, 0x3e, 0x71, 0xcf, 0xcd, 0x12, 0xba, 0x80, 0xaa, 0x7c, 0xf1, 0xd0, 0xc1, 0x4a, 0xba, 0xfd,
	0xd2, 0x1e, 0xa2, 0x7b, 0xac, 0x7c, 0x16, 0xcd, 0xd2, 0xb9, 0x72, 0x53, 0x93, 0x0f, 0xf4, 0xeb,
	0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x95, 0x71, 0x89, 0x15, 0xb0, 0x05, 0x00, 0x00,
}
