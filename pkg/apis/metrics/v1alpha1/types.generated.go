/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// ************************************************************
// DO NOT EDIT.
// THIS FILE IS AUTO-GENERATED BY codecgen.
// ************************************************************

package v1alpha1

import (
	"errors"
	"fmt"
	codec1978 "github.com/ugorji/go/codec"
	pkg1_unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	"reflect"
	"runtime"
)

const (
	codecSelferC_UTF81234         = 1
	codecSelferC_RAW1234          = 0
	codecSelferValueTypeArray1234 = 10
	codecSelferValueTypeMap1234   = 9
)

var (
	codecSelferBitsize1234                         = uint8(reflect.TypeOf(uint(0)).Bits())
	codecSelferOnlyMapOrArrayEncodeToStructErr1234 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer1234 struct{}

func init() {
	if codec1978.GenVersion != 4 {
		_, file, _, _ := runtime.Caller(0)
		err := fmt.Errorf("codecgen version mismatch: current: %v, need %v. Re-generate file: %v",
			4, codec1978.GenVersion, file)
		panic(err)
	}
	if false { // reference the types, but skip this branch at build/run time
		var v0 pkg1_unversioned.TypeMeta
		_ = v0
	}
}

func (x *RawNode) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym1 := z.EncBinary()
		_ = yym1
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			var yyq2 [2]bool
			_, _, _ = yysep2, yyq2, yy2arr2
			const yyr2 bool = false
			yyq2[0] = x.Kind != ""
			yyq2[1] = true
			if yyr2 || yy2arr2 {
				r.EncodeArrayStart(2)
			} else {
				var yynn2 int = 0
				for _, b := range yyq2 {
					if b {
						yynn2++
					}
				}
				r.EncodeMapStart(yynn2)
			}
			if yyr2 || yy2arr2 {
				if yyq2[0] {
					yym4 := z.EncBinary()
					_ = yym4
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq2[0] {
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					yym5 := z.EncBinary()
					_ = yym5
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr2 || yy2arr2 {
				if yyq2[1] {
					yy7 := &x.APIVersion
					yym8 := z.EncBinary()
					_ = yym8
					if false {
					} else if z.HasExtensions() && z.EncExt(yy7) {
					} else if !yym8 && z.IsJSONHandle() {
						z.EncJSONMarshal(yy7)
					} else {
						z.EncFallback(yy7)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq2[1] {
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					yy9 := &x.APIVersion
					yym10 := z.EncBinary()
					_ = yym10
					if false {
					} else if z.HasExtensions() && z.EncExt(yy9) {
					} else if !yym10 && z.IsJSONHandle() {
						z.EncJSONMarshal(yy9)
					} else {
						z.EncFallback(yy9)
					}
				}
			}
			if yysep2 {
				r.EncodeEnd()
			}
		}
	}
}

func (x *RawNode) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym11 := z.DecBinary()
	_ = yym11
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		if r.IsContainerType(codecSelferValueTypeMap1234) {
			yyl12 := r.ReadMapStart()
			if yyl12 == 0 {
				r.ReadEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl12, d)
			}
		} else if r.IsContainerType(codecSelferValueTypeArray1234) {
			yyl12 := r.ReadArrayStart()
			if yyl12 == 0 {
				r.ReadEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl12, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *RawNode) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys13Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys13Slc
	var yyhl13 bool = l >= 0
	for yyj13 := 0; ; yyj13++ {
		if yyhl13 {
			if yyj13 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		yys13Slc = r.DecodeBytes(yys13Slc, true, true)
		yys13 := string(yys13Slc)
		switch yys13 {
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = pkg1_unversioned.GroupVersion{}
			} else {
				yyv15 := &x.APIVersion
				yym16 := z.DecBinary()
				_ = yym16
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv15) {
				} else if !yym16 && z.IsJSONHandle() {
					z.DecJSONUnmarshal(yyv15)
				} else {
					z.DecFallback(yyv15, false)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys13)
		} // end switch yys13
	} // end for yyj13
	if !yyhl13 {
		r.ReadEnd()
	}
}

func (x *RawNode) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj17 int
	var yyb17 bool
	var yyhl17 bool = l >= 0
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj17++
	if yyhl17 {
		yyb17 = yyj17 > l
	} else {
		yyb17 = r.CheckBreak()
	}
	if yyb17 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.APIVersion = pkg1_unversioned.GroupVersion{}
	} else {
		yyv19 := &x.APIVersion
		yym20 := z.DecBinary()
		_ = yym20
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv19) {
		} else if !yym20 && z.IsJSONHandle() {
			z.DecJSONUnmarshal(yyv19)
		} else {
			z.DecFallback(yyv19, false)
		}
	}
	for {
		yyj17++
		if yyhl17 {
			yyb17 = yyj17 > l
		} else {
			yyb17 = r.CheckBreak()
		}
		if yyb17 {
			break
		}
		z.DecStructFieldNotFound(yyj17-1, "")
	}
	r.ReadEnd()
}

func (x *RawPod) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym21 := z.EncBinary()
		_ = yym21
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep22 := !z.EncBinary()
			yy2arr22 := z.EncBasicHandle().StructToArray
			var yyq22 [2]bool
			_, _, _ = yysep22, yyq22, yy2arr22
			const yyr22 bool = false
			yyq22[0] = x.Kind != ""
			yyq22[1] = true
			if yyr22 || yy2arr22 {
				r.EncodeArrayStart(2)
			} else {
				var yynn22 int = 0
				for _, b := range yyq22 {
					if b {
						yynn22++
					}
				}
				r.EncodeMapStart(yynn22)
			}
			if yyr22 || yy2arr22 {
				if yyq22[0] {
					yym24 := z.EncBinary()
					_ = yym24
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq22[0] {
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					yym25 := z.EncBinary()
					_ = yym25
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr22 || yy2arr22 {
				if yyq22[1] {
					yy27 := &x.APIVersion
					yym28 := z.EncBinary()
					_ = yym28
					if false {
					} else if z.HasExtensions() && z.EncExt(yy27) {
					} else if !yym28 && z.IsJSONHandle() {
						z.EncJSONMarshal(yy27)
					} else {
						z.EncFallback(yy27)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq22[1] {
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					yy29 := &x.APIVersion
					yym30 := z.EncBinary()
					_ = yym30
					if false {
					} else if z.HasExtensions() && z.EncExt(yy29) {
					} else if !yym30 && z.IsJSONHandle() {
						z.EncJSONMarshal(yy29)
					} else {
						z.EncFallback(yy29)
					}
				}
			}
			if yysep22 {
				r.EncodeEnd()
			}
		}
	}
}

func (x *RawPod) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym31 := z.DecBinary()
	_ = yym31
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		if r.IsContainerType(codecSelferValueTypeMap1234) {
			yyl32 := r.ReadMapStart()
			if yyl32 == 0 {
				r.ReadEnd()
			} else {
				x.codecDecodeSelfFromMap(yyl32, d)
			}
		} else if r.IsContainerType(codecSelferValueTypeArray1234) {
			yyl32 := r.ReadArrayStart()
			if yyl32 == 0 {
				r.ReadEnd()
			} else {
				x.codecDecodeSelfFromArray(yyl32, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *RawPod) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys33Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys33Slc
	var yyhl33 bool = l >= 0
	for yyj33 := 0; ; yyj33++ {
		if yyhl33 {
			if yyj33 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		yys33Slc = r.DecodeBytes(yys33Slc, true, true)
		yys33 := string(yys33Slc)
		switch yys33 {
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = pkg1_unversioned.GroupVersion{}
			} else {
				yyv35 := &x.APIVersion
				yym36 := z.DecBinary()
				_ = yym36
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv35) {
				} else if !yym36 && z.IsJSONHandle() {
					z.DecJSONUnmarshal(yyv35)
				} else {
					z.DecFallback(yyv35, false)
				}
			}
		default:
			z.DecStructFieldNotFound(-1, yys33)
		} // end switch yys33
	} // end for yyj33
	if !yyhl33 {
		r.ReadEnd()
	}
}

func (x *RawPod) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj37 int
	var yyb37 bool
	var yyhl37 bool = l >= 0
	yyj37++
	if yyhl37 {
		yyb37 = yyj37 > l
	} else {
		yyb37 = r.CheckBreak()
	}
	if yyb37 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj37++
	if yyhl37 {
		yyb37 = yyj37 > l
	} else {
		yyb37 = r.CheckBreak()
	}
	if yyb37 {
		r.ReadEnd()
		return
	}
	if r.TryDecodeAsNil() {
		x.APIVersion = pkg1_unversioned.GroupVersion{}
	} else {
		yyv39 := &x.APIVersion
		yym40 := z.DecBinary()
		_ = yym40
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv39) {
		} else if !yym40 && z.IsJSONHandle() {
			z.DecJSONUnmarshal(yyv39)
		} else {
			z.DecFallback(yyv39, false)
		}
	}
	for {
		yyj37++
		if yyhl37 {
			yyb37 = yyj37 > l
		} else {
			yyb37 = r.CheckBreak()
		}
		if yyb37 {
			break
		}
		z.DecStructFieldNotFound(yyj37-1, "")
	}
	r.ReadEnd()
}
