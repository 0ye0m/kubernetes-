// +build !ignore_autogenerated

/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by unstructured-conversion-gen. Do not edit it manually!

package v1

import (
	types "k8s.io/kubernetes/pkg/types"
)

func ConvertToUnstructured_AWSElasticBlockStoreVolumeSource(in *AWSElasticBlockStoreVolumeSource, out map[string]interface{}) error {
	out["volumeID"] = in.VolumeID
	out["fsType"] = in.FSType
	out["partition"] = in.Partition
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_Affinity(in *Affinity, out map[string]interface{}) error {
	if in.NodeAffinity != nil {
		result := make(map[string]interface{})
		{
			in, out := in.NodeAffinity, result
			if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
				result := make(map[string]interface{})
				{
					in, out := in.RequiredDuringSchedulingIgnoredDuringExecution, result
					if in.NodeSelectorTerms != nil {
						result := make([]interface{}, len(in.NodeSelectorTerms))
						{
							in, out := &in.NodeSelectorTerms, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_NodeSelectorTerm(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["nodeSelectorTerms"] = result
					}
				}
				out["requiredDuringSchedulingIgnoredDuringExecution"] = &result
			}
			if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
				result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
				{
					in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_PreferredSchedulingTerm(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["preferredDuringSchedulingIgnoredDuringExecution"] = result
			}
		}
		out["nodeAffinity"] = &result
	}
	if in.PodAffinity != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PodAffinity, result
			if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
				result := make([]interface{}, len(in.RequiredDuringSchedulingIgnoredDuringExecution))
				{
					in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_PodAffinityTerm(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["requiredDuringSchedulingIgnoredDuringExecution"] = result
			}
			if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
				result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
				{
					in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_WeightedPodAffinityTerm(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["preferredDuringSchedulingIgnoredDuringExecution"] = result
			}
		}
		out["podAffinity"] = &result
	}
	if in.PodAntiAffinity != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PodAntiAffinity, result
			if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
				result := make([]interface{}, len(in.RequiredDuringSchedulingIgnoredDuringExecution))
				{
					in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_PodAffinityTerm(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["requiredDuringSchedulingIgnoredDuringExecution"] = result
			}
			if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
				result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
				{
					in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_WeightedPodAffinityTerm(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["preferredDuringSchedulingIgnoredDuringExecution"] = result
			}
		}
		out["podAntiAffinity"] = &result
	}
	return nil
}

func ConvertToUnstructured_AttachedVolume(in *AttachedVolume, out map[string]interface{}) error {
	out["name"] = in.Name
	out["devicePath"] = in.DevicePath
	return nil
}

func ConvertToUnstructured_AvoidPods(in *AvoidPods, out map[string]interface{}) error {
	if in.PreferAvoidPods != nil {
		result := make([]interface{}, len(in.PreferAvoidPods))
		{
			in, out := &in.PreferAvoidPods, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PreferAvoidPodsEntry(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["preferAvoidPods"] = result
	}
	return nil
}

func ConvertToUnstructured_AzureDiskVolumeSource(in *AzureDiskVolumeSource, out map[string]interface{}) error {
	out["diskName"] = in.DiskName
	out["diskURI"] = in.DataDiskURI
	if in.CachingMode != nil {
		var result AzureDataDiskCachingMode
		{
			in, out := in.CachingMode, result
			out = *in
		}
		out["cachingMode"] = &result
	}
	if in.FSType != nil {
		var result string
		{
			in, out := in.FSType, result
			out = *in
		}
		out["fsType"] = &result
	}
	if in.ReadOnly != nil {
		var result bool
		{
			in, out := in.ReadOnly, result
			out = *in
		}
		out["readOnly"] = &result
	}
	return nil
}

func ConvertToUnstructured_AzureFileVolumeSource(in *AzureFileVolumeSource, out map[string]interface{}) error {
	out["secretName"] = in.SecretName
	out["shareName"] = in.ShareName
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_Binding(in *Binding, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectReference(&in.Target, result); err != nil {
			return err
		}
		out["target"] = result
	}
	return nil
}

func ConvertToUnstructured_Capabilities(in *Capabilities, out map[string]interface{}) error {
	if in.Add != nil {
		result := make([]interface{}, len(in.Add))
		{
			in, out := &in.Add, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["add"] = result
	}
	if in.Drop != nil {
		result := make([]interface{}, len(in.Drop))
		{
			in, out := &in.Drop, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["drop"] = result
	}
	return nil
}

func ConvertToUnstructured_CephFSVolumeSource(in *CephFSVolumeSource, out map[string]interface{}) error {
	if in.Monitors != nil {
		result := make([]interface{}, len(in.Monitors))
		{
			in, out := &in.Monitors, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["monitors"] = result
	}
	out["path"] = in.Path
	out["user"] = in.User
	out["secretFile"] = in.SecretFile
	if in.SecretRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SecretRef, result
			out["name"] = in.Name
		}
		out["secretRef"] = &result
	}
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_CinderVolumeSource(in *CinderVolumeSource, out map[string]interface{}) error {
	out["volumeID"] = in.VolumeID
	out["fsType"] = in.FSType
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_CodecSelfer1234(in *codecSelfer1234, out map[string]interface{}) error {
	return nil
}

func ConvertToUnstructured_ComponentCondition(in *ComponentCondition, out map[string]interface{}) error {
	out["type"] = in.Type
	out["status"] = in.Status
	out["message"] = in.Message
	out["error"] = in.Error
	return nil
}

func ConvertToUnstructured_ComponentStatus(in *ComponentStatus, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Conditions != nil {
		result := make([]interface{}, len(in.Conditions))
		{
			in, out := &in.Conditions, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ComponentCondition(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["conditions"] = result
	}
	return nil
}

func ConvertToUnstructured_ComponentStatusList(in *ComponentStatusList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ComponentStatus(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ConfigMap(in *ConfigMap, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Data != nil {
		out["data"] = in.Data
	}
	return nil
}

func ConvertToUnstructured_ConfigMapKeySelector(in *ConfigMapKeySelector, out map[string]interface{}) error {
	if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
		return err
	}
	out["key"] = in.Key
	return nil
}

func ConvertToUnstructured_ConfigMapList(in *ConfigMapList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ConfigMap(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ConfigMapVolumeSource(in *ConfigMapVolumeSource, out map[string]interface{}) error {
	if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
		return err
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_KeyToPath(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	if in.DefaultMode != nil {
		var result int32
		{
			in, out := in.DefaultMode, result
			out = *in
		}
		out["defaultMode"] = &result
	}
	return nil
}

func ConvertToUnstructured_Container(in *Container, out map[string]interface{}) error {
	out["name"] = in.Name
	out["image"] = in.Image
	if in.Command != nil {
		result := make([]interface{}, len(in.Command))
		{
			in, out := &in.Command, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["command"] = result
	}
	if in.Args != nil {
		result := make([]interface{}, len(in.Args))
		{
			in, out := &in.Args, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["args"] = result
	}
	out["workingDir"] = in.WorkingDir
	if in.Ports != nil {
		result := make([]interface{}, len(in.Ports))
		{
			in, out := &in.Ports, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ContainerPort(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["ports"] = result
	}
	if in.Env != nil {
		result := make([]interface{}, len(in.Env))
		{
			in, out := &in.Env, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_EnvVar(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["env"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ResourceRequirements(&in.Resources, result); err != nil {
			return err
		}
		out["resources"] = result
	}
	if in.VolumeMounts != nil {
		result := make([]interface{}, len(in.VolumeMounts))
		{
			in, out := &in.VolumeMounts, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_VolumeMount(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["volumeMounts"] = result
	}
	if in.LivenessProbe != nil {
		result := make(map[string]interface{})
		{
			in, out := in.LivenessProbe, result
			if err := ConvertToUnstructured_Handler(&in.Handler, out); err != nil {
				return err
			}
			out["initialDelaySeconds"] = in.InitialDelaySeconds
			out["timeoutSeconds"] = in.TimeoutSeconds
			out["periodSeconds"] = in.PeriodSeconds
			out["successThreshold"] = in.SuccessThreshold
			out["failureThreshold"] = in.FailureThreshold
		}
		out["livenessProbe"] = &result
	}
	if in.ReadinessProbe != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ReadinessProbe, result
			if err := ConvertToUnstructured_Handler(&in.Handler, out); err != nil {
				return err
			}
			out["initialDelaySeconds"] = in.InitialDelaySeconds
			out["timeoutSeconds"] = in.TimeoutSeconds
			out["periodSeconds"] = in.PeriodSeconds
			out["successThreshold"] = in.SuccessThreshold
			out["failureThreshold"] = in.FailureThreshold
		}
		out["readinessProbe"] = &result
	}
	if in.Lifecycle != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Lifecycle, result
			if in.PostStart != nil {
				result := make(map[string]interface{})
				{
					in, out := in.PostStart, result
					if in.Exec != nil {
						result := make(map[string]interface{})
						{
							in, out := in.Exec, result
							if in.Command != nil {
								result := make([]interface{}, len(in.Command))
								{
									in, out := &in.Command, result
									for i := range *in {
										out = append(out, (*in)[i])
									}
								}
								out["command"] = result
							}
						}
						out["exec"] = &result
					}
					if in.HTTPGet != nil {
						result := make(map[string]interface{})
						{
							in, out := in.HTTPGet, result
							out["path"] = in.Path
							{
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
									return err
								}
								out["port"] = result
							}
							out["host"] = in.Host
							out["scheme"] = in.Scheme
							if in.HTTPHeaders != nil {
								result := make([]interface{}, len(in.HTTPHeaders))
								{
									in, out := &in.HTTPHeaders, result
									for i := range *in {
										result := make(map[string]interface{})
										if err := ConvertToUnstructured_HTTPHeader(&(*in)[i], result); err != nil {
											return err
										}
										out = append(out, result)
									}
								}
								out["httpHeaders"] = result
							}
						}
						out["httpGet"] = &result
					}
					if in.TCPSocket != nil {
						result := make(map[string]interface{})
						{
							in, out := in.TCPSocket, result
							{
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
									return err
								}
								out["port"] = result
							}
						}
						out["tcpSocket"] = &result
					}
				}
				out["postStart"] = &result
			}
			if in.PreStop != nil {
				result := make(map[string]interface{})
				{
					in, out := in.PreStop, result
					if in.Exec != nil {
						result := make(map[string]interface{})
						{
							in, out := in.Exec, result
							if in.Command != nil {
								result := make([]interface{}, len(in.Command))
								{
									in, out := &in.Command, result
									for i := range *in {
										out = append(out, (*in)[i])
									}
								}
								out["command"] = result
							}
						}
						out["exec"] = &result
					}
					if in.HTTPGet != nil {
						result := make(map[string]interface{})
						{
							in, out := in.HTTPGet, result
							out["path"] = in.Path
							{
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
									return err
								}
								out["port"] = result
							}
							out["host"] = in.Host
							out["scheme"] = in.Scheme
							if in.HTTPHeaders != nil {
								result := make([]interface{}, len(in.HTTPHeaders))
								{
									in, out := &in.HTTPHeaders, result
									for i := range *in {
										result := make(map[string]interface{})
										if err := ConvertToUnstructured_HTTPHeader(&(*in)[i], result); err != nil {
											return err
										}
										out = append(out, result)
									}
								}
								out["httpHeaders"] = result
							}
						}
						out["httpGet"] = &result
					}
					if in.TCPSocket != nil {
						result := make(map[string]interface{})
						{
							in, out := in.TCPSocket, result
							{
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
									return err
								}
								out["port"] = result
							}
						}
						out["tcpSocket"] = &result
					}
				}
				out["preStop"] = &result
			}
		}
		out["lifecycle"] = &result
	}
	out["terminationMessagePath"] = in.TerminationMessagePath
	out["imagePullPolicy"] = in.ImagePullPolicy
	if in.SecurityContext != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SecurityContext, result
			if in.Capabilities != nil {
				result := make(map[string]interface{})
				{
					in, out := in.Capabilities, result
					if in.Add != nil {
						result := make([]interface{}, len(in.Add))
						{
							in, out := &in.Add, result
							for i := range *in {
								out = append(out, (*in)[i])
							}
						}
						out["add"] = result
					}
					if in.Drop != nil {
						result := make([]interface{}, len(in.Drop))
						{
							in, out := &in.Drop, result
							for i := range *in {
								out = append(out, (*in)[i])
							}
						}
						out["drop"] = result
					}
				}
				out["capabilities"] = &result
			}
			if in.Privileged != nil {
				var result bool
				{
					in, out := in.Privileged, result
					out = *in
				}
				out["privileged"] = &result
			}
			if in.SELinuxOptions != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SELinuxOptions, result
					out["user"] = in.User
					out["role"] = in.Role
					out["type"] = in.Type
					out["level"] = in.Level
				}
				out["seLinuxOptions"] = &result
			}
			if in.RunAsUser != nil {
				var result int64
				{
					in, out := in.RunAsUser, result
					out = *in
				}
				out["runAsUser"] = &result
			}
			if in.RunAsNonRoot != nil {
				var result bool
				{
					in, out := in.RunAsNonRoot, result
					out = *in
				}
				out["runAsNonRoot"] = &result
			}
			if in.ReadOnlyRootFilesystem != nil {
				var result bool
				{
					in, out := in.ReadOnlyRootFilesystem, result
					out = *in
				}
				out["readOnlyRootFilesystem"] = &result
			}
		}
		out["securityContext"] = &result
	}
	out["stdin"] = in.Stdin
	out["stdinOnce"] = in.StdinOnce
	out["tty"] = in.TTY
	return nil
}

func ConvertToUnstructured_ContainerImage(in *ContainerImage, out map[string]interface{}) error {
	if in.Names != nil {
		result := make([]interface{}, len(in.Names))
		{
			in, out := &in.Names, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["names"] = result
	}
	out["sizeBytes"] = in.SizeBytes
	return nil
}

func ConvertToUnstructured_ContainerPort(in *ContainerPort, out map[string]interface{}) error {
	out["name"] = in.Name
	out["hostPort"] = in.HostPort
	out["containerPort"] = in.ContainerPort
	out["protocol"] = in.Protocol
	out["hostIP"] = in.HostIP
	return nil
}

func ConvertToUnstructured_ContainerState(in *ContainerState, out map[string]interface{}) error {
	if in.Waiting != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Waiting, result
			out["reason"] = in.Reason
			out["message"] = in.Message
		}
		out["waiting"] = &result
	}
	if in.Running != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Running, result
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Time(&in.StartedAt, result); err != nil {
					return err
				}
				out["startedAt"] = result
			}
		}
		out["running"] = &result
	}
	if in.Terminated != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Terminated, result
			out["exitCode"] = in.ExitCode
			out["signal"] = in.Signal
			out["reason"] = in.Reason
			out["message"] = in.Message
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Time(&in.StartedAt, result); err != nil {
					return err
				}
				out["startedAt"] = result
			}
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Time(&in.FinishedAt, result); err != nil {
					return err
				}
				out["finishedAt"] = result
			}
			out["containerID"] = in.ContainerID
		}
		out["terminated"] = &result
	}
	return nil
}

func ConvertToUnstructured_ContainerStateRunning(in *ContainerStateRunning, out map[string]interface{}) error {
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.StartedAt, result); err != nil {
			return err
		}
		out["startedAt"] = result
	}
	return nil
}

func ConvertToUnstructured_ContainerStateTerminated(in *ContainerStateTerminated, out map[string]interface{}) error {
	out["exitCode"] = in.ExitCode
	out["signal"] = in.Signal
	out["reason"] = in.Reason
	out["message"] = in.Message
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.StartedAt, result); err != nil {
			return err
		}
		out["startedAt"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.FinishedAt, result); err != nil {
			return err
		}
		out["finishedAt"] = result
	}
	out["containerID"] = in.ContainerID
	return nil
}

func ConvertToUnstructured_ContainerStateWaiting(in *ContainerStateWaiting, out map[string]interface{}) error {
	out["reason"] = in.Reason
	out["message"] = in.Message
	return nil
}

func ConvertToUnstructured_ContainerStatus(in *ContainerStatus, out map[string]interface{}) error {
	out["name"] = in.Name
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ContainerState(&in.State, result); err != nil {
			return err
		}
		out["state"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ContainerState(&in.LastTerminationState, result); err != nil {
			return err
		}
		out["lastState"] = result
	}
	out["ready"] = in.Ready
	out["restartCount"] = in.RestartCount
	out["image"] = in.Image
	out["imageID"] = in.ImageID
	out["containerID"] = in.ContainerID
	return nil
}

func ConvertToUnstructured_DaemonEndpoint(in *DaemonEndpoint, out map[string]interface{}) error {
	out["Port"] = in.Port
	return nil
}

func ConvertToUnstructured_DeleteOptions(in *DeleteOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	if in.GracePeriodSeconds != nil {
		var result int64
		{
			in, out := in.GracePeriodSeconds, result
			out = *in
		}
		out["gracePeriodSeconds"] = &result
	}
	if in.Preconditions != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Preconditions, result
			if in.UID != nil {
				var result types.UID
				{
					in, out := in.UID, result
					out = *in
				}
				out["uid"] = &result
			}
		}
		out["preconditions"] = &result
	}
	if in.OrphanDependents != nil {
		var result bool
		{
			in, out := in.OrphanDependents, result
			out = *in
		}
		out["orphanDependents"] = &result
	}
	return nil
}

func ConvertToUnstructured_DownwardAPIVolumeFile(in *DownwardAPIVolumeFile, out map[string]interface{}) error {
	out["path"] = in.Path
	if in.FieldRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.FieldRef, result
			out["apiVersion"] = in.APIVersion
			out["fieldPath"] = in.FieldPath
		}
		out["fieldRef"] = &result
	}
	if in.ResourceFieldRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ResourceFieldRef, result
			out["containerName"] = in.ContainerName
			out["resource"] = in.Resource
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&in.Divisor, result); err != nil {
					return err
				}
				out["divisor"] = result
			}
		}
		out["resourceFieldRef"] = &result
	}
	if in.Mode != nil {
		var result int32
		{
			in, out := in.Mode, result
			out = *in
		}
		out["mode"] = &result
	}
	return nil
}

func ConvertToUnstructured_DownwardAPIVolumeSource(in *DownwardAPIVolumeSource, out map[string]interface{}) error {
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_DownwardAPIVolumeFile(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	if in.DefaultMode != nil {
		var result int32
		{
			in, out := in.DefaultMode, result
			out = *in
		}
		out["defaultMode"] = &result
	}
	return nil
}

func ConvertToUnstructured_EmptyDirVolumeSource(in *EmptyDirVolumeSource, out map[string]interface{}) error {
	out["medium"] = in.Medium
	return nil
}

func ConvertToUnstructured_EndpointAddress(in *EndpointAddress, out map[string]interface{}) error {
	out["ip"] = in.IP
	out["hostname"] = in.Hostname
	if in.NodeName != nil {
		var result string
		{
			in, out := in.NodeName, result
			out = *in
		}
		out["nodeName"] = &result
	}
	if in.TargetRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.TargetRef, result
			out["kind"] = in.Kind
			out["namespace"] = in.Namespace
			out["name"] = in.Name
			out["uid"] = in.UID
			out["apiVersion"] = in.APIVersion
			out["resourceVersion"] = in.ResourceVersion
			out["fieldPath"] = in.FieldPath
		}
		out["targetRef"] = &result
	}
	return nil
}

func ConvertToUnstructured_EndpointPort(in *EndpointPort, out map[string]interface{}) error {
	out["name"] = in.Name
	out["port"] = in.Port
	out["protocol"] = in.Protocol
	return nil
}

func ConvertToUnstructured_EndpointSubset(in *EndpointSubset, out map[string]interface{}) error {
	if in.Addresses != nil {
		result := make([]interface{}, len(in.Addresses))
		{
			in, out := &in.Addresses, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_EndpointAddress(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["addresses"] = result
	}
	if in.NotReadyAddresses != nil {
		result := make([]interface{}, len(in.NotReadyAddresses))
		{
			in, out := &in.NotReadyAddresses, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_EndpointAddress(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["notReadyAddresses"] = result
	}
	if in.Ports != nil {
		result := make([]interface{}, len(in.Ports))
		{
			in, out := &in.Ports, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_EndpointPort(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["ports"] = result
	}
	return nil
}

func ConvertToUnstructured_Endpoints(in *Endpoints, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Subsets != nil {
		result := make([]interface{}, len(in.Subsets))
		{
			in, out := &in.Subsets, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_EndpointSubset(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["subsets"] = result
	}
	return nil
}

func ConvertToUnstructured_EndpointsList(in *EndpointsList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Endpoints(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_EnvVar(in *EnvVar, out map[string]interface{}) error {
	out["name"] = in.Name
	out["value"] = in.Value
	if in.ValueFrom != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ValueFrom, result
			if in.FieldRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.FieldRef, result
					out["apiVersion"] = in.APIVersion
					out["fieldPath"] = in.FieldPath
				}
				out["fieldRef"] = &result
			}
			if in.ResourceFieldRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.ResourceFieldRef, result
					out["containerName"] = in.ContainerName
					out["resource"] = in.Resource
					{
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_Quantity(&in.Divisor, result); err != nil {
							return err
						}
						out["divisor"] = result
					}
				}
				out["resourceFieldRef"] = &result
			}
			if in.ConfigMapKeyRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.ConfigMapKeyRef, result
					if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
						return err
					}
					out["key"] = in.Key
				}
				out["configMapKeyRef"] = &result
			}
			if in.SecretKeyRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretKeyRef, result
					if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
						return err
					}
					out["key"] = in.Key
				}
				out["secretKeyRef"] = &result
			}
		}
		out["valueFrom"] = &result
	}
	return nil
}

func ConvertToUnstructured_EnvVarSource(in *EnvVarSource, out map[string]interface{}) error {
	if in.FieldRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.FieldRef, result
			out["apiVersion"] = in.APIVersion
			out["fieldPath"] = in.FieldPath
		}
		out["fieldRef"] = &result
	}
	if in.ResourceFieldRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ResourceFieldRef, result
			out["containerName"] = in.ContainerName
			out["resource"] = in.Resource
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&in.Divisor, result); err != nil {
					return err
				}
				out["divisor"] = result
			}
		}
		out["resourceFieldRef"] = &result
	}
	if in.ConfigMapKeyRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ConfigMapKeyRef, result
			if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
				return err
			}
			out["key"] = in.Key
		}
		out["configMapKeyRef"] = &result
	}
	if in.SecretKeyRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SecretKeyRef, result
			if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
				return err
			}
			out["key"] = in.Key
		}
		out["secretKeyRef"] = &result
	}
	return nil
}

func ConvertToUnstructured_Event(in *Event, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectReference(&in.InvolvedObject, result); err != nil {
			return err
		}
		out["involvedObject"] = result
	}
	out["reason"] = in.Reason
	out["message"] = in.Message
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_EventSource(&in.Source, result); err != nil {
			return err
		}
		out["source"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.FirstTimestamp, result); err != nil {
			return err
		}
		out["firstTimestamp"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.LastTimestamp, result); err != nil {
			return err
		}
		out["lastTimestamp"] = result
	}
	out["count"] = in.Count
	out["type"] = in.Type
	return nil
}

func ConvertToUnstructured_EventList(in *EventList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Event(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_EventSource(in *EventSource, out map[string]interface{}) error {
	out["component"] = in.Component
	out["host"] = in.Host
	return nil
}

func ConvertToUnstructured_ExecAction(in *ExecAction, out map[string]interface{}) error {
	if in.Command != nil {
		result := make([]interface{}, len(in.Command))
		{
			in, out := &in.Command, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["command"] = result
	}
	return nil
}

func ConvertToUnstructured_FCVolumeSource(in *FCVolumeSource, out map[string]interface{}) error {
	if in.TargetWWNs != nil {
		result := make([]interface{}, len(in.TargetWWNs))
		{
			in, out := &in.TargetWWNs, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["targetWWNs"] = result
	}
	if in.Lun != nil {
		var result int32
		{
			in, out := in.Lun, result
			out = *in
		}
		out["lun"] = &result
	}
	out["fsType"] = in.FSType
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_FlexVolumeSource(in *FlexVolumeSource, out map[string]interface{}) error {
	out["driver"] = in.Driver
	out["fsType"] = in.FSType
	if in.SecretRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SecretRef, result
			out["name"] = in.Name
		}
		out["secretRef"] = &result
	}
	out["readOnly"] = in.ReadOnly
	if in.Options != nil {
		out["options"] = in.Options
	}
	return nil
}

func ConvertToUnstructured_FlockerVolumeSource(in *FlockerVolumeSource, out map[string]interface{}) error {
	out["datasetName"] = in.DatasetName
	out["datasetUUID"] = in.DatasetUUID
	return nil
}

func ConvertToUnstructured_GCEPersistentDiskVolumeSource(in *GCEPersistentDiskVolumeSource, out map[string]interface{}) error {
	out["pdName"] = in.PDName
	out["fsType"] = in.FSType
	out["partition"] = in.Partition
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_GitRepoVolumeSource(in *GitRepoVolumeSource, out map[string]interface{}) error {
	out["repository"] = in.Repository
	out["revision"] = in.Revision
	out["directory"] = in.Directory
	return nil
}

func ConvertToUnstructured_GlusterfsVolumeSource(in *GlusterfsVolumeSource, out map[string]interface{}) error {
	out["endpoints"] = in.EndpointsName
	out["path"] = in.Path
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_HTTPGetAction(in *HTTPGetAction, out map[string]interface{}) error {
	out["path"] = in.Path
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
			return err
		}
		out["port"] = result
	}
	out["host"] = in.Host
	out["scheme"] = in.Scheme
	if in.HTTPHeaders != nil {
		result := make([]interface{}, len(in.HTTPHeaders))
		{
			in, out := &in.HTTPHeaders, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_HTTPHeader(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["httpHeaders"] = result
	}
	return nil
}

func ConvertToUnstructured_HTTPHeader(in *HTTPHeader, out map[string]interface{}) error {
	out["name"] = in.Name
	out["value"] = in.Value
	return nil
}

func ConvertToUnstructured_Handler(in *Handler, out map[string]interface{}) error {
	if in.Exec != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Exec, result
			if in.Command != nil {
				result := make([]interface{}, len(in.Command))
				{
					in, out := &in.Command, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["command"] = result
			}
		}
		out["exec"] = &result
	}
	if in.HTTPGet != nil {
		result := make(map[string]interface{})
		{
			in, out := in.HTTPGet, result
			out["path"] = in.Path
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
					return err
				}
				out["port"] = result
			}
			out["host"] = in.Host
			out["scheme"] = in.Scheme
			if in.HTTPHeaders != nil {
				result := make([]interface{}, len(in.HTTPHeaders))
				{
					in, out := &in.HTTPHeaders, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_HTTPHeader(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["httpHeaders"] = result
			}
		}
		out["httpGet"] = &result
	}
	if in.TCPSocket != nil {
		result := make(map[string]interface{})
		{
			in, out := in.TCPSocket, result
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
					return err
				}
				out["port"] = result
			}
		}
		out["tcpSocket"] = &result
	}
	return nil
}

func ConvertToUnstructured_HostPathVolumeSource(in *HostPathVolumeSource, out map[string]interface{}) error {
	out["path"] = in.Path
	return nil
}

func ConvertToUnstructured_ISCSIVolumeSource(in *ISCSIVolumeSource, out map[string]interface{}) error {
	out["targetPortal"] = in.TargetPortal
	out["iqn"] = in.IQN
	out["lun"] = in.Lun
	out["iscsiInterface"] = in.ISCSIInterface
	out["fsType"] = in.FSType
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_KeyToPath(in *KeyToPath, out map[string]interface{}) error {
	out["key"] = in.Key
	out["path"] = in.Path
	if in.Mode != nil {
		var result int32
		{
			in, out := in.Mode, result
			out = *in
		}
		out["mode"] = &result
	}
	return nil
}

func ConvertToUnstructured_Lifecycle(in *Lifecycle, out map[string]interface{}) error {
	if in.PostStart != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PostStart, result
			if in.Exec != nil {
				result := make(map[string]interface{})
				{
					in, out := in.Exec, result
					if in.Command != nil {
						result := make([]interface{}, len(in.Command))
						{
							in, out := &in.Command, result
							for i := range *in {
								out = append(out, (*in)[i])
							}
						}
						out["command"] = result
					}
				}
				out["exec"] = &result
			}
			if in.HTTPGet != nil {
				result := make(map[string]interface{})
				{
					in, out := in.HTTPGet, result
					out["path"] = in.Path
					{
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
							return err
						}
						out["port"] = result
					}
					out["host"] = in.Host
					out["scheme"] = in.Scheme
					if in.HTTPHeaders != nil {
						result := make([]interface{}, len(in.HTTPHeaders))
						{
							in, out := &in.HTTPHeaders, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_HTTPHeader(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["httpHeaders"] = result
					}
				}
				out["httpGet"] = &result
			}
			if in.TCPSocket != nil {
				result := make(map[string]interface{})
				{
					in, out := in.TCPSocket, result
					{
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
							return err
						}
						out["port"] = result
					}
				}
				out["tcpSocket"] = &result
			}
		}
		out["postStart"] = &result
	}
	if in.PreStop != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PreStop, result
			if in.Exec != nil {
				result := make(map[string]interface{})
				{
					in, out := in.Exec, result
					if in.Command != nil {
						result := make([]interface{}, len(in.Command))
						{
							in, out := &in.Command, result
							for i := range *in {
								out = append(out, (*in)[i])
							}
						}
						out["command"] = result
					}
				}
				out["exec"] = &result
			}
			if in.HTTPGet != nil {
				result := make(map[string]interface{})
				{
					in, out := in.HTTPGet, result
					out["path"] = in.Path
					{
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
							return err
						}
						out["port"] = result
					}
					out["host"] = in.Host
					out["scheme"] = in.Scheme
					if in.HTTPHeaders != nil {
						result := make([]interface{}, len(in.HTTPHeaders))
						{
							in, out := &in.HTTPHeaders, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_HTTPHeader(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["httpHeaders"] = result
					}
				}
				out["httpGet"] = &result
			}
			if in.TCPSocket != nil {
				result := make(map[string]interface{})
				{
					in, out := in.TCPSocket, result
					{
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
							return err
						}
						out["port"] = result
					}
				}
				out["tcpSocket"] = &result
			}
		}
		out["preStop"] = &result
	}
	return nil
}

func ConvertToUnstructured_LimitRange(in *LimitRange, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_LimitRangeSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	return nil
}

func ConvertToUnstructured_LimitRangeItem(in *LimitRangeItem, out map[string]interface{}) error {
	out["type"] = in.Type
	if in.Max != nil {
		result := make([]interface{}, len(in.Max))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["max"] = result
	}
	if in.Min != nil {
		result := make([]interface{}, len(in.Min))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["min"] = result
	}
	if in.Default != nil {
		result := make([]interface{}, len(in.Default))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["default"] = result
	}
	if in.DefaultRequest != nil {
		result := make([]interface{}, len(in.DefaultRequest))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["defaultRequest"] = result
	}
	if in.MaxLimitRequestRatio != nil {
		result := make([]interface{}, len(in.MaxLimitRequestRatio))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["maxLimitRequestRatio"] = result
	}
	return nil
}

func ConvertToUnstructured_LimitRangeList(in *LimitRangeList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_LimitRange(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_LimitRangeSpec(in *LimitRangeSpec, out map[string]interface{}) error {
	if in.Limits != nil {
		result := make([]interface{}, len(in.Limits))
		{
			in, out := &in.Limits, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_LimitRangeItem(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["limits"] = result
	}
	return nil
}

func ConvertToUnstructured_List(in *List, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_RawExtension(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ListOptions(in *ListOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["labelSelector"] = in.LabelSelector
	out["fieldSelector"] = in.FieldSelector
	out["watch"] = in.Watch
	out["resourceVersion"] = in.ResourceVersion
	if in.TimeoutSeconds != nil {
		var result int64
		{
			in, out := in.TimeoutSeconds, result
			out = *in
		}
		out["timeoutSeconds"] = &result
	}
	return nil
}

func ConvertToUnstructured_LoadBalancerIngress(in *LoadBalancerIngress, out map[string]interface{}) error {
	out["ip"] = in.IP
	out["hostname"] = in.Hostname
	return nil
}

func ConvertToUnstructured_LoadBalancerStatus(in *LoadBalancerStatus, out map[string]interface{}) error {
	if in.Ingress != nil {
		result := make([]interface{}, len(in.Ingress))
		{
			in, out := &in.Ingress, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_LoadBalancerIngress(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["ingress"] = result
	}
	return nil
}

func ConvertToUnstructured_LocalObjectReference(in *LocalObjectReference, out map[string]interface{}) error {
	out["name"] = in.Name
	return nil
}

func ConvertToUnstructured_NFSVolumeSource(in *NFSVolumeSource, out map[string]interface{}) error {
	out["server"] = in.Server
	out["path"] = in.Path
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_Namespace(in *Namespace, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NamespaceSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NamespaceStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_NamespaceList(in *NamespaceList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Namespace(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_NamespaceSpec(in *NamespaceSpec, out map[string]interface{}) error {
	if in.Finalizers != nil {
		result := make([]interface{}, len(in.Finalizers))
		{
			in, out := &in.Finalizers, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["finalizers"] = result
	}
	return nil
}

func ConvertToUnstructured_NamespaceStatus(in *NamespaceStatus, out map[string]interface{}) error {
	out["phase"] = in.Phase
	return nil
}

func ConvertToUnstructured_Node(in *Node, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NodeSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NodeStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeAddress(in *NodeAddress, out map[string]interface{}) error {
	out["type"] = in.Type
	out["address"] = in.Address
	return nil
}

func ConvertToUnstructured_NodeAffinity(in *NodeAffinity, out map[string]interface{}) error {
	if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
		result := make(map[string]interface{})
		{
			in, out := in.RequiredDuringSchedulingIgnoredDuringExecution, result
			if in.NodeSelectorTerms != nil {
				result := make([]interface{}, len(in.NodeSelectorTerms))
				{
					in, out := &in.NodeSelectorTerms, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_NodeSelectorTerm(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["nodeSelectorTerms"] = result
			}
		}
		out["requiredDuringSchedulingIgnoredDuringExecution"] = &result
	}
	if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
		result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
		{
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PreferredSchedulingTerm(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["preferredDuringSchedulingIgnoredDuringExecution"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeCondition(in *NodeCondition, out map[string]interface{}) error {
	out["type"] = in.Type
	out["status"] = in.Status
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.LastHeartbeatTime, result); err != nil {
			return err
		}
		out["lastHeartbeatTime"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.LastTransitionTime, result); err != nil {
			return err
		}
		out["lastTransitionTime"] = result
	}
	out["reason"] = in.Reason
	out["message"] = in.Message
	return nil
}

func ConvertToUnstructured_NodeDaemonEndpoints(in *NodeDaemonEndpoints, out map[string]interface{}) error {
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_DaemonEndpoint(&in.KubeletEndpoint, result); err != nil {
			return err
		}
		out["kubeletEndpoint"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeList(in *NodeList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Node(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeProxyOptions(in *NodeProxyOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["path"] = in.Path
	return nil
}

func ConvertToUnstructured_NodeResources(in *NodeResources, out map[string]interface{}) error {
	if in.Capacity != nil {
		result := make([]interface{}, len(in.Capacity))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["capacity"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeSelector(in *NodeSelector, out map[string]interface{}) error {
	if in.NodeSelectorTerms != nil {
		result := make([]interface{}, len(in.NodeSelectorTerms))
		{
			in, out := &in.NodeSelectorTerms, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_NodeSelectorTerm(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["nodeSelectorTerms"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeSelectorRequirement(in *NodeSelectorRequirement, out map[string]interface{}) error {
	out["key"] = in.Key
	out["operator"] = in.Operator
	if in.Values != nil {
		result := make([]interface{}, len(in.Values))
		{
			in, out := &in.Values, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["values"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeSelectorTerm(in *NodeSelectorTerm, out map[string]interface{}) error {
	if in.MatchExpressions != nil {
		result := make([]interface{}, len(in.MatchExpressions))
		{
			in, out := &in.MatchExpressions, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_NodeSelectorRequirement(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["matchExpressions"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeSpec(in *NodeSpec, out map[string]interface{}) error {
	out["podCIDR"] = in.PodCIDR
	out["externalID"] = in.ExternalID
	out["providerID"] = in.ProviderID
	out["unschedulable"] = in.Unschedulable
	return nil
}

func ConvertToUnstructured_NodeStatus(in *NodeStatus, out map[string]interface{}) error {
	if in.Capacity != nil {
		result := make([]interface{}, len(in.Capacity))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["capacity"] = result
	}
	if in.Allocatable != nil {
		result := make([]interface{}, len(in.Allocatable))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["allocatable"] = result
	}
	out["phase"] = in.Phase
	if in.Conditions != nil {
		result := make([]interface{}, len(in.Conditions))
		{
			in, out := &in.Conditions, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_NodeCondition(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["conditions"] = result
	}
	if in.Addresses != nil {
		result := make([]interface{}, len(in.Addresses))
		{
			in, out := &in.Addresses, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_NodeAddress(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["addresses"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NodeDaemonEndpoints(&in.DaemonEndpoints, result); err != nil {
			return err
		}
		out["daemonEndpoints"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NodeSystemInfo(&in.NodeInfo, result); err != nil {
			return err
		}
		out["nodeInfo"] = result
	}
	if in.Images != nil {
		result := make([]interface{}, len(in.Images))
		{
			in, out := &in.Images, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ContainerImage(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["images"] = result
	}
	if in.VolumesInUse != nil {
		result := make([]interface{}, len(in.VolumesInUse))
		{
			in, out := &in.VolumesInUse, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["volumesInUse"] = result
	}
	if in.VolumesAttached != nil {
		result := make([]interface{}, len(in.VolumesAttached))
		{
			in, out := &in.VolumesAttached, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_AttachedVolume(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["volumesAttached"] = result
	}
	return nil
}

func ConvertToUnstructured_NodeSystemInfo(in *NodeSystemInfo, out map[string]interface{}) error {
	out["machineID"] = in.MachineID
	out["systemUUID"] = in.SystemUUID
	out["bootID"] = in.BootID
	out["kernelVersion"] = in.KernelVersion
	out["osImage"] = in.OSImage
	out["containerRuntimeVersion"] = in.ContainerRuntimeVersion
	out["kubeletVersion"] = in.KubeletVersion
	out["kubeProxyVersion"] = in.KubeProxyVersion
	out["operatingSystem"] = in.OperatingSystem
	out["architecture"] = in.Architecture
	return nil
}

func ConvertToUnstructured_ObjectFieldSelector(in *ObjectFieldSelector, out map[string]interface{}) error {
	out["apiVersion"] = in.APIVersion
	out["fieldPath"] = in.FieldPath
	return nil
}

func ConvertToUnstructured_ObjectMeta(in *ObjectMeta, out map[string]interface{}) error {
	out["name"] = in.Name
	out["generateName"] = in.GenerateName
	out["namespace"] = in.Namespace
	out["selfLink"] = in.SelfLink
	out["uid"] = in.UID
	out["resourceVersion"] = in.ResourceVersion
	out["generation"] = in.Generation
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.CreationTimestamp, result); err != nil {
			return err
		}
		out["creationTimestamp"] = result
	}
	if in.DeletionTimestamp != nil {
		result := make(map[string]interface{})
		{
			in, out := in.DeletionTimestamp, result
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Time(&in.Time, result); err != nil {
					return err
				}
				out["time"] = result
			}
		}
		out["deletionTimestamp"] = &result
	}
	if in.DeletionGracePeriodSeconds != nil {
		var result int64
		{
			in, out := in.DeletionGracePeriodSeconds, result
			out = *in
		}
		out["deletionGracePeriodSeconds"] = &result
	}
	if in.Labels != nil {
		out["labels"] = in.Labels
	}
	if in.Annotations != nil {
		out["annotations"] = in.Annotations
	}
	if in.OwnerReferences != nil {
		result := make([]interface{}, len(in.OwnerReferences))
		{
			in, out := &in.OwnerReferences, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_OwnerReference(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["ownerReferences"] = result
	}
	if in.Finalizers != nil {
		result := make([]interface{}, len(in.Finalizers))
		{
			in, out := &in.Finalizers, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["finalizers"] = result
	}
	out["clusterName"] = in.ClusterName
	return nil
}

func ConvertToUnstructured_ObjectReference(in *ObjectReference, out map[string]interface{}) error {
	out["kind"] = in.Kind
	out["namespace"] = in.Namespace
	out["name"] = in.Name
	out["uid"] = in.UID
	out["apiVersion"] = in.APIVersion
	out["resourceVersion"] = in.ResourceVersion
	out["fieldPath"] = in.FieldPath
	return nil
}

func ConvertToUnstructured_PersistentVolume(in *PersistentVolume, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PersistentVolumeSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PersistentVolumeStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_PersistentVolumeClaim(in *PersistentVolumeClaim, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PersistentVolumeClaimSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PersistentVolumeClaimStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_PersistentVolumeClaimList(in *PersistentVolumeClaimList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PersistentVolumeClaim(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_PersistentVolumeClaimSpec(in *PersistentVolumeClaimSpec, out map[string]interface{}) error {
	if in.AccessModes != nil {
		result := make([]interface{}, len(in.AccessModes))
		{
			in, out := &in.AccessModes, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["accessModes"] = result
	}
	if in.Selector != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Selector, result
			if in.MatchLabels != nil {
				out["matchLabels"] = in.MatchLabels
			}
			if in.MatchExpressions != nil {
				result := make([]interface{}, len(in.MatchExpressions))
				{
					in, out := &in.MatchExpressions, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_LabelSelectorRequirement(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["matchExpressions"] = result
			}
		}
		out["selector"] = &result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ResourceRequirements(&in.Resources, result); err != nil {
			return err
		}
		out["resources"] = result
	}
	out["volumeName"] = in.VolumeName
	return nil
}

func ConvertToUnstructured_PersistentVolumeClaimStatus(in *PersistentVolumeClaimStatus, out map[string]interface{}) error {
	out["phase"] = in.Phase
	if in.AccessModes != nil {
		result := make([]interface{}, len(in.AccessModes))
		{
			in, out := &in.AccessModes, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["accessModes"] = result
	}
	if in.Capacity != nil {
		result := make([]interface{}, len(in.Capacity))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["capacity"] = result
	}
	return nil
}

func ConvertToUnstructured_PersistentVolumeClaimVolumeSource(in *PersistentVolumeClaimVolumeSource, out map[string]interface{}) error {
	out["claimName"] = in.ClaimName
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_PersistentVolumeList(in *PersistentVolumeList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PersistentVolume(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_PersistentVolumeSource(in *PersistentVolumeSource, out map[string]interface{}) error {
	if in.GCEPersistentDisk != nil {
		result := make(map[string]interface{})
		{
			in, out := in.GCEPersistentDisk, result
			out["pdName"] = in.PDName
			out["fsType"] = in.FSType
			out["partition"] = in.Partition
			out["readOnly"] = in.ReadOnly
		}
		out["gcePersistentDisk"] = &result
	}
	if in.AWSElasticBlockStore != nil {
		result := make(map[string]interface{})
		{
			in, out := in.AWSElasticBlockStore, result
			out["volumeID"] = in.VolumeID
			out["fsType"] = in.FSType
			out["partition"] = in.Partition
			out["readOnly"] = in.ReadOnly
		}
		out["awsElasticBlockStore"] = &result
	}
	if in.HostPath != nil {
		result := make(map[string]interface{})
		{
			in, out := in.HostPath, result
			out["path"] = in.Path
		}
		out["hostPath"] = &result
	}
	if in.Glusterfs != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Glusterfs, result
			out["endpoints"] = in.EndpointsName
			out["path"] = in.Path
			out["readOnly"] = in.ReadOnly
		}
		out["glusterfs"] = &result
	}
	if in.NFS != nil {
		result := make(map[string]interface{})
		{
			in, out := in.NFS, result
			out["server"] = in.Server
			out["path"] = in.Path
			out["readOnly"] = in.ReadOnly
		}
		out["nfs"] = &result
	}
	if in.RBD != nil {
		result := make(map[string]interface{})
		{
			in, out := in.RBD, result
			if in.CephMonitors != nil {
				result := make([]interface{}, len(in.CephMonitors))
				{
					in, out := &in.CephMonitors, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["monitors"] = result
			}
			out["image"] = in.RBDImage
			out["fsType"] = in.FSType
			out["pool"] = in.RBDPool
			out["user"] = in.RadosUser
			out["keyring"] = in.Keyring
			if in.SecretRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretRef, result
					out["name"] = in.Name
				}
				out["secretRef"] = &result
			}
			out["readOnly"] = in.ReadOnly
		}
		out["rbd"] = &result
	}
	if in.ISCSI != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ISCSI, result
			out["targetPortal"] = in.TargetPortal
			out["iqn"] = in.IQN
			out["lun"] = in.Lun
			out["iscsiInterface"] = in.ISCSIInterface
			out["fsType"] = in.FSType
			out["readOnly"] = in.ReadOnly
		}
		out["iscsi"] = &result
	}
	if in.Cinder != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Cinder, result
			out["volumeID"] = in.VolumeID
			out["fsType"] = in.FSType
			out["readOnly"] = in.ReadOnly
		}
		out["cinder"] = &result
	}
	if in.CephFS != nil {
		result := make(map[string]interface{})
		{
			in, out := in.CephFS, result
			if in.Monitors != nil {
				result := make([]interface{}, len(in.Monitors))
				{
					in, out := &in.Monitors, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["monitors"] = result
			}
			out["path"] = in.Path
			out["user"] = in.User
			out["secretFile"] = in.SecretFile
			if in.SecretRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretRef, result
					out["name"] = in.Name
				}
				out["secretRef"] = &result
			}
			out["readOnly"] = in.ReadOnly
		}
		out["cephfs"] = &result
	}
	if in.FC != nil {
		result := make(map[string]interface{})
		{
			in, out := in.FC, result
			if in.TargetWWNs != nil {
				result := make([]interface{}, len(in.TargetWWNs))
				{
					in, out := &in.TargetWWNs, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["targetWWNs"] = result
			}
			if in.Lun != nil {
				var result int32
				{
					in, out := in.Lun, result
					out = *in
				}
				out["lun"] = &result
			}
			out["fsType"] = in.FSType
			out["readOnly"] = in.ReadOnly
		}
		out["fc"] = &result
	}
	if in.Flocker != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Flocker, result
			out["datasetName"] = in.DatasetName
			out["datasetUUID"] = in.DatasetUUID
		}
		out["flocker"] = &result
	}
	if in.FlexVolume != nil {
		result := make(map[string]interface{})
		{
			in, out := in.FlexVolume, result
			out["driver"] = in.Driver
			out["fsType"] = in.FSType
			if in.SecretRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretRef, result
					out["name"] = in.Name
				}
				out["secretRef"] = &result
			}
			out["readOnly"] = in.ReadOnly
			if in.Options != nil {
				out["options"] = in.Options
			}
		}
		out["flexVolume"] = &result
	}
	if in.AzureFile != nil {
		result := make(map[string]interface{})
		{
			in, out := in.AzureFile, result
			out["secretName"] = in.SecretName
			out["shareName"] = in.ShareName
			out["readOnly"] = in.ReadOnly
		}
		out["azureFile"] = &result
	}
	if in.VsphereVolume != nil {
		result := make(map[string]interface{})
		{
			in, out := in.VsphereVolume, result
			out["volumePath"] = in.VolumePath
			out["fsType"] = in.FSType
		}
		out["vsphereVolume"] = &result
	}
	if in.Quobyte != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Quobyte, result
			out["registry"] = in.Registry
			out["volume"] = in.Volume
			out["readOnly"] = in.ReadOnly
			out["user"] = in.User
			out["group"] = in.Group
		}
		out["quobyte"] = &result
	}
	if in.AzureDisk != nil {
		result := make(map[string]interface{})
		{
			in, out := in.AzureDisk, result
			out["diskName"] = in.DiskName
			out["diskURI"] = in.DataDiskURI
			if in.CachingMode != nil {
				var result AzureDataDiskCachingMode
				{
					in, out := in.CachingMode, result
					out = *in
				}
				out["cachingMode"] = &result
			}
			if in.FSType != nil {
				var result string
				{
					in, out := in.FSType, result
					out = *in
				}
				out["fsType"] = &result
			}
			if in.ReadOnly != nil {
				var result bool
				{
					in, out := in.ReadOnly, result
					out = *in
				}
				out["readOnly"] = &result
			}
		}
		out["azureDisk"] = &result
	}
	if in.PhotonPersistentDisk != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PhotonPersistentDisk, result
			out["pdID"] = in.PdID
			out["fsType"] = in.FSType
		}
		out["photonPersistentDisk"] = &result
	}
	return nil
}

func ConvertToUnstructured_PersistentVolumeSpec(in *PersistentVolumeSpec, out map[string]interface{}) error {
	if in.Capacity != nil {
		result := make([]interface{}, len(in.Capacity))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["capacity"] = result
	}
	if err := ConvertToUnstructured_PersistentVolumeSource(&in.PersistentVolumeSource, out); err != nil {
		return err
	}
	if in.AccessModes != nil {
		result := make([]interface{}, len(in.AccessModes))
		{
			in, out := &in.AccessModes, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["accessModes"] = result
	}
	if in.ClaimRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ClaimRef, result
			out["kind"] = in.Kind
			out["namespace"] = in.Namespace
			out["name"] = in.Name
			out["uid"] = in.UID
			out["apiVersion"] = in.APIVersion
			out["resourceVersion"] = in.ResourceVersion
			out["fieldPath"] = in.FieldPath
		}
		out["claimRef"] = &result
	}
	out["persistentVolumeReclaimPolicy"] = in.PersistentVolumeReclaimPolicy
	return nil
}

func ConvertToUnstructured_PersistentVolumeStatus(in *PersistentVolumeStatus, out map[string]interface{}) error {
	out["phase"] = in.Phase
	out["message"] = in.Message
	out["reason"] = in.Reason
	return nil
}

func ConvertToUnstructured_PhotonPersistentDiskVolumeSource(in *PhotonPersistentDiskVolumeSource, out map[string]interface{}) error {
	out["pdID"] = in.PdID
	out["fsType"] = in.FSType
	return nil
}

func ConvertToUnstructured_Pod(in *Pod, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_PodAffinity(in *PodAffinity, out map[string]interface{}) error {
	if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
		result := make([]interface{}, len(in.RequiredDuringSchedulingIgnoredDuringExecution))
		{
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PodAffinityTerm(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["requiredDuringSchedulingIgnoredDuringExecution"] = result
	}
	if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
		result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
		{
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_WeightedPodAffinityTerm(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["preferredDuringSchedulingIgnoredDuringExecution"] = result
	}
	return nil
}

func ConvertToUnstructured_PodAffinityTerm(in *PodAffinityTerm, out map[string]interface{}) error {
	if in.LabelSelector != nil {
		result := make(map[string]interface{})
		{
			in, out := in.LabelSelector, result
			if in.MatchLabels != nil {
				out["matchLabels"] = in.MatchLabels
			}
			if in.MatchExpressions != nil {
				result := make([]interface{}, len(in.MatchExpressions))
				{
					in, out := &in.MatchExpressions, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_LabelSelectorRequirement(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["matchExpressions"] = result
			}
		}
		out["labelSelector"] = &result
	}
	if in.Namespaces != nil {
		result := make([]interface{}, len(in.Namespaces))
		{
			in, out := &in.Namespaces, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["namespaces"] = result
	}
	out["topologyKey"] = in.TopologyKey
	return nil
}

func ConvertToUnstructured_PodAntiAffinity(in *PodAntiAffinity, out map[string]interface{}) error {
	if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
		result := make([]interface{}, len(in.RequiredDuringSchedulingIgnoredDuringExecution))
		{
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PodAffinityTerm(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["requiredDuringSchedulingIgnoredDuringExecution"] = result
	}
	if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
		result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
		{
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_WeightedPodAffinityTerm(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["preferredDuringSchedulingIgnoredDuringExecution"] = result
	}
	return nil
}

func ConvertToUnstructured_PodAttachOptions(in *PodAttachOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["stdin"] = in.Stdin
	out["stdout"] = in.Stdout
	out["stderr"] = in.Stderr
	out["tty"] = in.TTY
	out["container"] = in.Container
	return nil
}

func ConvertToUnstructured_PodCondition(in *PodCondition, out map[string]interface{}) error {
	out["type"] = in.Type
	out["status"] = in.Status
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.LastProbeTime, result); err != nil {
			return err
		}
		out["lastProbeTime"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.LastTransitionTime, result); err != nil {
			return err
		}
		out["lastTransitionTime"] = result
	}
	out["reason"] = in.Reason
	out["message"] = in.Message
	return nil
}

func ConvertToUnstructured_PodExecOptions(in *PodExecOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["stdin"] = in.Stdin
	out["stdout"] = in.Stdout
	out["stderr"] = in.Stderr
	out["tty"] = in.TTY
	out["container"] = in.Container
	if in.Command != nil {
		result := make([]interface{}, len(in.Command))
		{
			in, out := &in.Command, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["command"] = result
	}
	return nil
}

func ConvertToUnstructured_PodList(in *PodList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Pod(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_PodLogOptions(in *PodLogOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["container"] = in.Container
	out["follow"] = in.Follow
	out["previous"] = in.Previous
	if in.SinceSeconds != nil {
		var result int64
		{
			in, out := in.SinceSeconds, result
			out = *in
		}
		out["sinceSeconds"] = &result
	}
	if in.SinceTime != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SinceTime, result
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Time(&in.Time, result); err != nil {
					return err
				}
				out["time"] = result
			}
		}
		out["sinceTime"] = &result
	}
	out["timestamps"] = in.Timestamps
	if in.TailLines != nil {
		var result int64
		{
			in, out := in.TailLines, result
			out = *in
		}
		out["tailLines"] = &result
	}
	if in.LimitBytes != nil {
		var result int64
		{
			in, out := in.LimitBytes, result
			out = *in
		}
		out["limitBytes"] = &result
	}
	return nil
}

func ConvertToUnstructured_PodProxyOptions(in *PodProxyOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["path"] = in.Path
	return nil
}

func ConvertToUnstructured_PodSecurityContext(in *PodSecurityContext, out map[string]interface{}) error {
	if in.SELinuxOptions != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SELinuxOptions, result
			out["user"] = in.User
			out["role"] = in.Role
			out["type"] = in.Type
			out["level"] = in.Level
		}
		out["seLinuxOptions"] = &result
	}
	if in.RunAsUser != nil {
		var result int64
		{
			in, out := in.RunAsUser, result
			out = *in
		}
		out["runAsUser"] = &result
	}
	if in.RunAsNonRoot != nil {
		var result bool
		{
			in, out := in.RunAsNonRoot, result
			out = *in
		}
		out["runAsNonRoot"] = &result
	}
	if in.SupplementalGroups != nil {
		result := make([]interface{}, len(in.SupplementalGroups))
		{
			in, out := &in.SupplementalGroups, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["supplementalGroups"] = result
	}
	if in.FSGroup != nil {
		var result int64
		{
			in, out := in.FSGroup, result
			out = *in
		}
		out["fsGroup"] = &result
	}
	return nil
}

func ConvertToUnstructured_PodSignature(in *PodSignature, out map[string]interface{}) error {
	if in.PodController != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PodController, result
			out["apiVersion"] = in.APIVersion
			out["kind"] = in.Kind
			out["name"] = in.Name
			out["uid"] = in.UID
			if in.Controller != nil {
				var result bool
				{
					in, out := in.Controller, result
					out = *in
				}
				out["controller"] = &result
			}
		}
		out["podController"] = &result
	}
	return nil
}

func ConvertToUnstructured_PodSpec(in *PodSpec, out map[string]interface{}) error {
	if in.Volumes != nil {
		result := make([]interface{}, len(in.Volumes))
		{
			in, out := &in.Volumes, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Volume(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["volumes"] = result
	}
	if in.InitContainers != nil {
		result := make([]interface{}, len(in.InitContainers))
		{
			in, out := &in.InitContainers, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Container(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["-"] = result
	}
	if in.Containers != nil {
		result := make([]interface{}, len(in.Containers))
		{
			in, out := &in.Containers, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Container(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["containers"] = result
	}
	out["restartPolicy"] = in.RestartPolicy
	if in.TerminationGracePeriodSeconds != nil {
		var result int64
		{
			in, out := in.TerminationGracePeriodSeconds, result
			out = *in
		}
		out["terminationGracePeriodSeconds"] = &result
	}
	if in.ActiveDeadlineSeconds != nil {
		var result int64
		{
			in, out := in.ActiveDeadlineSeconds, result
			out = *in
		}
		out["activeDeadlineSeconds"] = &result
	}
	out["dnsPolicy"] = in.DNSPolicy
	if in.NodeSelector != nil {
		out["nodeSelector"] = in.NodeSelector
	}
	out["serviceAccountName"] = in.ServiceAccountName
	out["serviceAccount"] = in.DeprecatedServiceAccount
	out["nodeName"] = in.NodeName
	out["hostNetwork"] = in.HostNetwork
	out["hostPID"] = in.HostPID
	out["hostIPC"] = in.HostIPC
	if in.SecurityContext != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SecurityContext, result
			if in.SELinuxOptions != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SELinuxOptions, result
					out["user"] = in.User
					out["role"] = in.Role
					out["type"] = in.Type
					out["level"] = in.Level
				}
				out["seLinuxOptions"] = &result
			}
			if in.RunAsUser != nil {
				var result int64
				{
					in, out := in.RunAsUser, result
					out = *in
				}
				out["runAsUser"] = &result
			}
			if in.RunAsNonRoot != nil {
				var result bool
				{
					in, out := in.RunAsNonRoot, result
					out = *in
				}
				out["runAsNonRoot"] = &result
			}
			if in.SupplementalGroups != nil {
				result := make([]interface{}, len(in.SupplementalGroups))
				{
					in, out := &in.SupplementalGroups, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["supplementalGroups"] = result
			}
			if in.FSGroup != nil {
				var result int64
				{
					in, out := in.FSGroup, result
					out = *in
				}
				out["fsGroup"] = &result
			}
		}
		out["securityContext"] = &result
	}
	if in.ImagePullSecrets != nil {
		result := make([]interface{}, len(in.ImagePullSecrets))
		{
			in, out := &in.ImagePullSecrets, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_LocalObjectReference(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["imagePullSecrets"] = result
	}
	out["hostname"] = in.Hostname
	out["subdomain"] = in.Subdomain
	if in.Affinity != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Affinity, result
			if in.NodeAffinity != nil {
				result := make(map[string]interface{})
				{
					in, out := in.NodeAffinity, result
					if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
						result := make(map[string]interface{})
						{
							in, out := in.RequiredDuringSchedulingIgnoredDuringExecution, result
							if in.NodeSelectorTerms != nil {
								result := make([]interface{}, len(in.NodeSelectorTerms))
								{
									in, out := &in.NodeSelectorTerms, result
									for i := range *in {
										result := make(map[string]interface{})
										if err := ConvertToUnstructured_NodeSelectorTerm(&(*in)[i], result); err != nil {
											return err
										}
										out = append(out, result)
									}
								}
								out["nodeSelectorTerms"] = result
							}
						}
						out["requiredDuringSchedulingIgnoredDuringExecution"] = &result
					}
					if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
						result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
						{
							in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_PreferredSchedulingTerm(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["preferredDuringSchedulingIgnoredDuringExecution"] = result
					}
				}
				out["nodeAffinity"] = &result
			}
			if in.PodAffinity != nil {
				result := make(map[string]interface{})
				{
					in, out := in.PodAffinity, result
					if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
						result := make([]interface{}, len(in.RequiredDuringSchedulingIgnoredDuringExecution))
						{
							in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_PodAffinityTerm(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["requiredDuringSchedulingIgnoredDuringExecution"] = result
					}
					if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
						result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
						{
							in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_WeightedPodAffinityTerm(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["preferredDuringSchedulingIgnoredDuringExecution"] = result
					}
				}
				out["podAffinity"] = &result
			}
			if in.PodAntiAffinity != nil {
				result := make(map[string]interface{})
				{
					in, out := in.PodAntiAffinity, result
					if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
						result := make([]interface{}, len(in.RequiredDuringSchedulingIgnoredDuringExecution))
						{
							in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_PodAffinityTerm(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["requiredDuringSchedulingIgnoredDuringExecution"] = result
					}
					if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
						result := make([]interface{}, len(in.PreferredDuringSchedulingIgnoredDuringExecution))
						{
							in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, result
							for i := range *in {
								result := make(map[string]interface{})
								if err := ConvertToUnstructured_WeightedPodAffinityTerm(&(*in)[i], result); err != nil {
									return err
								}
								out = append(out, result)
							}
						}
						out["preferredDuringSchedulingIgnoredDuringExecution"] = result
					}
				}
				out["podAntiAffinity"] = &result
			}
		}
		out["affinity"] = &result
	}
	return nil
}

func ConvertToUnstructured_PodStatus(in *PodStatus, out map[string]interface{}) error {
	out["phase"] = in.Phase
	if in.Conditions != nil {
		result := make([]interface{}, len(in.Conditions))
		{
			in, out := &in.Conditions, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PodCondition(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["conditions"] = result
	}
	out["message"] = in.Message
	out["reason"] = in.Reason
	out["hostIP"] = in.HostIP
	out["podIP"] = in.PodIP
	if in.StartTime != nil {
		result := make(map[string]interface{})
		{
			in, out := in.StartTime, result
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Time(&in.Time, result); err != nil {
					return err
				}
				out["time"] = result
			}
		}
		out["startTime"] = &result
	}
	if in.InitContainerStatuses != nil {
		result := make([]interface{}, len(in.InitContainerStatuses))
		{
			in, out := &in.InitContainerStatuses, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ContainerStatus(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["-"] = result
	}
	if in.ContainerStatuses != nil {
		result := make([]interface{}, len(in.ContainerStatuses))
		{
			in, out := &in.ContainerStatuses, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ContainerStatus(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["containerStatuses"] = result
	}
	out["qosClass"] = in.QOSClass
	return nil
}

func ConvertToUnstructured_PodStatusResult(in *PodStatusResult, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_PodTemplate(in *PodTemplate, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodTemplateSpec(&in.Template, result); err != nil {
			return err
		}
		out["template"] = result
	}
	return nil
}

func ConvertToUnstructured_PodTemplateList(in *PodTemplateList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PodTemplate(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_PodTemplateSpec(in *PodTemplateSpec, out map[string]interface{}) error {
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	return nil
}

func ConvertToUnstructured_Preconditions(in *Preconditions, out map[string]interface{}) error {
	if in.UID != nil {
		var result types.UID
		{
			in, out := in.UID, result
			out = *in
		}
		out["uid"] = &result
	}
	return nil
}

func ConvertToUnstructured_PreferAvoidPodsEntry(in *PreferAvoidPodsEntry, out map[string]interface{}) error {
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodSignature(&in.PodSignature, result); err != nil {
			return err
		}
		out["podSignature"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.EvictionTime, result); err != nil {
			return err
		}
		out["evictionTime"] = result
	}
	out["reason"] = in.Reason
	out["message"] = in.Message
	return nil
}

func ConvertToUnstructured_PreferredSchedulingTerm(in *PreferredSchedulingTerm, out map[string]interface{}) error {
	out["weight"] = in.Weight
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_NodeSelectorTerm(&in.Preference, result); err != nil {
			return err
		}
		out["preference"] = result
	}
	return nil
}

func ConvertToUnstructured_Probe(in *Probe, out map[string]interface{}) error {
	if err := ConvertToUnstructured_Handler(&in.Handler, out); err != nil {
		return err
	}
	out["initialDelaySeconds"] = in.InitialDelaySeconds
	out["timeoutSeconds"] = in.TimeoutSeconds
	out["periodSeconds"] = in.PeriodSeconds
	out["successThreshold"] = in.SuccessThreshold
	out["failureThreshold"] = in.FailureThreshold
	return nil
}

func ConvertToUnstructured_QuobyteVolumeSource(in *QuobyteVolumeSource, out map[string]interface{}) error {
	out["registry"] = in.Registry
	out["volume"] = in.Volume
	out["readOnly"] = in.ReadOnly
	out["user"] = in.User
	out["group"] = in.Group
	return nil
}

func ConvertToUnstructured_RBDVolumeSource(in *RBDVolumeSource, out map[string]interface{}) error {
	if in.CephMonitors != nil {
		result := make([]interface{}, len(in.CephMonitors))
		{
			in, out := &in.CephMonitors, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["monitors"] = result
	}
	out["image"] = in.RBDImage
	out["fsType"] = in.FSType
	out["pool"] = in.RBDPool
	out["user"] = in.RadosUser
	out["keyring"] = in.Keyring
	if in.SecretRef != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SecretRef, result
			out["name"] = in.Name
		}
		out["secretRef"] = &result
	}
	out["readOnly"] = in.ReadOnly
	return nil
}

func ConvertToUnstructured_RangeAllocation(in *RangeAllocation, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	out["range"] = in.Range
	if in.Data != nil {
		result := make([]interface{}, len(in.Data))
		{
			in, out := &in.Data, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["data"] = result
	}
	return nil
}

func ConvertToUnstructured_ReplicationController(in *ReplicationController, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ReplicationControllerSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ReplicationControllerStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_ReplicationControllerCondition(in *ReplicationControllerCondition, out map[string]interface{}) error {
	out["type"] = in.Type
	out["status"] = in.Status
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Time(&in.LastTransitionTime, result); err != nil {
			return err
		}
		out["lastTransitionTime"] = result
	}
	out["reason"] = in.Reason
	out["message"] = in.Message
	return nil
}

func ConvertToUnstructured_ReplicationControllerList(in *ReplicationControllerList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ReplicationController(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ReplicationControllerSpec(in *ReplicationControllerSpec, out map[string]interface{}) error {
	if in.Replicas != nil {
		var result int32
		{
			in, out := in.Replicas, result
			out = *in
		}
		out["replicas"] = &result
	}
	out["minReadySeconds"] = in.MinReadySeconds
	if in.Selector != nil {
		out["selector"] = in.Selector
	}
	if in.Template != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Template, result
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
					return err
				}
				out["metadata"] = result
			}
			{
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_PodSpec(&in.Spec, result); err != nil {
					return err
				}
				out["spec"] = result
			}
		}
		out["template"] = &result
	}
	return nil
}

func ConvertToUnstructured_ReplicationControllerStatus(in *ReplicationControllerStatus, out map[string]interface{}) error {
	out["replicas"] = in.Replicas
	out["fullyLabeledReplicas"] = in.FullyLabeledReplicas
	out["readyReplicas"] = in.ReadyReplicas
	out["availableReplicas"] = in.AvailableReplicas
	out["observedGeneration"] = in.ObservedGeneration
	if in.Conditions != nil {
		result := make([]interface{}, len(in.Conditions))
		{
			in, out := &in.Conditions, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ReplicationControllerCondition(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["conditions"] = result
	}
	return nil
}

func ConvertToUnstructured_ResourceFieldSelector(in *ResourceFieldSelector, out map[string]interface{}) error {
	out["containerName"] = in.ContainerName
	out["resource"] = in.Resource
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_Quantity(&in.Divisor, result); err != nil {
			return err
		}
		out["divisor"] = result
	}
	return nil
}

func ConvertToUnstructured_ResourceQuota(in *ResourceQuota, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ResourceQuotaSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ResourceQuotaStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_ResourceQuotaList(in *ResourceQuotaList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ResourceQuota(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ResourceQuotaSpec(in *ResourceQuotaSpec, out map[string]interface{}) error {
	if in.Hard != nil {
		result := make([]interface{}, len(in.Hard))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["hard"] = result
	}
	if in.Scopes != nil {
		result := make([]interface{}, len(in.Scopes))
		{
			in, out := &in.Scopes, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["scopes"] = result
	}
	return nil
}

func ConvertToUnstructured_ResourceQuotaStatus(in *ResourceQuotaStatus, out map[string]interface{}) error {
	if in.Hard != nil {
		result := make([]interface{}, len(in.Hard))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["hard"] = result
	}
	if in.Used != nil {
		result := make([]interface{}, len(in.Used))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["used"] = result
	}
	return nil
}

func ConvertToUnstructured_ResourceRequirements(in *ResourceRequirements, out map[string]interface{}) error {
	if in.Limits != nil {
		result := make([]interface{}, len(in.Limits))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["limits"] = result
	}
	if in.Requests != nil {
		result := make([]interface{}, len(in.Requests))
		{
			for key := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Quantity(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["requests"] = result
	}
	return nil
}

func ConvertToUnstructured_SELinuxOptions(in *SELinuxOptions, out map[string]interface{}) error {
	out["user"] = in.User
	out["role"] = in.Role
	out["type"] = in.Type
	out["level"] = in.Level
	return nil
}

func ConvertToUnstructured_Secret(in *Secret, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Data != nil {
		result := make([]interface{}, len(in.Data))
		{
			for key := range *in {
				result := make([]interface{}, 0)
				if err := ConvertToUnstructured_SliceByte(&(*in)[key], result); err != nil {
					return err
				}
			}
		}
		out["data"] = result
	}
	if in.StringData != nil {
		out["stringData"] = in.StringData
	}
	out["type"] = in.Type
	return nil
}

func ConvertToUnstructured_SecretKeySelector(in *SecretKeySelector, out map[string]interface{}) error {
	if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
		return err
	}
	out["key"] = in.Key
	return nil
}

func ConvertToUnstructured_SecretList(in *SecretList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Secret(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_SecretVolumeSource(in *SecretVolumeSource, out map[string]interface{}) error {
	out["secretName"] = in.SecretName
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_KeyToPath(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	if in.DefaultMode != nil {
		var result int32
		{
			in, out := in.DefaultMode, result
			out = *in
		}
		out["defaultMode"] = &result
	}
	return nil
}

func ConvertToUnstructured_SecurityContext(in *SecurityContext, out map[string]interface{}) error {
	if in.Capabilities != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Capabilities, result
			if in.Add != nil {
				result := make([]interface{}, len(in.Add))
				{
					in, out := &in.Add, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["add"] = result
			}
			if in.Drop != nil {
				result := make([]interface{}, len(in.Drop))
				{
					in, out := &in.Drop, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["drop"] = result
			}
		}
		out["capabilities"] = &result
	}
	if in.Privileged != nil {
		var result bool
		{
			in, out := in.Privileged, result
			out = *in
		}
		out["privileged"] = &result
	}
	if in.SELinuxOptions != nil {
		result := make(map[string]interface{})
		{
			in, out := in.SELinuxOptions, result
			out["user"] = in.User
			out["role"] = in.Role
			out["type"] = in.Type
			out["level"] = in.Level
		}
		out["seLinuxOptions"] = &result
	}
	if in.RunAsUser != nil {
		var result int64
		{
			in, out := in.RunAsUser, result
			out = *in
		}
		out["runAsUser"] = &result
	}
	if in.RunAsNonRoot != nil {
		var result bool
		{
			in, out := in.RunAsNonRoot, result
			out = *in
		}
		out["runAsNonRoot"] = &result
	}
	if in.ReadOnlyRootFilesystem != nil {
		var result bool
		{
			in, out := in.ReadOnlyRootFilesystem, result
			out = *in
		}
		out["readOnlyRootFilesystem"] = &result
	}
	return nil
}

func ConvertToUnstructured_SerializedReference(in *SerializedReference, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectReference(&in.Reference, result); err != nil {
			return err
		}
		out["reference"] = result
	}
	return nil
}

func ConvertToUnstructured_Service(in *Service, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ServiceSpec(&in.Spec, result); err != nil {
			return err
		}
		out["spec"] = result
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ServiceStatus(&in.Status, result); err != nil {
			return err
		}
		out["status"] = result
	}
	return nil
}

func ConvertToUnstructured_ServiceAccount(in *ServiceAccount, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ObjectMeta(&in.ObjectMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Secrets != nil {
		result := make([]interface{}, len(in.Secrets))
		{
			in, out := &in.Secrets, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ObjectReference(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["secrets"] = result
	}
	if in.ImagePullSecrets != nil {
		result := make([]interface{}, len(in.ImagePullSecrets))
		{
			in, out := &in.ImagePullSecrets, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_LocalObjectReference(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["imagePullSecrets"] = result
	}
	return nil
}

func ConvertToUnstructured_ServiceAccountList(in *ServiceAccountList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ServiceAccount(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ServiceList(in *ServiceList, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_ListMeta(&in.ListMeta, result); err != nil {
			return err
		}
		out["metadata"] = result
	}
	if in.Items != nil {
		result := make([]interface{}, len(in.Items))
		{
			in, out := &in.Items, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_Service(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["items"] = result
	}
	return nil
}

func ConvertToUnstructured_ServicePort(in *ServicePort, out map[string]interface{}) error {
	out["name"] = in.Name
	out["protocol"] = in.Protocol
	out["port"] = in.Port
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_IntOrString(&in.TargetPort, result); err != nil {
			return err
		}
		out["targetPort"] = result
	}
	out["nodePort"] = in.NodePort
	return nil
}

func ConvertToUnstructured_ServiceProxyOptions(in *ServiceProxyOptions, out map[string]interface{}) error {
	if err := ConvertToUnstructured_TypeMeta(&in.TypeMeta, out); err != nil {
		return err
	}
	out["path"] = in.Path
	return nil
}

func ConvertToUnstructured_ServiceSpec(in *ServiceSpec, out map[string]interface{}) error {
	if in.Ports != nil {
		result := make([]interface{}, len(in.Ports))
		{
			in, out := &in.Ports, result
			for i := range *in {
				result := make(map[string]interface{})
				if err := ConvertToUnstructured_ServicePort(&(*in)[i], result); err != nil {
					return err
				}
				out = append(out, result)
			}
		}
		out["ports"] = result
	}
	if in.Selector != nil {
		out["selector"] = in.Selector
	}
	out["clusterIP"] = in.ClusterIP
	out["type"] = in.Type
	if in.ExternalIPs != nil {
		result := make([]interface{}, len(in.ExternalIPs))
		{
			in, out := &in.ExternalIPs, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["externalIPs"] = result
	}
	if in.DeprecatedPublicIPs != nil {
		result := make([]interface{}, len(in.DeprecatedPublicIPs))
		{
			in, out := &in.DeprecatedPublicIPs, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["deprecatedPublicIPs"] = result
	}
	out["sessionAffinity"] = in.SessionAffinity
	out["loadBalancerIP"] = in.LoadBalancerIP
	if in.LoadBalancerSourceRanges != nil {
		result := make([]interface{}, len(in.LoadBalancerSourceRanges))
		{
			in, out := &in.LoadBalancerSourceRanges, result
			for i := range *in {
				out = append(out, (*in)[i])
			}
		}
		out["loadBalancerSourceRanges"] = result
	}
	out["externalName"] = in.ExternalName
	return nil
}

func ConvertToUnstructured_ServiceStatus(in *ServiceStatus, out map[string]interface{}) error {
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_LoadBalancerStatus(&in.LoadBalancer, result); err != nil {
			return err
		}
		out["loadBalancer"] = result
	}
	return nil
}

func ConvertToUnstructured_SimpleNameGenerator(in *simpleNameGenerator, out map[string]interface{}) error {
	return nil
}

func ConvertToUnstructured_Sysctl(in *Sysctl, out map[string]interface{}) error {
	out["name"] = in.Name
	out["value"] = in.Value
	return nil
}

func ConvertToUnstructured_TCPSocketAction(in *TCPSocketAction, out map[string]interface{}) error {
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_IntOrString(&in.Port, result); err != nil {
			return err
		}
		out["port"] = result
	}
	return nil
}

func ConvertToUnstructured_Taint(in *Taint, out map[string]interface{}) error {
	out["key"] = in.Key
	out["value"] = in.Value
	out["effect"] = in.Effect
	return nil
}

func ConvertToUnstructured_Toleration(in *Toleration, out map[string]interface{}) error {
	out["key"] = in.Key
	out["operator"] = in.Operator
	out["value"] = in.Value
	out["effect"] = in.Effect
	return nil
}

func ConvertToUnstructured_Volume(in *Volume, out map[string]interface{}) error {
	out["name"] = in.Name
	if err := ConvertToUnstructured_VolumeSource(&in.VolumeSource, out); err != nil {
		return err
	}
	return nil
}

func ConvertToUnstructured_VolumeMount(in *VolumeMount, out map[string]interface{}) error {
	out["name"] = in.Name
	out["readOnly"] = in.ReadOnly
	out["mountPath"] = in.MountPath
	out["subPath"] = in.SubPath
	return nil
}

func ConvertToUnstructured_VolumeSource(in *VolumeSource, out map[string]interface{}) error {
	if in.HostPath != nil {
		result := make(map[string]interface{})
		{
			in, out := in.HostPath, result
			out["path"] = in.Path
		}
		out["hostPath"] = &result
	}
	if in.EmptyDir != nil {
		result := make(map[string]interface{})
		{
			in, out := in.EmptyDir, result
			out["medium"] = in.Medium
		}
		out["emptyDir"] = &result
	}
	if in.GCEPersistentDisk != nil {
		result := make(map[string]interface{})
		{
			in, out := in.GCEPersistentDisk, result
			out["pdName"] = in.PDName
			out["fsType"] = in.FSType
			out["partition"] = in.Partition
			out["readOnly"] = in.ReadOnly
		}
		out["gcePersistentDisk"] = &result
	}
	if in.AWSElasticBlockStore != nil {
		result := make(map[string]interface{})
		{
			in, out := in.AWSElasticBlockStore, result
			out["volumeID"] = in.VolumeID
			out["fsType"] = in.FSType
			out["partition"] = in.Partition
			out["readOnly"] = in.ReadOnly
		}
		out["awsElasticBlockStore"] = &result
	}
	if in.GitRepo != nil {
		result := make(map[string]interface{})
		{
			in, out := in.GitRepo, result
			out["repository"] = in.Repository
			out["revision"] = in.Revision
			out["directory"] = in.Directory
		}
		out["gitRepo"] = &result
	}
	if in.Secret != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Secret, result
			out["secretName"] = in.SecretName
			if in.Items != nil {
				result := make([]interface{}, len(in.Items))
				{
					in, out := &in.Items, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_KeyToPath(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["items"] = result
			}
			if in.DefaultMode != nil {
				var result int32
				{
					in, out := in.DefaultMode, result
					out = *in
				}
				out["defaultMode"] = &result
			}
		}
		out["secret"] = &result
	}
	if in.NFS != nil {
		result := make(map[string]interface{})
		{
			in, out := in.NFS, result
			out["server"] = in.Server
			out["path"] = in.Path
			out["readOnly"] = in.ReadOnly
		}
		out["nfs"] = &result
	}
	if in.ISCSI != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ISCSI, result
			out["targetPortal"] = in.TargetPortal
			out["iqn"] = in.IQN
			out["lun"] = in.Lun
			out["iscsiInterface"] = in.ISCSIInterface
			out["fsType"] = in.FSType
			out["readOnly"] = in.ReadOnly
		}
		out["iscsi"] = &result
	}
	if in.Glusterfs != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Glusterfs, result
			out["endpoints"] = in.EndpointsName
			out["path"] = in.Path
			out["readOnly"] = in.ReadOnly
		}
		out["glusterfs"] = &result
	}
	if in.PersistentVolumeClaim != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PersistentVolumeClaim, result
			out["claimName"] = in.ClaimName
			out["readOnly"] = in.ReadOnly
		}
		out["persistentVolumeClaim"] = &result
	}
	if in.RBD != nil {
		result := make(map[string]interface{})
		{
			in, out := in.RBD, result
			if in.CephMonitors != nil {
				result := make([]interface{}, len(in.CephMonitors))
				{
					in, out := &in.CephMonitors, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["monitors"] = result
			}
			out["image"] = in.RBDImage
			out["fsType"] = in.FSType
			out["pool"] = in.RBDPool
			out["user"] = in.RadosUser
			out["keyring"] = in.Keyring
			if in.SecretRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretRef, result
					out["name"] = in.Name
				}
				out["secretRef"] = &result
			}
			out["readOnly"] = in.ReadOnly
		}
		out["rbd"] = &result
	}
	if in.FlexVolume != nil {
		result := make(map[string]interface{})
		{
			in, out := in.FlexVolume, result
			out["driver"] = in.Driver
			out["fsType"] = in.FSType
			if in.SecretRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretRef, result
					out["name"] = in.Name
				}
				out["secretRef"] = &result
			}
			out["readOnly"] = in.ReadOnly
			if in.Options != nil {
				out["options"] = in.Options
			}
		}
		out["flexVolume"] = &result
	}
	if in.Cinder != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Cinder, result
			out["volumeID"] = in.VolumeID
			out["fsType"] = in.FSType
			out["readOnly"] = in.ReadOnly
		}
		out["cinder"] = &result
	}
	if in.CephFS != nil {
		result := make(map[string]interface{})
		{
			in, out := in.CephFS, result
			if in.Monitors != nil {
				result := make([]interface{}, len(in.Monitors))
				{
					in, out := &in.Monitors, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["monitors"] = result
			}
			out["path"] = in.Path
			out["user"] = in.User
			out["secretFile"] = in.SecretFile
			if in.SecretRef != nil {
				result := make(map[string]interface{})
				{
					in, out := in.SecretRef, result
					out["name"] = in.Name
				}
				out["secretRef"] = &result
			}
			out["readOnly"] = in.ReadOnly
		}
		out["cephfs"] = &result
	}
	if in.Flocker != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Flocker, result
			out["datasetName"] = in.DatasetName
			out["datasetUUID"] = in.DatasetUUID
		}
		out["flocker"] = &result
	}
	if in.DownwardAPI != nil {
		result := make(map[string]interface{})
		{
			in, out := in.DownwardAPI, result
			if in.Items != nil {
				result := make([]interface{}, len(in.Items))
				{
					in, out := &in.Items, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_DownwardAPIVolumeFile(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["items"] = result
			}
			if in.DefaultMode != nil {
				var result int32
				{
					in, out := in.DefaultMode, result
					out = *in
				}
				out["defaultMode"] = &result
			}
		}
		out["downwardAPI"] = &result
	}
	if in.FC != nil {
		result := make(map[string]interface{})
		{
			in, out := in.FC, result
			if in.TargetWWNs != nil {
				result := make([]interface{}, len(in.TargetWWNs))
				{
					in, out := &in.TargetWWNs, result
					for i := range *in {
						out = append(out, (*in)[i])
					}
				}
				out["targetWWNs"] = result
			}
			if in.Lun != nil {
				var result int32
				{
					in, out := in.Lun, result
					out = *in
				}
				out["lun"] = &result
			}
			out["fsType"] = in.FSType
			out["readOnly"] = in.ReadOnly
		}
		out["fc"] = &result
	}
	if in.AzureFile != nil {
		result := make(map[string]interface{})
		{
			in, out := in.AzureFile, result
			out["secretName"] = in.SecretName
			out["shareName"] = in.ShareName
			out["readOnly"] = in.ReadOnly
		}
		out["azureFile"] = &result
	}
	if in.ConfigMap != nil {
		result := make(map[string]interface{})
		{
			in, out := in.ConfigMap, result
			if err := ConvertToUnstructured_LocalObjectReference(&in.LocalObjectReference, out); err != nil {
				return err
			}
			if in.Items != nil {
				result := make([]interface{}, len(in.Items))
				{
					in, out := &in.Items, result
					for i := range *in {
						result := make(map[string]interface{})
						if err := ConvertToUnstructured_KeyToPath(&(*in)[i], result); err != nil {
							return err
						}
						out = append(out, result)
					}
				}
				out["items"] = result
			}
			if in.DefaultMode != nil {
				var result int32
				{
					in, out := in.DefaultMode, result
					out = *in
				}
				out["defaultMode"] = &result
			}
		}
		out["configMap"] = &result
	}
	if in.VsphereVolume != nil {
		result := make(map[string]interface{})
		{
			in, out := in.VsphereVolume, result
			out["volumePath"] = in.VolumePath
			out["fsType"] = in.FSType
		}
		out["vsphereVolume"] = &result
	}
	if in.Quobyte != nil {
		result := make(map[string]interface{})
		{
			in, out := in.Quobyte, result
			out["registry"] = in.Registry
			out["volume"] = in.Volume
			out["readOnly"] = in.ReadOnly
			out["user"] = in.User
			out["group"] = in.Group
		}
		out["quobyte"] = &result
	}
	if in.AzureDisk != nil {
		result := make(map[string]interface{})
		{
			in, out := in.AzureDisk, result
			out["diskName"] = in.DiskName
			out["diskURI"] = in.DataDiskURI
			if in.CachingMode != nil {
				var result AzureDataDiskCachingMode
				{
					in, out := in.CachingMode, result
					out = *in
				}
				out["cachingMode"] = &result
			}
			if in.FSType != nil {
				var result string
				{
					in, out := in.FSType, result
					out = *in
				}
				out["fsType"] = &result
			}
			if in.ReadOnly != nil {
				var result bool
				{
					in, out := in.ReadOnly, result
					out = *in
				}
				out["readOnly"] = &result
			}
		}
		out["azureDisk"] = &result
	}
	if in.PhotonPersistentDisk != nil {
		result := make(map[string]interface{})
		{
			in, out := in.PhotonPersistentDisk, result
			out["pdID"] = in.PdID
			out["fsType"] = in.FSType
		}
		out["photonPersistentDisk"] = &result
	}
	return nil
}

func ConvertToUnstructured_VsphereVirtualDiskVolumeSource(in *VsphereVirtualDiskVolumeSource, out map[string]interface{}) error {
	out["volumePath"] = in.VolumePath
	out["fsType"] = in.FSType
	return nil
}

func ConvertToUnstructured_WeightedPodAffinityTerm(in *WeightedPodAffinityTerm, out map[string]interface{}) error {
	out["weight"] = in.Weight
	{
		result := make(map[string]interface{})
		if err := ConvertToUnstructured_PodAffinityTerm(&in.PodAffinityTerm, result); err != nil {
			return err
		}
		out["podAffinityTerm"] = result
	}
	return nil
}
