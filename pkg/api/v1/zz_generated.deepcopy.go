// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package v1

import (
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	conversion "k8s.io/apimachinery/pkg/conversion"
	runtime "k8s.io/apimachinery/pkg/runtime"
	types "k8s.io/apimachinery/pkg/types"
	reflect "reflect"
)

func init() {
	SchemeBuilder.Register(RegisterDeepCopies)
}

// RegisterDeepCopies adds deep-copy functions to the given scheme. Public
// to allow building arbitrary schemes.
func RegisterDeepCopies(scheme *runtime.Scheme) error {
	return scheme.AddGeneratedDeepCopyFuncs(
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1AWSElasticBlockStoreVolumeSource, InType: reflect.TypeOf(&AWSElasticBlockStoreVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Affinity, InType: reflect.TypeOf(&Affinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1AttachedVolume, InType: reflect.TypeOf(&AttachedVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1AvoidPods, InType: reflect.TypeOf(&AvoidPods{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1AzureDiskVolumeSource, InType: reflect.TypeOf(&AzureDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1AzureFileVolumeSource, InType: reflect.TypeOf(&AzureFileVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Binding, InType: reflect.TypeOf(&Binding{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Capabilities, InType: reflect.TypeOf(&Capabilities{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1CephFSVolumeSource, InType: reflect.TypeOf(&CephFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1CinderVolumeSource, InType: reflect.TypeOf(&CinderVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ComponentCondition, InType: reflect.TypeOf(&ComponentCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ComponentStatus, InType: reflect.TypeOf(&ComponentStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ComponentStatusList, InType: reflect.TypeOf(&ComponentStatusList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ConfigMap, InType: reflect.TypeOf(&ConfigMap{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ConfigMapEnvSource, InType: reflect.TypeOf(&ConfigMapEnvSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ConfigMapKeySelector, InType: reflect.TypeOf(&ConfigMapKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ConfigMapList, InType: reflect.TypeOf(&ConfigMapList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ConfigMapVolumeSource, InType: reflect.TypeOf(&ConfigMapVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Container, InType: reflect.TypeOf(&Container{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerImage, InType: reflect.TypeOf(&ContainerImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerPort, InType: reflect.TypeOf(&ContainerPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerState, InType: reflect.TypeOf(&ContainerState{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerStateRunning, InType: reflect.TypeOf(&ContainerStateRunning{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerStateTerminated, InType: reflect.TypeOf(&ContainerStateTerminated{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerStateWaiting, InType: reflect.TypeOf(&ContainerStateWaiting{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ContainerStatus, InType: reflect.TypeOf(&ContainerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1DaemonEndpoint, InType: reflect.TypeOf(&DaemonEndpoint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1DeleteOptions, InType: reflect.TypeOf(&DeleteOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1DownwardAPIVolumeFile, InType: reflect.TypeOf(&DownwardAPIVolumeFile{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1DownwardAPIVolumeSource, InType: reflect.TypeOf(&DownwardAPIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EmptyDirVolumeSource, InType: reflect.TypeOf(&EmptyDirVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EndpointAddress, InType: reflect.TypeOf(&EndpointAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EndpointPort, InType: reflect.TypeOf(&EndpointPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EndpointSubset, InType: reflect.TypeOf(&EndpointSubset{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Endpoints, InType: reflect.TypeOf(&Endpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EndpointsList, InType: reflect.TypeOf(&EndpointsList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EnvFromSource, InType: reflect.TypeOf(&EnvFromSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EnvVar, InType: reflect.TypeOf(&EnvVar{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EnvVarSource, InType: reflect.TypeOf(&EnvVarSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Event, InType: reflect.TypeOf(&Event{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EventList, InType: reflect.TypeOf(&EventList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1EventSource, InType: reflect.TypeOf(&EventSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ExecAction, InType: reflect.TypeOf(&ExecAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1FCVolumeSource, InType: reflect.TypeOf(&FCVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1FlexVolumeSource, InType: reflect.TypeOf(&FlexVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1FlockerVolumeSource, InType: reflect.TypeOf(&FlockerVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1GCEPersistentDiskVolumeSource, InType: reflect.TypeOf(&GCEPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1GitRepoVolumeSource, InType: reflect.TypeOf(&GitRepoVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1GlusterfsVolumeSource, InType: reflect.TypeOf(&GlusterfsVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1HTTPGetAction, InType: reflect.TypeOf(&HTTPGetAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1HTTPHeader, InType: reflect.TypeOf(&HTTPHeader{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Handler, InType: reflect.TypeOf(&Handler{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1HostPathVolumeSource, InType: reflect.TypeOf(&HostPathVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ISCSIVolumeSource, InType: reflect.TypeOf(&ISCSIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1KeyToPath, InType: reflect.TypeOf(&KeyToPath{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Lifecycle, InType: reflect.TypeOf(&Lifecycle{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LimitRange, InType: reflect.TypeOf(&LimitRange{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LimitRangeItem, InType: reflect.TypeOf(&LimitRangeItem{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LimitRangeList, InType: reflect.TypeOf(&LimitRangeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LimitRangeSpec, InType: reflect.TypeOf(&LimitRangeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1List, InType: reflect.TypeOf(&List{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ListOptions, InType: reflect.TypeOf(&ListOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LoadBalancerIngress, InType: reflect.TypeOf(&LoadBalancerIngress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LoadBalancerStatus, InType: reflect.TypeOf(&LoadBalancerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1LocalObjectReference, InType: reflect.TypeOf(&LocalObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NFSVolumeSource, InType: reflect.TypeOf(&NFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Namespace, InType: reflect.TypeOf(&Namespace{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NamespaceList, InType: reflect.TypeOf(&NamespaceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NamespaceSpec, InType: reflect.TypeOf(&NamespaceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NamespaceStatus, InType: reflect.TypeOf(&NamespaceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Node, InType: reflect.TypeOf(&Node{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeAddress, InType: reflect.TypeOf(&NodeAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeAffinity, InType: reflect.TypeOf(&NodeAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeCondition, InType: reflect.TypeOf(&NodeCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeDaemonEndpoints, InType: reflect.TypeOf(&NodeDaemonEndpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeList, InType: reflect.TypeOf(&NodeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeProxyOptions, InType: reflect.TypeOf(&NodeProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeResources, InType: reflect.TypeOf(&NodeResources{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeSelector, InType: reflect.TypeOf(&NodeSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeSelectorRequirement, InType: reflect.TypeOf(&NodeSelectorRequirement{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeSelectorTerm, InType: reflect.TypeOf(&NodeSelectorTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeSpec, InType: reflect.TypeOf(&NodeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeStatus, InType: reflect.TypeOf(&NodeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1NodeSystemInfo, InType: reflect.TypeOf(&NodeSystemInfo{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ObjectFieldSelector, InType: reflect.TypeOf(&ObjectFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ObjectMeta, InType: reflect.TypeOf(&ObjectMeta{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ObjectReference, InType: reflect.TypeOf(&ObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolume, InType: reflect.TypeOf(&PersistentVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeClaim, InType: reflect.TypeOf(&PersistentVolumeClaim{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeClaimList, InType: reflect.TypeOf(&PersistentVolumeClaimList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeClaimSpec, InType: reflect.TypeOf(&PersistentVolumeClaimSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeClaimStatus, InType: reflect.TypeOf(&PersistentVolumeClaimStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeClaimVolumeSource, InType: reflect.TypeOf(&PersistentVolumeClaimVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeList, InType: reflect.TypeOf(&PersistentVolumeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeSource, InType: reflect.TypeOf(&PersistentVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeSpec, InType: reflect.TypeOf(&PersistentVolumeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PersistentVolumeStatus, InType: reflect.TypeOf(&PersistentVolumeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PhotonPersistentDiskVolumeSource, InType: reflect.TypeOf(&PhotonPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Pod, InType: reflect.TypeOf(&Pod{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodAffinity, InType: reflect.TypeOf(&PodAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodAffinityTerm, InType: reflect.TypeOf(&PodAffinityTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodAntiAffinity, InType: reflect.TypeOf(&PodAntiAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodAttachOptions, InType: reflect.TypeOf(&PodAttachOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodCondition, InType: reflect.TypeOf(&PodCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodExecOptions, InType: reflect.TypeOf(&PodExecOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodList, InType: reflect.TypeOf(&PodList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodLogOptions, InType: reflect.TypeOf(&PodLogOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodPortForwardOptions, InType: reflect.TypeOf(&PodPortForwardOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodProxyOptions, InType: reflect.TypeOf(&PodProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodSecurityContext, InType: reflect.TypeOf(&PodSecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodSignature, InType: reflect.TypeOf(&PodSignature{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodSpec, InType: reflect.TypeOf(&PodSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodStatus, InType: reflect.TypeOf(&PodStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodStatusResult, InType: reflect.TypeOf(&PodStatusResult{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodTemplate, InType: reflect.TypeOf(&PodTemplate{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodTemplateList, InType: reflect.TypeOf(&PodTemplateList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PodTemplateSpec, InType: reflect.TypeOf(&PodTemplateSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Preconditions, InType: reflect.TypeOf(&Preconditions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PreferAvoidPodsEntry, InType: reflect.TypeOf(&PreferAvoidPodsEntry{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1PreferredSchedulingTerm, InType: reflect.TypeOf(&PreferredSchedulingTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Probe, InType: reflect.TypeOf(&Probe{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1QuobyteVolumeSource, InType: reflect.TypeOf(&QuobyteVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1RBDVolumeSource, InType: reflect.TypeOf(&RBDVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1RangeAllocation, InType: reflect.TypeOf(&RangeAllocation{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ReplicationController, InType: reflect.TypeOf(&ReplicationController{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ReplicationControllerCondition, InType: reflect.TypeOf(&ReplicationControllerCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ReplicationControllerList, InType: reflect.TypeOf(&ReplicationControllerList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ReplicationControllerSpec, InType: reflect.TypeOf(&ReplicationControllerSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ReplicationControllerStatus, InType: reflect.TypeOf(&ReplicationControllerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ResourceFieldSelector, InType: reflect.TypeOf(&ResourceFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ResourceQuota, InType: reflect.TypeOf(&ResourceQuota{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ResourceQuotaList, InType: reflect.TypeOf(&ResourceQuotaList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ResourceQuotaSpec, InType: reflect.TypeOf(&ResourceQuotaSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ResourceQuotaStatus, InType: reflect.TypeOf(&ResourceQuotaStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ResourceRequirements, InType: reflect.TypeOf(&ResourceRequirements{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SELinuxOptions, InType: reflect.TypeOf(&SELinuxOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Secret, InType: reflect.TypeOf(&Secret{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SecretEnvSource, InType: reflect.TypeOf(&SecretEnvSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SecretKeySelector, InType: reflect.TypeOf(&SecretKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SecretList, InType: reflect.TypeOf(&SecretList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SecretVolumeSource, InType: reflect.TypeOf(&SecretVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SecurityContext, InType: reflect.TypeOf(&SecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1SerializedReference, InType: reflect.TypeOf(&SerializedReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Service, InType: reflect.TypeOf(&Service{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServiceAccount, InType: reflect.TypeOf(&ServiceAccount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServiceAccountList, InType: reflect.TypeOf(&ServiceAccountList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServiceList, InType: reflect.TypeOf(&ServiceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServicePort, InType: reflect.TypeOf(&ServicePort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServiceProxyOptions, InType: reflect.TypeOf(&ServiceProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServiceSpec, InType: reflect.TypeOf(&ServiceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1ServiceStatus, InType: reflect.TypeOf(&ServiceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Sysctl, InType: reflect.TypeOf(&Sysctl{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1TCPSocketAction, InType: reflect.TypeOf(&TCPSocketAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Taint, InType: reflect.TypeOf(&Taint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Toleration, InType: reflect.TypeOf(&Toleration{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1Volume, InType: reflect.TypeOf(&Volume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1VolumeMount, InType: reflect.TypeOf(&VolumeMount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1VolumeSource, InType: reflect.TypeOf(&VolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1VsphereVirtualDiskVolumeSource, InType: reflect.TypeOf(&VsphereVirtualDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopyv1WeightedPodAffinityTerm, InType: reflect.TypeOf(&WeightedPodAffinityTerm{})},
	)
}

// DeepCopyv1AWSElasticBlockStoreVolumeSource ...
func DeepCopyv1AWSElasticBlockStoreVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AWSElasticBlockStoreVolumeSource)
		out := out.(*AWSElasticBlockStoreVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1Affinity ...
func DeepCopyv1Affinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Affinity)
		out := out.(*Affinity)
		*out = *in
		if in.NodeAffinity != nil {
			in, out := &in.NodeAffinity, &out.NodeAffinity
			*out = new(NodeAffinity)
			if err := DeepCopyv1NodeAffinity(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PodAffinity != nil {
			in, out := &in.PodAffinity, &out.PodAffinity
			*out = new(PodAffinity)
			if err := DeepCopyv1PodAffinity(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PodAntiAffinity != nil {
			in, out := &in.PodAntiAffinity, &out.PodAntiAffinity
			*out = new(PodAntiAffinity)
			if err := DeepCopyv1PodAntiAffinity(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1AttachedVolume ...
func DeepCopyv1AttachedVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AttachedVolume)
		out := out.(*AttachedVolume)
		*out = *in
		return nil
	}
}

// DeepCopyv1AvoidPods ...
func DeepCopyv1AvoidPods(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AvoidPods)
		out := out.(*AvoidPods)
		*out = *in
		if in.PreferAvoidPods != nil {
			in, out := &in.PreferAvoidPods, &out.PreferAvoidPods
			*out = make([]PreferAvoidPodsEntry, len(*in))
			for i := range *in {
				if err := DeepCopyv1PreferAvoidPodsEntry(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1AzureDiskVolumeSource ...
func DeepCopyv1AzureDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AzureDiskVolumeSource)
		out := out.(*AzureDiskVolumeSource)
		*out = *in
		if in.CachingMode != nil {
			in, out := &in.CachingMode, &out.CachingMode
			*out = new(AzureDataDiskCachingMode)
			**out = **in
		}
		if in.FSType != nil {
			in, out := &in.FSType, &out.FSType
			*out = new(string)
			**out = **in
		}
		if in.ReadOnly != nil {
			in, out := &in.ReadOnly, &out.ReadOnly
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1AzureFileVolumeSource ...
func DeepCopyv1AzureFileVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AzureFileVolumeSource)
		out := out.(*AzureFileVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1Binding ...
func DeepCopyv1Binding(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Binding)
		out := out.(*Binding)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		return nil
	}
}

// DeepCopyv1Capabilities ...
func DeepCopyv1Capabilities(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Capabilities)
		out := out.(*Capabilities)
		*out = *in
		if in.Add != nil {
			in, out := &in.Add, &out.Add
			*out = make([]Capability, len(*in))
			copy(*out, *in)
		}
		if in.Drop != nil {
			in, out := &in.Drop, &out.Drop
			*out = make([]Capability, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1CephFSVolumeSource ...
func DeepCopyv1CephFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*CephFSVolumeSource)
		out := out.(*CephFSVolumeSource)
		*out = *in
		if in.Monitors != nil {
			in, out := &in.Monitors, &out.Monitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1CinderVolumeSource ...
func DeepCopyv1CinderVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*CinderVolumeSource)
		out := out.(*CinderVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1ComponentCondition ...
func DeepCopyv1ComponentCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentCondition)
		out := out.(*ComponentCondition)
		*out = *in
		return nil
	}
}

// DeepCopyv1ComponentStatus ...
func DeepCopyv1ComponentStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentStatus)
		out := out.(*ComponentStatus)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]ComponentCondition, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ComponentStatusList ...
func DeepCopyv1ComponentStatusList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentStatusList)
		out := out.(*ComponentStatusList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ComponentStatus, len(*in))
			for i := range *in {
				if err := DeepCopyv1ComponentStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ConfigMap ...
func DeepCopyv1ConfigMap(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMap)
		out := out.(*ConfigMap)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		return nil
	}
}

// DeepCopyv1ConfigMapEnvSource ...
func DeepCopyv1ConfigMapEnvSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapEnvSource)
		out := out.(*ConfigMapEnvSource)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1ConfigMapKeySelector ...
func DeepCopyv1ConfigMapKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapKeySelector)
		out := out.(*ConfigMapKeySelector)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1ConfigMapList ...
func DeepCopyv1ConfigMapList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapList)
		out := out.(*ConfigMapList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ConfigMap, len(*in))
			for i := range *in {
				if err := DeepCopyv1ConfigMap(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ConfigMapVolumeSource ...
func DeepCopyv1ConfigMapVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapVolumeSource)
		out := out.(*ConfigMapVolumeSource)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopyv1KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1Container ...
func DeepCopyv1Container(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Container)
		out := out.(*Container)
		*out = *in
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.Args != nil {
			in, out := &in.Args, &out.Args
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]ContainerPort, len(*in))
			copy(*out, *in)
		}
		if in.EnvFrom != nil {
			in, out := &in.EnvFrom, &out.EnvFrom
			*out = make([]EnvFromSource, len(*in))
			for i := range *in {
				if err := DeepCopyv1EnvFromSource(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Env != nil {
			in, out := &in.Env, &out.Env
			*out = make([]EnvVar, len(*in))
			for i := range *in {
				if err := DeepCopyv1EnvVar(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if err := DeepCopyv1ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		if in.VolumeMounts != nil {
			in, out := &in.VolumeMounts, &out.VolumeMounts
			*out = make([]VolumeMount, len(*in))
			copy(*out, *in)
		}
		if in.LivenessProbe != nil {
			in, out := &in.LivenessProbe, &out.LivenessProbe
			*out = new(Probe)
			if err := DeepCopyv1Probe(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ReadinessProbe != nil {
			in, out := &in.ReadinessProbe, &out.ReadinessProbe
			*out = new(Probe)
			if err := DeepCopyv1Probe(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Lifecycle != nil {
			in, out := &in.Lifecycle, &out.Lifecycle
			*out = new(Lifecycle)
			if err := DeepCopyv1Lifecycle(*in, *out, c); err != nil {
				return err
			}
		}
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(SecurityContext)
			if err := DeepCopyv1SecurityContext(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1ContainerImage ...
func DeepCopyv1ContainerImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerImage)
		out := out.(*ContainerImage)
		*out = *in
		if in.Names != nil {
			in, out := &in.Names, &out.Names
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ContainerPort ...
func DeepCopyv1ContainerPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerPort)
		out := out.(*ContainerPort)
		*out = *in
		return nil
	}
}

// DeepCopyv1ContainerState ...
func DeepCopyv1ContainerState(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerState)
		out := out.(*ContainerState)
		*out = *in
		if in.Waiting != nil {
			in, out := &in.Waiting, &out.Waiting
			*out = new(ContainerStateWaiting)
			**out = **in
		}
		if in.Running != nil {
			in, out := &in.Running, &out.Running
			*out = new(ContainerStateRunning)
			if err := DeepCopyv1ContainerStateRunning(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Terminated != nil {
			in, out := &in.Terminated, &out.Terminated
			*out = new(ContainerStateTerminated)
			if err := DeepCopyv1ContainerStateTerminated(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1ContainerStateRunning ...
func DeepCopyv1ContainerStateRunning(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateRunning)
		out := out.(*ContainerStateRunning)
		*out = *in
		out.StartedAt = in.StartedAt.DeepCopy()
		return nil
	}
}

// DeepCopyv1ContainerStateTerminated ...
func DeepCopyv1ContainerStateTerminated(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateTerminated)
		out := out.(*ContainerStateTerminated)
		*out = *in
		out.StartedAt = in.StartedAt.DeepCopy()
		out.FinishedAt = in.FinishedAt.DeepCopy()
		return nil
	}
}

// DeepCopyv1ContainerStateWaiting ...
func DeepCopyv1ContainerStateWaiting(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateWaiting)
		out := out.(*ContainerStateWaiting)
		*out = *in
		return nil
	}
}

// DeepCopyv1ContainerStatus ...
func DeepCopyv1ContainerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStatus)
		out := out.(*ContainerStatus)
		*out = *in
		if err := DeepCopyv1ContainerState(&in.State, &out.State, c); err != nil {
			return err
		}
		if err := DeepCopyv1ContainerState(&in.LastTerminationState, &out.LastTerminationState, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1DaemonEndpoint ...
func DeepCopyv1DaemonEndpoint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DaemonEndpoint)
		out := out.(*DaemonEndpoint)
		*out = *in
		return nil
	}
}

// DeepCopyv1DeleteOptions ...
func DeepCopyv1DeleteOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DeleteOptions)
		out := out.(*DeleteOptions)
		*out = *in
		if in.GracePeriodSeconds != nil {
			in, out := &in.GracePeriodSeconds, &out.GracePeriodSeconds
			*out = new(int64)
			**out = **in
		}
		if in.Preconditions != nil {
			in, out := &in.Preconditions, &out.Preconditions
			*out = new(Preconditions)
			if err := DeepCopyv1Preconditions(*in, *out, c); err != nil {
				return err
			}
		}
		if in.OrphanDependents != nil {
			in, out := &in.OrphanDependents, &out.OrphanDependents
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1DownwardAPIVolumeFile ...
func DeepCopyv1DownwardAPIVolumeFile(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DownwardAPIVolumeFile)
		out := out.(*DownwardAPIVolumeFile)
		*out = *in
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(ObjectFieldSelector)
			**out = **in
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(ResourceFieldSelector)
			if err := DeepCopyv1ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1DownwardAPIVolumeSource ...
func DeepCopyv1DownwardAPIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DownwardAPIVolumeSource)
		out := out.(*DownwardAPIVolumeSource)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				if err := DeepCopyv1DownwardAPIVolumeFile(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1EmptyDirVolumeSource ...
func DeepCopyv1EmptyDirVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EmptyDirVolumeSource)
		out := out.(*EmptyDirVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1EndpointAddress ...
func DeepCopyv1EndpointAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointAddress)
		out := out.(*EndpointAddress)
		*out = *in
		if in.NodeName != nil {
			in, out := &in.NodeName, &out.NodeName
			*out = new(string)
			**out = **in
		}
		if in.TargetRef != nil {
			in, out := &in.TargetRef, &out.TargetRef
			*out = new(ObjectReference)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1EndpointPort ...
func DeepCopyv1EndpointPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointPort)
		out := out.(*EndpointPort)
		*out = *in
		return nil
	}
}

// DeepCopyv1EndpointSubset ...
func DeepCopyv1EndpointSubset(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointSubset)
		out := out.(*EndpointSubset)
		*out = *in
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopyv1EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.NotReadyAddresses != nil {
			in, out := &in.NotReadyAddresses, &out.NotReadyAddresses
			*out = make([]EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopyv1EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]EndpointPort, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1Endpoints ...
func DeepCopyv1Endpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Endpoints)
		out := out.(*Endpoints)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if in.Subsets != nil {
			in, out := &in.Subsets, &out.Subsets
			*out = make([]EndpointSubset, len(*in))
			for i := range *in {
				if err := DeepCopyv1EndpointSubset(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1EndpointsList ...
func DeepCopyv1EndpointsList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointsList)
		out := out.(*EndpointsList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Endpoints, len(*in))
			for i := range *in {
				if err := DeepCopyv1Endpoints(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1EnvFromSource ...
func DeepCopyv1EnvFromSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvFromSource)
		out := out.(*EnvFromSource)
		*out = *in
		if in.ConfigMapRef != nil {
			in, out := &in.ConfigMapRef, &out.ConfigMapRef
			*out = new(ConfigMapEnvSource)
			if err := DeepCopyv1ConfigMapEnvSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(SecretEnvSource)
			if err := DeepCopyv1SecretEnvSource(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1EnvVar ...
func DeepCopyv1EnvVar(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvVar)
		out := out.(*EnvVar)
		*out = *in
		if in.ValueFrom != nil {
			in, out := &in.ValueFrom, &out.ValueFrom
			*out = new(EnvVarSource)
			if err := DeepCopyv1EnvVarSource(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1EnvVarSource ...
func DeepCopyv1EnvVarSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvVarSource)
		out := out.(*EnvVarSource)
		*out = *in
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(ObjectFieldSelector)
			**out = **in
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(ResourceFieldSelector)
			if err := DeepCopyv1ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ConfigMapKeyRef != nil {
			in, out := &in.ConfigMapKeyRef, &out.ConfigMapKeyRef
			*out = new(ConfigMapKeySelector)
			if err := DeepCopyv1ConfigMapKeySelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.SecretKeyRef != nil {
			in, out := &in.SecretKeyRef, &out.SecretKeyRef
			*out = new(SecretKeySelector)
			if err := DeepCopyv1SecretKeySelector(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1Event ...
func DeepCopyv1Event(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Event)
		out := out.(*Event)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		out.FirstTimestamp = in.FirstTimestamp.DeepCopy()
		out.LastTimestamp = in.LastTimestamp.DeepCopy()
		return nil
	}
}

// DeepCopyv1EventList ...
func DeepCopyv1EventList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EventList)
		out := out.(*EventList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Event, len(*in))
			for i := range *in {
				if err := DeepCopyv1Event(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1EventSource ...
func DeepCopyv1EventSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EventSource)
		out := out.(*EventSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1ExecAction ...
func DeepCopyv1ExecAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ExecAction)
		out := out.(*ExecAction)
		*out = *in
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1FCVolumeSource ...
func DeepCopyv1FCVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FCVolumeSource)
		out := out.(*FCVolumeSource)
		*out = *in
		if in.TargetWWNs != nil {
			in, out := &in.TargetWWNs, &out.TargetWWNs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.Lun != nil {
			in, out := &in.Lun, &out.Lun
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1FlexVolumeSource ...
func DeepCopyv1FlexVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FlexVolumeSource)
		out := out.(*FlexVolumeSource)
		*out = *in
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
		}
		if in.Options != nil {
			in, out := &in.Options, &out.Options
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		return nil
	}
}

// DeepCopyv1FlockerVolumeSource ...
func DeepCopyv1FlockerVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FlockerVolumeSource)
		out := out.(*FlockerVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1GCEPersistentDiskVolumeSource ...
func DeepCopyv1GCEPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GCEPersistentDiskVolumeSource)
		out := out.(*GCEPersistentDiskVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1GitRepoVolumeSource ...
func DeepCopyv1GitRepoVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GitRepoVolumeSource)
		out := out.(*GitRepoVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1GlusterfsVolumeSource ...
func DeepCopyv1GlusterfsVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GlusterfsVolumeSource)
		out := out.(*GlusterfsVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1HTTPGetAction ...
func DeepCopyv1HTTPGetAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HTTPGetAction)
		out := out.(*HTTPGetAction)
		*out = *in
		if in.HTTPHeaders != nil {
			in, out := &in.HTTPHeaders, &out.HTTPHeaders
			*out = make([]HTTPHeader, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1HTTPHeader ...
func DeepCopyv1HTTPHeader(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HTTPHeader)
		out := out.(*HTTPHeader)
		*out = *in
		return nil
	}
}

// DeepCopyv1Handler ...
func DeepCopyv1Handler(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Handler)
		out := out.(*Handler)
		*out = *in
		if in.Exec != nil {
			in, out := &in.Exec, &out.Exec
			*out = new(ExecAction)
			if err := DeepCopyv1ExecAction(*in, *out, c); err != nil {
				return err
			}
		}
		if in.HTTPGet != nil {
			in, out := &in.HTTPGet, &out.HTTPGet
			*out = new(HTTPGetAction)
			if err := DeepCopyv1HTTPGetAction(*in, *out, c); err != nil {
				return err
			}
		}
		if in.TCPSocket != nil {
			in, out := &in.TCPSocket, &out.TCPSocket
			*out = new(TCPSocketAction)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1HostPathVolumeSource ...
func DeepCopyv1HostPathVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HostPathVolumeSource)
		out := out.(*HostPathVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1ISCSIVolumeSource ...
func DeepCopyv1ISCSIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ISCSIVolumeSource)
		out := out.(*ISCSIVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1KeyToPath ...
func DeepCopyv1KeyToPath(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*KeyToPath)
		out := out.(*KeyToPath)
		*out = *in
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1Lifecycle ...
func DeepCopyv1Lifecycle(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Lifecycle)
		out := out.(*Lifecycle)
		*out = *in
		if in.PostStart != nil {
			in, out := &in.PostStart, &out.PostStart
			*out = new(Handler)
			if err := DeepCopyv1Handler(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PreStop != nil {
			in, out := &in.PreStop, &out.PreStop
			*out = new(Handler)
			if err := DeepCopyv1Handler(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1LimitRange ...
func DeepCopyv1LimitRange(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRange)
		out := out.(*LimitRange)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1LimitRangeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1LimitRangeItem ...
func DeepCopyv1LimitRangeItem(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeItem)
		out := out.(*LimitRangeItem)
		*out = *in
		if in.Max != nil {
			in, out := &in.Max, &out.Max
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Min != nil {
			in, out := &in.Min, &out.Min
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Default != nil {
			in, out := &in.Default, &out.Default
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.DefaultRequest != nil {
			in, out := &in.DefaultRequest, &out.DefaultRequest
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.MaxLimitRequestRatio != nil {
			in, out := &in.MaxLimitRequestRatio, &out.MaxLimitRequestRatio
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

// DeepCopyv1LimitRangeList ...
func DeepCopyv1LimitRangeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeList)
		out := out.(*LimitRangeList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]LimitRange, len(*in))
			for i := range *in {
				if err := DeepCopyv1LimitRange(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1LimitRangeSpec ...
func DeepCopyv1LimitRangeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeSpec)
		out := out.(*LimitRangeSpec)
		*out = *in
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make([]LimitRangeItem, len(*in))
			for i := range *in {
				if err := DeepCopyv1LimitRangeItem(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1List ...
func DeepCopyv1List(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*List)
		out := out.(*List)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]runtime.RawExtension, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err == nil {
					(*out)[i] = *newVal.(*runtime.RawExtension)
				} else {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ListOptions ...
func DeepCopyv1ListOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ListOptions)
		out := out.(*ListOptions)
		*out = *in
		if in.TimeoutSeconds != nil {
			in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1LoadBalancerIngress ...
func DeepCopyv1LoadBalancerIngress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LoadBalancerIngress)
		out := out.(*LoadBalancerIngress)
		*out = *in
		return nil
	}
}

// DeepCopyv1LoadBalancerStatus ...
func DeepCopyv1LoadBalancerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LoadBalancerStatus)
		out := out.(*LoadBalancerStatus)
		*out = *in
		if in.Ingress != nil {
			in, out := &in.Ingress, &out.Ingress
			*out = make([]LoadBalancerIngress, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1LocalObjectReference ...
func DeepCopyv1LocalObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LocalObjectReference)
		out := out.(*LocalObjectReference)
		*out = *in
		return nil
	}
}

// DeepCopyv1NFSVolumeSource ...
func DeepCopyv1NFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NFSVolumeSource)
		out := out.(*NFSVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1Namespace ...
func DeepCopyv1Namespace(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Namespace)
		out := out.(*Namespace)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1NamespaceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1NamespaceList ...
func DeepCopyv1NamespaceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceList)
		out := out.(*NamespaceList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Namespace, len(*in))
			for i := range *in {
				if err := DeepCopyv1Namespace(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1NamespaceSpec ...
func DeepCopyv1NamespaceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceSpec)
		out := out.(*NamespaceSpec)
		*out = *in
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]FinalizerName, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1NamespaceStatus ...
func DeepCopyv1NamespaceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceStatus)
		out := out.(*NamespaceStatus)
		*out = *in
		return nil
	}
}

// DeepCopyv1Node ...
func DeepCopyv1Node(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Node)
		out := out.(*Node)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1NodeStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1NodeAddress ...
func DeepCopyv1NodeAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeAddress)
		out := out.(*NodeAddress)
		*out = *in
		return nil
	}
}

// DeepCopyv1NodeAffinity ...
func DeepCopyv1NodeAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeAffinity)
		out := out.(*NodeAffinity)
		*out = *in
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = new(NodeSelector)
			if err := DeepCopyv1NodeSelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]PreferredSchedulingTerm, len(*in))
			for i := range *in {
				if err := DeepCopyv1PreferredSchedulingTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1NodeCondition ...
func DeepCopyv1NodeCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeCondition)
		out := out.(*NodeCondition)
		*out = *in
		out.LastHeartbeatTime = in.LastHeartbeatTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		return nil
	}
}

// DeepCopyv1NodeDaemonEndpoints ...
func DeepCopyv1NodeDaemonEndpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeDaemonEndpoints)
		out := out.(*NodeDaemonEndpoints)
		*out = *in
		return nil
	}
}

// DeepCopyv1NodeList ...
func DeepCopyv1NodeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeList)
		out := out.(*NodeList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Node, len(*in))
			for i := range *in {
				if err := DeepCopyv1Node(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1NodeProxyOptions ...
func DeepCopyv1NodeProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeProxyOptions)
		out := out.(*NodeProxyOptions)
		*out = *in
		return nil
	}
}

// DeepCopyv1NodeResources ...
func DeepCopyv1NodeResources(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeResources)
		out := out.(*NodeResources)
		*out = *in
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

// DeepCopyv1NodeSelector ...
func DeepCopyv1NodeSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelector)
		out := out.(*NodeSelector)
		*out = *in
		if in.NodeSelectorTerms != nil {
			in, out := &in.NodeSelectorTerms, &out.NodeSelectorTerms
			*out = make([]NodeSelectorTerm, len(*in))
			for i := range *in {
				if err := DeepCopyv1NodeSelectorTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1NodeSelectorRequirement ...
func DeepCopyv1NodeSelectorRequirement(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelectorRequirement)
		out := out.(*NodeSelectorRequirement)
		*out = *in
		if in.Values != nil {
			in, out := &in.Values, &out.Values
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1NodeSelectorTerm ...
func DeepCopyv1NodeSelectorTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelectorTerm)
		out := out.(*NodeSelectorTerm)
		*out = *in
		if in.MatchExpressions != nil {
			in, out := &in.MatchExpressions, &out.MatchExpressions
			*out = make([]NodeSelectorRequirement, len(*in))
			for i := range *in {
				if err := DeepCopyv1NodeSelectorRequirement(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1NodeSpec ...
func DeepCopyv1NodeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSpec)
		out := out.(*NodeSpec)
		*out = *in
		return nil
	}
}

// DeepCopyv1NodeStatus ...
func DeepCopyv1NodeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeStatus)
		out := out.(*NodeStatus)
		*out = *in
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Allocatable != nil {
			in, out := &in.Allocatable, &out.Allocatable
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]NodeCondition, len(*in))
			for i := range *in {
				if err := DeepCopyv1NodeCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]NodeAddress, len(*in))
			copy(*out, *in)
		}
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]ContainerImage, len(*in))
			for i := range *in {
				if err := DeepCopyv1ContainerImage(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.VolumesInUse != nil {
			in, out := &in.VolumesInUse, &out.VolumesInUse
			*out = make([]UniqueVolumeName, len(*in))
			copy(*out, *in)
		}
		if in.VolumesAttached != nil {
			in, out := &in.VolumesAttached, &out.VolumesAttached
			*out = make([]AttachedVolume, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1NodeSystemInfo ...
func DeepCopyv1NodeSystemInfo(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSystemInfo)
		out := out.(*NodeSystemInfo)
		*out = *in
		return nil
	}
}

// DeepCopyv1ObjectFieldSelector ...
func DeepCopyv1ObjectFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectFieldSelector)
		out := out.(*ObjectFieldSelector)
		*out = *in
		return nil
	}
}

// DeepCopyv1ObjectMeta ...
func DeepCopyv1ObjectMeta(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectMeta)
		out := out.(*ObjectMeta)
		*out = *in
		out.CreationTimestamp = in.CreationTimestamp.DeepCopy()
		if in.DeletionTimestamp != nil {
			in, out := &in.DeletionTimestamp, &out.DeletionTimestamp
			*out = new(meta_v1.Time)
			**out = (*in).DeepCopy()
		}
		if in.DeletionGracePeriodSeconds != nil {
			in, out := &in.DeletionGracePeriodSeconds, &out.DeletionGracePeriodSeconds
			*out = new(int64)
			**out = **in
		}
		if in.Labels != nil {
			in, out := &in.Labels, &out.Labels
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.Annotations != nil {
			in, out := &in.Annotations, &out.Annotations
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.OwnerReferences != nil {
			in, out := &in.OwnerReferences, &out.OwnerReferences
			*out = make([]meta_v1.OwnerReference, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err == nil {
					(*out)[i] = *newVal.(*meta_v1.OwnerReference)
				} else {
					return err
				}
			}
		}
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ObjectReference ...
func DeepCopyv1ObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectReference)
		out := out.(*ObjectReference)
		*out = *in
		return nil
	}
}

// DeepCopyv1PersistentVolume ...
func DeepCopyv1PersistentVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolume)
		out := out.(*PersistentVolume)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1PersistentVolumeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeClaim ...
func DeepCopyv1PersistentVolumeClaim(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaim)
		out := out.(*PersistentVolumeClaim)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1PersistentVolumeClaimSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopyv1PersistentVolumeClaimStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeClaimList ...
func DeepCopyv1PersistentVolumeClaimList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimList)
		out := out.(*PersistentVolumeClaimList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PersistentVolumeClaim, len(*in))
			for i := range *in {
				if err := DeepCopyv1PersistentVolumeClaim(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeClaimSpec ...
func DeepCopyv1PersistentVolumeClaimSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimSpec)
		out := out.(*PersistentVolumeClaimSpec)
		*out = *in
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			copy(*out, *in)
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			if newVal, err := c.DeepCopy(*in); err == nil {
				*out = newVal.(*meta_v1.LabelSelector)
			} else {
				return err
			}
		}
		if err := DeepCopyv1ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeClaimStatus ...
func DeepCopyv1PersistentVolumeClaimStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimStatus)
		out := out.(*PersistentVolumeClaimStatus)
		*out = *in
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			copy(*out, *in)
		}
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeClaimVolumeSource ...
func DeepCopyv1PersistentVolumeClaimVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimVolumeSource)
		out := out.(*PersistentVolumeClaimVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1PersistentVolumeList ...
func DeepCopyv1PersistentVolumeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeList)
		out := out.(*PersistentVolumeList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PersistentVolume, len(*in))
			for i := range *in {
				if err := DeepCopyv1PersistentVolume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeSource ...
func DeepCopyv1PersistentVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeSource)
		out := out.(*PersistentVolumeSource)
		*out = *in
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(GCEPersistentDiskVolumeSource)
			**out = **in
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(AWSElasticBlockStoreVolumeSource)
			**out = **in
		}
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(HostPathVolumeSource)
			**out = **in
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(GlusterfsVolumeSource)
			**out = **in
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(NFSVolumeSource)
			**out = **in
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(RBDVolumeSource)
			if err := DeepCopyv1RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(ISCSIVolumeSource)
			**out = **in
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(CinderVolumeSource)
			**out = **in
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(CephFSVolumeSource)
			if err := DeepCopyv1CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(FCVolumeSource)
			if err := DeepCopyv1FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(FlockerVolumeSource)
			**out = **in
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(FlexVolumeSource)
			if err := DeepCopyv1FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(AzureFileVolumeSource)
			**out = **in
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(VsphereVirtualDiskVolumeSource)
			**out = **in
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(QuobyteVolumeSource)
			**out = **in
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(AzureDiskVolumeSource)
			if err := DeepCopyv1AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(PhotonPersistentDiskVolumeSource)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeSpec ...
func DeepCopyv1PersistentVolumeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeSpec)
		out := out.(*PersistentVolumeSpec)
		*out = *in
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if err := DeepCopyv1PersistentVolumeSource(&in.PersistentVolumeSource, &out.PersistentVolumeSource, c); err != nil {
			return err
		}
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			copy(*out, *in)
		}
		if in.ClaimRef != nil {
			in, out := &in.ClaimRef, &out.ClaimRef
			*out = new(ObjectReference)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1PersistentVolumeStatus ...
func DeepCopyv1PersistentVolumeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeStatus)
		out := out.(*PersistentVolumeStatus)
		*out = *in
		return nil
	}
}

// DeepCopyv1PhotonPersistentDiskVolumeSource ...
func DeepCopyv1PhotonPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PhotonPersistentDiskVolumeSource)
		out := out.(*PhotonPersistentDiskVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1Pod ...
func DeepCopyv1Pod(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Pod)
		out := out.(*Pod)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopyv1PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1PodAffinity ...
func DeepCopyv1PodAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAffinity)
		out := out.(*PodAffinity)
		*out = *in
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopyv1PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopyv1WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PodAffinityTerm ...
func DeepCopyv1PodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAffinityTerm)
		out := out.(*PodAffinityTerm)
		*out = *in
		if in.LabelSelector != nil {
			in, out := &in.LabelSelector, &out.LabelSelector
			if newVal, err := c.DeepCopy(*in); err == nil {
				*out = newVal.(*meta_v1.LabelSelector)
			} else {
				return err
			}
		}
		if in.Namespaces != nil {
			in, out := &in.Namespaces, &out.Namespaces
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1PodAntiAffinity ...
func DeepCopyv1PodAntiAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAntiAffinity)
		out := out.(*PodAntiAffinity)
		*out = *in
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopyv1PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopyv1WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PodAttachOptions ...
func DeepCopyv1PodAttachOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAttachOptions)
		out := out.(*PodAttachOptions)
		*out = *in
		return nil
	}
}

// DeepCopyv1PodCondition ...
func DeepCopyv1PodCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodCondition)
		out := out.(*PodCondition)
		*out = *in
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		return nil
	}
}

// DeepCopyv1PodExecOptions ...
func DeepCopyv1PodExecOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodExecOptions)
		out := out.(*PodExecOptions)
		*out = *in
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1PodList ...
func DeepCopyv1PodList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodList)
		out := out.(*PodList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Pod, len(*in))
			for i := range *in {
				if err := DeepCopyv1Pod(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PodLogOptions ...
func DeepCopyv1PodLogOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodLogOptions)
		out := out.(*PodLogOptions)
		*out = *in
		if in.SinceSeconds != nil {
			in, out := &in.SinceSeconds, &out.SinceSeconds
			*out = new(int64)
			**out = **in
		}
		if in.SinceTime != nil {
			in, out := &in.SinceTime, &out.SinceTime
			*out = new(meta_v1.Time)
			**out = (*in).DeepCopy()
		}
		if in.TailLines != nil {
			in, out := &in.TailLines, &out.TailLines
			*out = new(int64)
			**out = **in
		}
		if in.LimitBytes != nil {
			in, out := &in.LimitBytes, &out.LimitBytes
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1PodPortForwardOptions ...
func DeepCopyv1PodPortForwardOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodPortForwardOptions)
		out := out.(*PodPortForwardOptions)
		*out = *in
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]int32, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1PodProxyOptions ...
func DeepCopyv1PodProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodProxyOptions)
		out := out.(*PodProxyOptions)
		*out = *in
		return nil
	}
}

// DeepCopyv1PodSecurityContext ...
func DeepCopyv1PodSecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSecurityContext)
		out := out.(*PodSecurityContext)
		*out = *in
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(SELinuxOptions)
			**out = **in
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
		}
		if in.SupplementalGroups != nil {
			in, out := &in.SupplementalGroups, &out.SupplementalGroups
			*out = make([]int64, len(*in))
			copy(*out, *in)
		}
		if in.FSGroup != nil {
			in, out := &in.FSGroup, &out.FSGroup
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1PodSignature ...
func DeepCopyv1PodSignature(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSignature)
		out := out.(*PodSignature)
		*out = *in
		if in.PodController != nil {
			in, out := &in.PodController, &out.PodController
			if newVal, err := c.DeepCopy(*in); err == nil {
				*out = newVal.(*meta_v1.OwnerReference)
			} else {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1PodSpec ...
func DeepCopyv1PodSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSpec)
		out := out.(*PodSpec)
		*out = *in
		if in.Volumes != nil {
			in, out := &in.Volumes, &out.Volumes
			*out = make([]Volume, len(*in))
			for i := range *in {
				if err := DeepCopyv1Volume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.InitContainers != nil {
			in, out := &in.InitContainers, &out.InitContainers
			*out = make([]Container, len(*in))
			for i := range *in {
				if err := DeepCopyv1Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Containers != nil {
			in, out := &in.Containers, &out.Containers
			*out = make([]Container, len(*in))
			for i := range *in {
				if err := DeepCopyv1Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.TerminationGracePeriodSeconds != nil {
			in, out := &in.TerminationGracePeriodSeconds, &out.TerminationGracePeriodSeconds
			*out = new(int64)
			**out = **in
		}
		if in.ActiveDeadlineSeconds != nil {
			in, out := &in.ActiveDeadlineSeconds, &out.ActiveDeadlineSeconds
			*out = new(int64)
			**out = **in
		}
		if in.NodeSelector != nil {
			in, out := &in.NodeSelector, &out.NodeSelector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(PodSecurityContext)
			if err := DeepCopyv1PodSecurityContext(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]LocalObjectReference, len(*in))
			copy(*out, *in)
		}
		if in.Affinity != nil {
			in, out := &in.Affinity, &out.Affinity
			*out = new(Affinity)
			if err := DeepCopyv1Affinity(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1PodStatus ...
func DeepCopyv1PodStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodStatus)
		out := out.(*PodStatus)
		*out = *in
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]PodCondition, len(*in))
			for i := range *in {
				if err := DeepCopyv1PodCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.StartTime != nil {
			in, out := &in.StartTime, &out.StartTime
			*out = new(meta_v1.Time)
			**out = (*in).DeepCopy()
		}
		if in.InitContainerStatuses != nil {
			in, out := &in.InitContainerStatuses, &out.InitContainerStatuses
			*out = make([]ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopyv1ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.ContainerStatuses != nil {
			in, out := &in.ContainerStatuses, &out.ContainerStatuses
			*out = make([]ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopyv1ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PodStatusResult ...
func DeepCopyv1PodStatusResult(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodStatusResult)
		out := out.(*PodStatusResult)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1PodTemplate ...
func DeepCopyv1PodTemplate(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplate)
		out := out.(*PodTemplate)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1PodTemplateSpec(&in.Template, &out.Template, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1PodTemplateList ...
func DeepCopyv1PodTemplateList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplateList)
		out := out.(*PodTemplateList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PodTemplate, len(*in))
			for i := range *in {
				if err := DeepCopyv1PodTemplate(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1PodTemplateSpec ...
func DeepCopyv1PodTemplateSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplateSpec)
		out := out.(*PodTemplateSpec)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1Preconditions ...
func DeepCopyv1Preconditions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Preconditions)
		out := out.(*Preconditions)
		*out = *in
		if in.UID != nil {
			in, out := &in.UID, &out.UID
			*out = new(types.UID)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1PreferAvoidPodsEntry ...
func DeepCopyv1PreferAvoidPodsEntry(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PreferAvoidPodsEntry)
		out := out.(*PreferAvoidPodsEntry)
		*out = *in
		if err := DeepCopyv1PodSignature(&in.PodSignature, &out.PodSignature, c); err != nil {
			return err
		}
		out.EvictionTime = in.EvictionTime.DeepCopy()
		return nil
	}
}

// DeepCopyv1PreferredSchedulingTerm ...
func DeepCopyv1PreferredSchedulingTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PreferredSchedulingTerm)
		out := out.(*PreferredSchedulingTerm)
		*out = *in
		if err := DeepCopyv1NodeSelectorTerm(&in.Preference, &out.Preference, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1Probe ...
func DeepCopyv1Probe(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Probe)
		out := out.(*Probe)
		*out = *in
		if err := DeepCopyv1Handler(&in.Handler, &out.Handler, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1QuobyteVolumeSource ...
func DeepCopyv1QuobyteVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*QuobyteVolumeSource)
		out := out.(*QuobyteVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1RBDVolumeSource ...
func DeepCopyv1RBDVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RBDVolumeSource)
		out := out.(*RBDVolumeSource)
		*out = *in
		if in.CephMonitors != nil {
			in, out := &in.CephMonitors, &out.CephMonitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1RangeAllocation ...
func DeepCopyv1RangeAllocation(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RangeAllocation)
		out := out.(*RangeAllocation)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ReplicationController ...
func DeepCopyv1ReplicationController(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationController)
		out := out.(*ReplicationController)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1ReplicationControllerSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopyv1ReplicationControllerStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1ReplicationControllerCondition ...
func DeepCopyv1ReplicationControllerCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerCondition)
		out := out.(*ReplicationControllerCondition)
		*out = *in
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		return nil
	}
}

// DeepCopyv1ReplicationControllerList ...
func DeepCopyv1ReplicationControllerList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerList)
		out := out.(*ReplicationControllerList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ReplicationController, len(*in))
			for i := range *in {
				if err := DeepCopyv1ReplicationController(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ReplicationControllerSpec ...
func DeepCopyv1ReplicationControllerSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerSpec)
		out := out.(*ReplicationControllerSpec)
		*out = *in
		if in.Replicas != nil {
			in, out := &in.Replicas, &out.Replicas
			*out = new(int32)
			**out = **in
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.Template != nil {
			in, out := &in.Template, &out.Template
			*out = new(PodTemplateSpec)
			if err := DeepCopyv1PodTemplateSpec(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

// DeepCopyv1ReplicationControllerStatus ...
func DeepCopyv1ReplicationControllerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerStatus)
		out := out.(*ReplicationControllerStatus)
		*out = *in
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]ReplicationControllerCondition, len(*in))
			for i := range *in {
				if err := DeepCopyv1ReplicationControllerCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ResourceFieldSelector ...
func DeepCopyv1ResourceFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceFieldSelector)
		out := out.(*ResourceFieldSelector)
		*out = *in
		out.Divisor = in.Divisor.DeepCopy()
		return nil
	}
}

// DeepCopyv1ResourceQuota ...
func DeepCopyv1ResourceQuota(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuota)
		out := out.(*ResourceQuota)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1ResourceQuotaSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopyv1ResourceQuotaStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1ResourceQuotaList ...
func DeepCopyv1ResourceQuotaList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaList)
		out := out.(*ResourceQuotaList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ResourceQuota, len(*in))
			for i := range *in {
				if err := DeepCopyv1ResourceQuota(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ResourceQuotaSpec ...
func DeepCopyv1ResourceQuotaSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaSpec)
		out := out.(*ResourceQuotaSpec)
		*out = *in
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Scopes != nil {
			in, out := &in.Scopes, &out.Scopes
			*out = make([]ResourceQuotaScope, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ResourceQuotaStatus ...
func DeepCopyv1ResourceQuotaStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaStatus)
		out := out.(*ResourceQuotaStatus)
		*out = *in
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Used != nil {
			in, out := &in.Used, &out.Used
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

// DeepCopyv1ResourceRequirements ...
func DeepCopyv1ResourceRequirements(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceRequirements)
		out := out.(*ResourceRequirements)
		*out = *in
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Requests != nil {
			in, out := &in.Requests, &out.Requests
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

// DeepCopyv1SELinuxOptions ...
func DeepCopyv1SELinuxOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SELinuxOptions)
		out := out.(*SELinuxOptions)
		*out = *in
		return nil
	}
}

// DeepCopyv1Secret ...
func DeepCopyv1Secret(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Secret)
		out := out.(*Secret)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string][]byte)
			for key, val := range *in {
				if newVal, err := c.DeepCopy(&val); err == nil {
					(*out)[key] = *newVal.(*[]byte)
				} else {
					return err
				}
			}
		}
		if in.StringData != nil {
			in, out := &in.StringData, &out.StringData
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		return nil
	}
}

// DeepCopyv1SecretEnvSource ...
func DeepCopyv1SecretEnvSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretEnvSource)
		out := out.(*SecretEnvSource)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1SecretKeySelector ...
func DeepCopyv1SecretKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretKeySelector)
		out := out.(*SecretKeySelector)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1SecretList ...
func DeepCopyv1SecretList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretList)
		out := out.(*SecretList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Secret, len(*in))
			for i := range *in {
				if err := DeepCopyv1Secret(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1SecretVolumeSource ...
func DeepCopyv1SecretVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretVolumeSource)
		out := out.(*SecretVolumeSource)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopyv1KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1SecurityContext ...
func DeepCopyv1SecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecurityContext)
		out := out.(*SecurityContext)
		*out = *in
		if in.Capabilities != nil {
			in, out := &in.Capabilities, &out.Capabilities
			*out = new(Capabilities)
			if err := DeepCopyv1Capabilities(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Privileged != nil {
			in, out := &in.Privileged, &out.Privileged
			*out = new(bool)
			**out = **in
		}
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(SELinuxOptions)
			**out = **in
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
		}
		if in.ReadOnlyRootFilesystem != nil {
			in, out := &in.ReadOnlyRootFilesystem, &out.ReadOnlyRootFilesystem
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1SerializedReference ...
func DeepCopyv1SerializedReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SerializedReference)
		out := out.(*SerializedReference)
		*out = *in
		return nil
	}
}

// DeepCopyv1Service ...
func DeepCopyv1Service(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Service)
		out := out.(*Service)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if err := DeepCopyv1ServiceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopyv1ServiceStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1ServiceAccount ...
func DeepCopyv1ServiceAccount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceAccount)
		out := out.(*ServiceAccount)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err == nil {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		} else {
			return err
		}
		if in.Secrets != nil {
			in, out := &in.Secrets, &out.Secrets
			*out = make([]ObjectReference, len(*in))
			copy(*out, *in)
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]LocalObjectReference, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ServiceAccountList ...
func DeepCopyv1ServiceAccountList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceAccountList)
		out := out.(*ServiceAccountList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ServiceAccount, len(*in))
			for i := range *in {
				if err := DeepCopyv1ServiceAccount(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ServiceList ...
func DeepCopyv1ServiceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceList)
		out := out.(*ServiceList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Service, len(*in))
			for i := range *in {
				if err := DeepCopyv1Service(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

// DeepCopyv1ServicePort ...
func DeepCopyv1ServicePort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServicePort)
		out := out.(*ServicePort)
		*out = *in
		return nil
	}
}

// DeepCopyv1ServiceProxyOptions ...
func DeepCopyv1ServiceProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceProxyOptions)
		out := out.(*ServiceProxyOptions)
		*out = *in
		return nil
	}
}

// DeepCopyv1ServiceSpec ...
func DeepCopyv1ServiceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceSpec)
		out := out.(*ServiceSpec)
		*out = *in
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]ServicePort, len(*in))
			copy(*out, *in)
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.ExternalIPs != nil {
			in, out := &in.ExternalIPs, &out.ExternalIPs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.DeprecatedPublicIPs != nil {
			in, out := &in.DeprecatedPublicIPs, &out.DeprecatedPublicIPs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.LoadBalancerSourceRanges != nil {
			in, out := &in.LoadBalancerSourceRanges, &out.LoadBalancerSourceRanges
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

// DeepCopyv1ServiceStatus ...
func DeepCopyv1ServiceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceStatus)
		out := out.(*ServiceStatus)
		*out = *in
		if err := DeepCopyv1LoadBalancerStatus(&in.LoadBalancer, &out.LoadBalancer, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1Sysctl ...
func DeepCopyv1Sysctl(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Sysctl)
		out := out.(*Sysctl)
		*out = *in
		return nil
	}
}

// DeepCopyv1TCPSocketAction ...
func DeepCopyv1TCPSocketAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TCPSocketAction)
		out := out.(*TCPSocketAction)
		*out = *in
		return nil
	}
}

// DeepCopyv1Taint ...
func DeepCopyv1Taint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Taint)
		out := out.(*Taint)
		*out = *in
		out.TimeAdded = in.TimeAdded.DeepCopy()
		return nil
	}
}

// DeepCopyv1Toleration ...
func DeepCopyv1Toleration(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Toleration)
		out := out.(*Toleration)
		*out = *in
		if in.TolerationSeconds != nil {
			in, out := &in.TolerationSeconds, &out.TolerationSeconds
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1Volume ...
func DeepCopyv1Volume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Volume)
		out := out.(*Volume)
		*out = *in
		if err := DeepCopyv1VolumeSource(&in.VolumeSource, &out.VolumeSource, c); err != nil {
			return err
		}
		return nil
	}
}

// DeepCopyv1VolumeMount ...
func DeepCopyv1VolumeMount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VolumeMount)
		out := out.(*VolumeMount)
		*out = *in
		return nil
	}
}

// DeepCopyv1VolumeSource ...
func DeepCopyv1VolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VolumeSource)
		out := out.(*VolumeSource)
		*out = *in
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(HostPathVolumeSource)
			**out = **in
		}
		if in.EmptyDir != nil {
			in, out := &in.EmptyDir, &out.EmptyDir
			*out = new(EmptyDirVolumeSource)
			**out = **in
		}
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(GCEPersistentDiskVolumeSource)
			**out = **in
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(AWSElasticBlockStoreVolumeSource)
			**out = **in
		}
		if in.GitRepo != nil {
			in, out := &in.GitRepo, &out.GitRepo
			*out = new(GitRepoVolumeSource)
			**out = **in
		}
		if in.Secret != nil {
			in, out := &in.Secret, &out.Secret
			*out = new(SecretVolumeSource)
			if err := DeepCopyv1SecretVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(NFSVolumeSource)
			**out = **in
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(ISCSIVolumeSource)
			**out = **in
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(GlusterfsVolumeSource)
			**out = **in
		}
		if in.PersistentVolumeClaim != nil {
			in, out := &in.PersistentVolumeClaim, &out.PersistentVolumeClaim
			*out = new(PersistentVolumeClaimVolumeSource)
			**out = **in
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(RBDVolumeSource)
			if err := DeepCopyv1RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(FlexVolumeSource)
			if err := DeepCopyv1FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(CinderVolumeSource)
			**out = **in
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(CephFSVolumeSource)
			if err := DeepCopyv1CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(FlockerVolumeSource)
			**out = **in
		}
		if in.DownwardAPI != nil {
			in, out := &in.DownwardAPI, &out.DownwardAPI
			*out = new(DownwardAPIVolumeSource)
			if err := DeepCopyv1DownwardAPIVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(FCVolumeSource)
			if err := DeepCopyv1FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(AzureFileVolumeSource)
			**out = **in
		}
		if in.ConfigMap != nil {
			in, out := &in.ConfigMap, &out.ConfigMap
			*out = new(ConfigMapVolumeSource)
			if err := DeepCopyv1ConfigMapVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(VsphereVirtualDiskVolumeSource)
			**out = **in
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(QuobyteVolumeSource)
			**out = **in
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(AzureDiskVolumeSource)
			if err := DeepCopyv1AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(PhotonPersistentDiskVolumeSource)
			**out = **in
		}
		return nil
	}
}

// DeepCopyv1VsphereVirtualDiskVolumeSource ...
func DeepCopyv1VsphereVirtualDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VsphereVirtualDiskVolumeSource)
		out := out.(*VsphereVirtualDiskVolumeSource)
		*out = *in
		return nil
	}
}

// DeepCopyv1WeightedPodAffinityTerm ...
func DeepCopyv1WeightedPodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*WeightedPodAffinityTerm)
		out := out.(*WeightedPodAffinityTerm)
		*out = *in
		if err := DeepCopyv1PodAffinityTerm(&in.PodAffinityTerm, &out.PodAffinityTerm, c); err != nil {
			return err
		}
		return nil
	}
}
