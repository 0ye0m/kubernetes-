// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: /Users/bburns/gopath/src/github.com/GoogleCloudPlatform/kubernetes/_tmp/api/v1/types.go
// DO NOT EDIT!

package v1

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/GoogleCloudPlatform/kubernetes/pkg/runtime"
	"github.com/GoogleCloudPlatform/kubernetes/pkg/types"
	"github.com/GoogleCloudPlatform/kubernetes/pkg/util"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"reflect"
)

func (mj *AWSElasticBlockStoreVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AWSElasticBlockStoreVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "volumeID":`)
	fflib.WriteJsonString(buf, string(mj.VolumeID))
	buf.WriteString(`,"fsType":`)
	fflib.WriteJsonString(buf, string(mj.FSType))
	buf.WriteByte(',')
	if mj.Partition != 0 {
		buf.WriteString(`"partition":`)
		fflib.FormatBits2(buf, uint64(mj.Partition), 10, mj.Partition < 0)
		buf.WriteByte(',')
	}
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AWSElasticBlockStoreVolumeSourcebase = iota
	ffj_t_AWSElasticBlockStoreVolumeSourceno_such_key

	ffj_t_AWSElasticBlockStoreVolumeSource_VolumeID

	ffj_t_AWSElasticBlockStoreVolumeSource_FSType

	ffj_t_AWSElasticBlockStoreVolumeSource_Partition

	ffj_t_AWSElasticBlockStoreVolumeSource_ReadOnly
)

var ffj_key_AWSElasticBlockStoreVolumeSource_VolumeID = []byte("volumeID")

var ffj_key_AWSElasticBlockStoreVolumeSource_FSType = []byte("fsType")

var ffj_key_AWSElasticBlockStoreVolumeSource_Partition = []byte("partition")

var ffj_key_AWSElasticBlockStoreVolumeSource_ReadOnly = []byte("readOnly")

func (uj *AWSElasticBlockStoreVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AWSElasticBlockStoreVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AWSElasticBlockStoreVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AWSElasticBlockStoreVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_AWSElasticBlockStoreVolumeSource_FSType, kn) {
						currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_FSType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AWSElasticBlockStoreVolumeSource_Partition, kn) {
						currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_Partition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_AWSElasticBlockStoreVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_AWSElasticBlockStoreVolumeSource_VolumeID, kn) {
						currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_VolumeID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_AWSElasticBlockStoreVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AWSElasticBlockStoreVolumeSource_Partition, kn) {
					currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_Partition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AWSElasticBlockStoreVolumeSource_FSType, kn) {
					currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_FSType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AWSElasticBlockStoreVolumeSource_VolumeID, kn) {
					currentKey = ffj_t_AWSElasticBlockStoreVolumeSource_VolumeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AWSElasticBlockStoreVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AWSElasticBlockStoreVolumeSource_VolumeID:
					goto handle_VolumeID

				case ffj_t_AWSElasticBlockStoreVolumeSource_FSType:
					goto handle_FSType

				case ffj_t_AWSElasticBlockStoreVolumeSource_Partition:
					goto handle_Partition

				case ffj_t_AWSElasticBlockStoreVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_AWSElasticBlockStoreVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_VolumeID:

	/* handler: uj.VolumeID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.VolumeID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FSType:

	/* handler: uj.FSType type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FSType = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Partition:

	/* handler: uj.Partition type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Partition = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Binding) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Binding) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"target":`)

	{
		err = mj.Target.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}
	}

	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Bindingbase = iota
	ffj_t_Bindingno_such_key

	ffj_t_Binding_ObjectMeta

	ffj_t_Binding_Target

	ffj_t_Binding_Kind

	ffj_t_Binding_APIVersion
)

var ffj_key_Binding_ObjectMeta = []byte("metadata")

var ffj_key_Binding_Target = []byte("target")

var ffj_key_Binding_Kind = []byte("kind")

var ffj_key_Binding_APIVersion = []byte("apiVersion")

func (uj *Binding) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Binding) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Bindingbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Bindingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Binding_APIVersion, kn) {
						currentKey = ffj_t_Binding_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Binding_Kind, kn) {
						currentKey = ffj_t_Binding_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Binding_ObjectMeta, kn) {
						currentKey = ffj_t_Binding_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Binding_Target, kn) {
						currentKey = ffj_t_Binding_Target
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Binding_APIVersion, kn) {
					currentKey = ffj_t_Binding_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Binding_Kind, kn) {
					currentKey = ffj_t_Binding_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Binding_Target, kn) {
					currentKey = ffj_t_Binding_Target
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Binding_ObjectMeta, kn) {
					currentKey = ffj_t_Binding_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Bindingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Binding_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Binding_Target:
					goto handle_Target

				case ffj_t_Binding_Kind:
					goto handle_Kind

				case ffj_t_Binding_APIVersion:
					goto handle_APIVersion

				case ffj_t_Bindingno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Target:

	/* handler: uj.Target type=v1.ObjectReference kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Target.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Capabilities) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Capabilities) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Add) != 0 {
		buf.WriteString(`"add":`)
		if mj.Add != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Add {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Drop) != 0 {
		buf.WriteString(`"drop":`)
		if mj.Drop != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Drop {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Capabilitiesbase = iota
	ffj_t_Capabilitiesno_such_key

	ffj_t_Capabilities_Add

	ffj_t_Capabilities_Drop
)

var ffj_key_Capabilities_Add = []byte("add")

var ffj_key_Capabilities_Drop = []byte("drop")

func (uj *Capabilities) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Capabilities) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Capabilitiesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Capabilitiesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Capabilities_Add, kn) {
						currentKey = ffj_t_Capabilities_Add
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Capabilities_Drop, kn) {
						currentKey = ffj_t_Capabilities_Drop
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Capabilities_Drop, kn) {
					currentKey = ffj_t_Capabilities_Drop
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Capabilities_Add, kn) {
					currentKey = ffj_t_Capabilities_Add
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Capabilitiesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Capabilities_Add:
					goto handle_Add

				case ffj_t_Capabilities_Drop:
					goto handle_Drop

				case ffj_t_Capabilitiesno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Add:

	/* handler: uj.Add type=[]v1.Capability kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Add = nil
		} else {

			uj.Add = make([]Capability, 0)

			wantVal := true

			for {

				var v Capability

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Capability kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Capability", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = Capability(fs.Output.String())

					}
				}

				uj.Add = append(uj.Add, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Drop:

	/* handler: uj.Drop type=[]v1.Capability kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Drop = nil
		} else {

			uj.Drop = make([]Capability, 0)

			wantVal := true

			for {

				var v Capability

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Capability kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Capability", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = Capability(fs.Output.String())

					}
				}

				uj.Drop = append(uj.Drop, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ComponentCondition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ComponentCondition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(mj.Status))
	buf.WriteByte(',')
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if len(mj.Error) != 0 {
		buf.WriteString(`"error":`)
		fflib.WriteJsonString(buf, string(mj.Error))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ComponentConditionbase = iota
	ffj_t_ComponentConditionno_such_key

	ffj_t_ComponentCondition_Type

	ffj_t_ComponentCondition_Status

	ffj_t_ComponentCondition_Message

	ffj_t_ComponentCondition_Error
)

var ffj_key_ComponentCondition_Type = []byte("type")

var ffj_key_ComponentCondition_Status = []byte("status")

var ffj_key_ComponentCondition_Message = []byte("message")

var ffj_key_ComponentCondition_Error = []byte("error")

func (uj *ComponentCondition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ComponentCondition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ComponentConditionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ComponentConditionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_ComponentCondition_Error, kn) {
						currentKey = ffj_t_ComponentCondition_Error
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ComponentCondition_Message, kn) {
						currentKey = ffj_t_ComponentCondition_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ComponentCondition_Status, kn) {
						currentKey = ffj_t_ComponentCondition_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ComponentCondition_Type, kn) {
						currentKey = ffj_t_ComponentCondition_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ComponentCondition_Error, kn) {
					currentKey = ffj_t_ComponentCondition_Error
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ComponentCondition_Message, kn) {
					currentKey = ffj_t_ComponentCondition_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ComponentCondition_Status, kn) {
					currentKey = ffj_t_ComponentCondition_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ComponentCondition_Type, kn) {
					currentKey = ffj_t_ComponentCondition_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ComponentConditionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ComponentCondition_Type:
					goto handle_Type

				case ffj_t_ComponentCondition_Status:
					goto handle_Status

				case ffj_t_ComponentCondition_Message:
					goto handle_Message

				case ffj_t_ComponentCondition_Error:
					goto handle_Error

				case ffj_t_ComponentConditionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=v1.ComponentConditionType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ComponentConditionType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = ComponentConditionType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.ConditionStatus kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ConditionStatus", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Status = ConditionStatus(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Error:

	/* handler: uj.Error type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Error = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ComponentStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ComponentStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Conditions) != 0 {
		buf.WriteString(`"conditions":`)
		if mj.Conditions != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Conditions {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ComponentStatusbase = iota
	ffj_t_ComponentStatusno_such_key

	ffj_t_ComponentStatus_ObjectMeta

	ffj_t_ComponentStatus_Conditions

	ffj_t_ComponentStatus_Kind

	ffj_t_ComponentStatus_APIVersion
)

var ffj_key_ComponentStatus_ObjectMeta = []byte("metadata")

var ffj_key_ComponentStatus_Conditions = []byte("conditions")

var ffj_key_ComponentStatus_Kind = []byte("kind")

var ffj_key_ComponentStatus_APIVersion = []byte("apiVersion")

func (uj *ComponentStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ComponentStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ComponentStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ComponentStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ComponentStatus_APIVersion, kn) {
						currentKey = ffj_t_ComponentStatus_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ComponentStatus_Conditions, kn) {
						currentKey = ffj_t_ComponentStatus_Conditions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ComponentStatus_Kind, kn) {
						currentKey = ffj_t_ComponentStatus_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ComponentStatus_ObjectMeta, kn) {
						currentKey = ffj_t_ComponentStatus_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ComponentStatus_APIVersion, kn) {
					currentKey = ffj_t_ComponentStatus_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ComponentStatus_Kind, kn) {
					currentKey = ffj_t_ComponentStatus_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ComponentStatus_Conditions, kn) {
					currentKey = ffj_t_ComponentStatus_Conditions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ComponentStatus_ObjectMeta, kn) {
					currentKey = ffj_t_ComponentStatus_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ComponentStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ComponentStatus_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_ComponentStatus_Conditions:
					goto handle_Conditions

				case ffj_t_ComponentStatus_Kind:
					goto handle_Kind

				case ffj_t_ComponentStatus_APIVersion:
					goto handle_APIVersion

				case ffj_t_ComponentStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Conditions:

	/* handler: uj.Conditions type=[]v1.ComponentCondition kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Conditions = nil
		} else {

			uj.Conditions = make([]ComponentCondition, 0)

			wantVal := true

			for {

				var v ComponentCondition

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ComponentCondition kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Conditions = append(uj.Conditions, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ComponentStatusList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ComponentStatusList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ComponentStatusListbase = iota
	ffj_t_ComponentStatusListno_such_key

	ffj_t_ComponentStatusList_ListMeta

	ffj_t_ComponentStatusList_Items

	ffj_t_ComponentStatusList_Kind

	ffj_t_ComponentStatusList_APIVersion
)

var ffj_key_ComponentStatusList_ListMeta = []byte("metadata")

var ffj_key_ComponentStatusList_Items = []byte("items")

var ffj_key_ComponentStatusList_Kind = []byte("kind")

var ffj_key_ComponentStatusList_APIVersion = []byte("apiVersion")

func (uj *ComponentStatusList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ComponentStatusList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ComponentStatusListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ComponentStatusListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ComponentStatusList_APIVersion, kn) {
						currentKey = ffj_t_ComponentStatusList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ComponentStatusList_Items, kn) {
						currentKey = ffj_t_ComponentStatusList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ComponentStatusList_Kind, kn) {
						currentKey = ffj_t_ComponentStatusList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ComponentStatusList_ListMeta, kn) {
						currentKey = ffj_t_ComponentStatusList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ComponentStatusList_APIVersion, kn) {
					currentKey = ffj_t_ComponentStatusList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ComponentStatusList_Kind, kn) {
					currentKey = ffj_t_ComponentStatusList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ComponentStatusList_Items, kn) {
					currentKey = ffj_t_ComponentStatusList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ComponentStatusList_ListMeta, kn) {
					currentKey = ffj_t_ComponentStatusList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ComponentStatusListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ComponentStatusList_ListMeta:
					goto handle_ListMeta

				case ffj_t_ComponentStatusList_Items:
					goto handle_Items

				case ffj_t_ComponentStatusList_Kind:
					goto handle_Kind

				case ffj_t_ComponentStatusList_APIVersion:
					goto handle_APIVersion

				case ffj_t_ComponentStatusListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.ComponentStatus kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]ComponentStatus, 0)

			wantVal := true

			for {

				var v ComponentStatus

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ComponentStatus kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Container) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Container) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if len(mj.Image) != 0 {
		buf.WriteString(`"image":`)
		fflib.WriteJsonString(buf, string(mj.Image))
		buf.WriteByte(',')
	}
	if len(mj.Command) != 0 {
		buf.WriteString(`"command":`)
		if mj.Command != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Command {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Args) != 0 {
		buf.WriteString(`"args":`)
		if mj.Args != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Args {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.WorkingDir) != 0 {
		buf.WriteString(`"workingDir":`)
		fflib.WriteJsonString(buf, string(mj.WorkingDir))
		buf.WriteByte(',')
	}
	if len(mj.Ports) != 0 {
		buf.WriteString(`"ports":`)
		if mj.Ports != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Ports {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Env) != 0 {
		buf.WriteString(`"env":`)
		if mj.Env != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Env {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"resources":`)

		{
			err = mj.Resources.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.VolumeMounts) != 0 {
		buf.WriteString(`"volumeMounts":`)
		if mj.VolumeMounts != nil {
			buf.WriteString(`[`)
			for i, v := range mj.VolumeMounts {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.LivenessProbe != nil {
		if true {
			buf.WriteString(`"livenessProbe":`)

			{
				err = mj.LivenessProbe.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.ReadinessProbe != nil {
		if true {
			buf.WriteString(`"readinessProbe":`)

			{
				err = mj.ReadinessProbe.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Lifecycle != nil {
		if true {
			buf.WriteString(`"lifecycle":`)

			{
				err = mj.Lifecycle.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if len(mj.TerminationMessagePath) != 0 {
		buf.WriteString(`"terminationMessagePath":`)
		fflib.WriteJsonString(buf, string(mj.TerminationMessagePath))
		buf.WriteByte(',')
	}
	if len(mj.ImagePullPolicy) != 0 {
		buf.WriteString(`"imagePullPolicy":`)
		fflib.WriteJsonString(buf, string(mj.ImagePullPolicy))
		buf.WriteByte(',')
	}
	if mj.SecurityContext != nil {
		if true {
			buf.WriteString(`"securityContext":`)

			{
				err = mj.SecurityContext.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Containerbase = iota
	ffj_t_Containerno_such_key

	ffj_t_Container_Name

	ffj_t_Container_Image

	ffj_t_Container_Command

	ffj_t_Container_Args

	ffj_t_Container_WorkingDir

	ffj_t_Container_Ports

	ffj_t_Container_Env

	ffj_t_Container_Resources

	ffj_t_Container_VolumeMounts

	ffj_t_Container_LivenessProbe

	ffj_t_Container_ReadinessProbe

	ffj_t_Container_Lifecycle

	ffj_t_Container_TerminationMessagePath

	ffj_t_Container_ImagePullPolicy

	ffj_t_Container_SecurityContext
)

var ffj_key_Container_Name = []byte("name")

var ffj_key_Container_Image = []byte("image")

var ffj_key_Container_Command = []byte("command")

var ffj_key_Container_Args = []byte("args")

var ffj_key_Container_WorkingDir = []byte("workingDir")

var ffj_key_Container_Ports = []byte("ports")

var ffj_key_Container_Env = []byte("env")

var ffj_key_Container_Resources = []byte("resources")

var ffj_key_Container_VolumeMounts = []byte("volumeMounts")

var ffj_key_Container_LivenessProbe = []byte("livenessProbe")

var ffj_key_Container_ReadinessProbe = []byte("readinessProbe")

var ffj_key_Container_Lifecycle = []byte("lifecycle")

var ffj_key_Container_TerminationMessagePath = []byte("terminationMessagePath")

var ffj_key_Container_ImagePullPolicy = []byte("imagePullPolicy")

var ffj_key_Container_SecurityContext = []byte("securityContext")

func (uj *Container) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Container) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Containerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Containerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Container_Args, kn) {
						currentKey = ffj_t_Container_Args
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Container_Command, kn) {
						currentKey = ffj_t_Container_Command
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Container_Env, kn) {
						currentKey = ffj_t_Container_Env
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Container_Image, kn) {
						currentKey = ffj_t_Container_Image
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Container_ImagePullPolicy, kn) {
						currentKey = ffj_t_Container_ImagePullPolicy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Container_LivenessProbe, kn) {
						currentKey = ffj_t_Container_LivenessProbe
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Container_Lifecycle, kn) {
						currentKey = ffj_t_Container_Lifecycle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Container_Name, kn) {
						currentKey = ffj_t_Container_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Container_Ports, kn) {
						currentKey = ffj_t_Container_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Container_Resources, kn) {
						currentKey = ffj_t_Container_Resources
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Container_ReadinessProbe, kn) {
						currentKey = ffj_t_Container_ReadinessProbe
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Container_SecurityContext, kn) {
						currentKey = ffj_t_Container_SecurityContext
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Container_TerminationMessagePath, kn) {
						currentKey = ffj_t_Container_TerminationMessagePath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Container_VolumeMounts, kn) {
						currentKey = ffj_t_Container_VolumeMounts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_Container_WorkingDir, kn) {
						currentKey = ffj_t_Container_WorkingDir
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Container_SecurityContext, kn) {
					currentKey = ffj_t_Container_SecurityContext
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Container_ImagePullPolicy, kn) {
					currentKey = ffj_t_Container_ImagePullPolicy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_TerminationMessagePath, kn) {
					currentKey = ffj_t_Container_TerminationMessagePath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Container_Lifecycle, kn) {
					currentKey = ffj_t_Container_Lifecycle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_ReadinessProbe, kn) {
					currentKey = ffj_t_Container_ReadinessProbe
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_LivenessProbe, kn) {
					currentKey = ffj_t_Container_LivenessProbe
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_VolumeMounts, kn) {
					currentKey = ffj_t_Container_VolumeMounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_Resources, kn) {
					currentKey = ffj_t_Container_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Container_Env, kn) {
					currentKey = ffj_t_Container_Env
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_Ports, kn) {
					currentKey = ffj_t_Container_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_WorkingDir, kn) {
					currentKey = ffj_t_Container_WorkingDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Container_Args, kn) {
					currentKey = ffj_t_Container_Args
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Container_Command, kn) {
					currentKey = ffj_t_Container_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Container_Image, kn) {
					currentKey = ffj_t_Container_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Container_Name, kn) {
					currentKey = ffj_t_Container_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Containerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Container_Name:
					goto handle_Name

				case ffj_t_Container_Image:
					goto handle_Image

				case ffj_t_Container_Command:
					goto handle_Command

				case ffj_t_Container_Args:
					goto handle_Args

				case ffj_t_Container_WorkingDir:
					goto handle_WorkingDir

				case ffj_t_Container_Ports:
					goto handle_Ports

				case ffj_t_Container_Env:
					goto handle_Env

				case ffj_t_Container_Resources:
					goto handle_Resources

				case ffj_t_Container_VolumeMounts:
					goto handle_VolumeMounts

				case ffj_t_Container_LivenessProbe:
					goto handle_LivenessProbe

				case ffj_t_Container_ReadinessProbe:
					goto handle_ReadinessProbe

				case ffj_t_Container_Lifecycle:
					goto handle_Lifecycle

				case ffj_t_Container_TerminationMessagePath:
					goto handle_TerminationMessagePath

				case ffj_t_Container_ImagePullPolicy:
					goto handle_ImagePullPolicy

				case ffj_t_Container_SecurityContext:
					goto handle_SecurityContext

				case ffj_t_Containerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: uj.Image type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Image = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=[]string kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Command = nil
		} else {

			uj.Command = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = string(fs.Output.String())

					}
				}

				uj.Command = append(uj.Command, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Args:

	/* handler: uj.Args type=[]string kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Args = nil
		} else {

			uj.Args = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = string(fs.Output.String())

					}
				}

				uj.Args = append(uj.Args, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkingDir:

	/* handler: uj.WorkingDir type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.WorkingDir = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ports:

	/* handler: uj.Ports type=[]v1.ContainerPort kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ports = nil
		} else {

			uj.Ports = make([]ContainerPort, 0)

			wantVal := true

			for {

				var v ContainerPort

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ContainerPort kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Ports = append(uj.Ports, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Env:

	/* handler: uj.Env type=[]v1.EnvVar kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Env = nil
		} else {

			uj.Env = make([]EnvVar, 0)

			wantVal := true

			for {

				var v EnvVar

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.EnvVar kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Env = append(uj.Env, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=v1.ResourceRequirements kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Resources.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VolumeMounts:

	/* handler: uj.VolumeMounts type=[]v1.VolumeMount kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.VolumeMounts = nil
		} else {

			uj.VolumeMounts = make([]VolumeMount, 0)

			wantVal := true

			for {

				var v VolumeMount

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.VolumeMount kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.VolumeMounts = append(uj.VolumeMounts, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LivenessProbe:

	/* handler: uj.LivenessProbe type=v1.Probe kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.LivenessProbe = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.LivenessProbe == nil {
			uj.LivenessProbe = new(Probe)
		}

		err = uj.LivenessProbe.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadinessProbe:

	/* handler: uj.ReadinessProbe type=v1.Probe kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ReadinessProbe = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReadinessProbe == nil {
			uj.ReadinessProbe = new(Probe)
		}

		err = uj.ReadinessProbe.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lifecycle:

	/* handler: uj.Lifecycle type=v1.Lifecycle kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Lifecycle = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Lifecycle == nil {
			uj.Lifecycle = new(Lifecycle)
		}

		err = uj.Lifecycle.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TerminationMessagePath:

	/* handler: uj.TerminationMessagePath type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.TerminationMessagePath = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImagePullPolicy:

	/* handler: uj.ImagePullPolicy type=v1.PullPolicy kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PullPolicy", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ImagePullPolicy = PullPolicy(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SecurityContext:

	/* handler: uj.SecurityContext type=v1.SecurityContext kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.SecurityContext = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.SecurityContext == nil {
			uj.SecurityContext = new(SecurityContext)
		}

		err = uj.SecurityContext.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerPort) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerPort) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	if mj.HostPort != 0 {
		buf.WriteString(`"hostPort":`)
		fflib.FormatBits2(buf, uint64(mj.HostPort), 10, mj.HostPort < 0)
		buf.WriteByte(',')
	}
	buf.WriteString(`"containerPort":`)
	fflib.FormatBits2(buf, uint64(mj.ContainerPort), 10, mj.ContainerPort < 0)
	buf.WriteByte(',')
	if len(mj.Protocol) != 0 {
		buf.WriteString(`"protocol":`)
		fflib.WriteJsonString(buf, string(mj.Protocol))
		buf.WriteByte(',')
	}
	if len(mj.HostIP) != 0 {
		buf.WriteString(`"hostIP":`)
		fflib.WriteJsonString(buf, string(mj.HostIP))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerPortbase = iota
	ffj_t_ContainerPortno_such_key

	ffj_t_ContainerPort_Name

	ffj_t_ContainerPort_HostPort

	ffj_t_ContainerPort_ContainerPort

	ffj_t_ContainerPort_Protocol

	ffj_t_ContainerPort_HostIP
)

var ffj_key_ContainerPort_Name = []byte("name")

var ffj_key_ContainerPort_HostPort = []byte("hostPort")

var ffj_key_ContainerPort_ContainerPort = []byte("containerPort")

var ffj_key_ContainerPort_Protocol = []byte("protocol")

var ffj_key_ContainerPort_HostIP = []byte("hostIP")

func (uj *ContainerPort) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerPort) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerPortbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerPortno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ContainerPort_ContainerPort, kn) {
						currentKey = ffj_t_ContainerPort_ContainerPort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_ContainerPort_HostPort, kn) {
						currentKey = ffj_t_ContainerPort_HostPort
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerPort_HostIP, kn) {
						currentKey = ffj_t_ContainerPort_HostIP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ContainerPort_Name, kn) {
						currentKey = ffj_t_ContainerPort_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ContainerPort_Protocol, kn) {
						currentKey = ffj_t_ContainerPort_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ContainerPort_HostIP, kn) {
					currentKey = ffj_t_ContainerPort_HostIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerPort_Protocol, kn) {
					currentKey = ffj_t_ContainerPort_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerPort_ContainerPort, kn) {
					currentKey = ffj_t_ContainerPort_ContainerPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerPort_HostPort, kn) {
					currentKey = ffj_t_ContainerPort_HostPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerPort_Name, kn) {
					currentKey = ffj_t_ContainerPort_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerPortno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerPort_Name:
					goto handle_Name

				case ffj_t_ContainerPort_HostPort:
					goto handle_HostPort

				case ffj_t_ContainerPort_ContainerPort:
					goto handle_ContainerPort

				case ffj_t_ContainerPort_Protocol:
					goto handle_Protocol

				case ffj_t_ContainerPort_HostIP:
					goto handle_HostIP

				case ffj_t_ContainerPortno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostPort:

	/* handler: uj.HostPort type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.HostPort = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerPort:

	/* handler: uj.ContainerPort type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ContainerPort = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=v1.Protocol kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Protocol", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Protocol = Protocol(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostIP:

	/* handler: uj.HostIP type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.HostIP = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerState) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerState) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Waiting != nil {
		if true {
			buf.WriteString(`"waiting":`)

			{
				err = mj.Waiting.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Running != nil {
		if true {
			buf.WriteString(`"running":`)

			{
				err = mj.Running.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Terminated != nil {
		if true {
			buf.WriteString(`"terminated":`)

			{
				err = mj.Terminated.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerStatebase = iota
	ffj_t_ContainerStateno_such_key

	ffj_t_ContainerState_Waiting

	ffj_t_ContainerState_Running

	ffj_t_ContainerState_Terminated
)

var ffj_key_ContainerState_Waiting = []byte("waiting")

var ffj_key_ContainerState_Running = []byte("running")

var ffj_key_ContainerState_Terminated = []byte("terminated")

func (uj *ContainerState) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerState) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerStatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerStateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_ContainerState_Running, kn) {
						currentKey = ffj_t_ContainerState_Running
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ContainerState_Terminated, kn) {
						currentKey = ffj_t_ContainerState_Terminated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_ContainerState_Waiting, kn) {
						currentKey = ffj_t_ContainerState_Waiting
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerState_Terminated, kn) {
					currentKey = ffj_t_ContainerState_Terminated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerState_Running, kn) {
					currentKey = ffj_t_ContainerState_Running
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerState_Waiting, kn) {
					currentKey = ffj_t_ContainerState_Waiting
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerStateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerState_Waiting:
					goto handle_Waiting

				case ffj_t_ContainerState_Running:
					goto handle_Running

				case ffj_t_ContainerState_Terminated:
					goto handle_Terminated

				case ffj_t_ContainerStateno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Waiting:

	/* handler: uj.Waiting type=v1.ContainerStateWaiting kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Waiting = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Waiting == nil {
			uj.Waiting = new(ContainerStateWaiting)
		}

		err = uj.Waiting.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Running:

	/* handler: uj.Running type=v1.ContainerStateRunning kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Running = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Running == nil {
			uj.Running = new(ContainerStateRunning)
		}

		err = uj.Running.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Terminated:

	/* handler: uj.Terminated type=v1.ContainerStateTerminated kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Terminated = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Terminated == nil {
			uj.Terminated = new(ContainerStateTerminated)
		}

		err = uj.Terminated.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerStateRunning) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerStateRunning) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"startedAt":`)

		{
			obj, err = mj.StartedAt.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerStateRunningbase = iota
	ffj_t_ContainerStateRunningno_such_key

	ffj_t_ContainerStateRunning_StartedAt
)

var ffj_key_ContainerStateRunning_StartedAt = []byte("startedAt")

func (uj *ContainerStateRunning) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerStateRunning) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerStateRunningbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerStateRunningno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffj_key_ContainerStateRunning_StartedAt, kn) {
						currentKey = ffj_t_ContainerStateRunning_StartedAt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateRunning_StartedAt, kn) {
					currentKey = ffj_t_ContainerStateRunning_StartedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerStateRunningno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerStateRunning_StartedAt:
					goto handle_StartedAt

				case ffj_t_ContainerStateRunningno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_StartedAt:

	/* handler: uj.StartedAt type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.StartedAt.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerStateTerminated) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerStateTerminated) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "exitCode":`)
	fflib.FormatBits2(buf, uint64(mj.ExitCode), 10, mj.ExitCode < 0)
	buf.WriteByte(',')
	if mj.Signal != 0 {
		buf.WriteString(`"signal":`)
		fflib.FormatBits2(buf, uint64(mj.Signal), 10, mj.Signal < 0)
		buf.WriteByte(',')
	}
	if len(mj.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Reason))
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"startedAt":`)

		{
			obj, err = mj.StartedAt.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"finishedAt":`)

		{
			obj, err = mj.FinishedAt.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if len(mj.ContainerID) != 0 {
		buf.WriteString(`"containerID":`)
		fflib.WriteJsonString(buf, string(mj.ContainerID))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerStateTerminatedbase = iota
	ffj_t_ContainerStateTerminatedno_such_key

	ffj_t_ContainerStateTerminated_ExitCode

	ffj_t_ContainerStateTerminated_Signal

	ffj_t_ContainerStateTerminated_Reason

	ffj_t_ContainerStateTerminated_Message

	ffj_t_ContainerStateTerminated_StartedAt

	ffj_t_ContainerStateTerminated_FinishedAt

	ffj_t_ContainerStateTerminated_ContainerID
)

var ffj_key_ContainerStateTerminated_ExitCode = []byte("exitCode")

var ffj_key_ContainerStateTerminated_Signal = []byte("signal")

var ffj_key_ContainerStateTerminated_Reason = []byte("reason")

var ffj_key_ContainerStateTerminated_Message = []byte("message")

var ffj_key_ContainerStateTerminated_StartedAt = []byte("startedAt")

var ffj_key_ContainerStateTerminated_FinishedAt = []byte("finishedAt")

var ffj_key_ContainerStateTerminated_ContainerID = []byte("containerID")

func (uj *ContainerStateTerminated) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerStateTerminated) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerStateTerminatedbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerStateTerminatedno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ContainerStateTerminated_ContainerID, kn) {
						currentKey = ffj_t_ContainerStateTerminated_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_ContainerStateTerminated_ExitCode, kn) {
						currentKey = ffj_t_ContainerStateTerminated_ExitCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ContainerStateTerminated_FinishedAt, kn) {
						currentKey = ffj_t_ContainerStateTerminated_FinishedAt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ContainerStateTerminated_Message, kn) {
						currentKey = ffj_t_ContainerStateTerminated_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ContainerStateTerminated_Reason, kn) {
						currentKey = ffj_t_ContainerStateTerminated_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ContainerStateTerminated_Signal, kn) {
						currentKey = ffj_t_ContainerStateTerminated_Signal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerStateTerminated_StartedAt, kn) {
						currentKey = ffj_t_ContainerStateTerminated_StartedAt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStateTerminated_ContainerID, kn) {
					currentKey = ffj_t_ContainerStateTerminated_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateTerminated_FinishedAt, kn) {
					currentKey = ffj_t_ContainerStateTerminated_FinishedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateTerminated_StartedAt, kn) {
					currentKey = ffj_t_ContainerStateTerminated_StartedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateTerminated_Message, kn) {
					currentKey = ffj_t_ContainerStateTerminated_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateTerminated_Reason, kn) {
					currentKey = ffj_t_ContainerStateTerminated_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateTerminated_Signal, kn) {
					currentKey = ffj_t_ContainerStateTerminated_Signal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStateTerminated_ExitCode, kn) {
					currentKey = ffj_t_ContainerStateTerminated_ExitCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerStateTerminatedno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerStateTerminated_ExitCode:
					goto handle_ExitCode

				case ffj_t_ContainerStateTerminated_Signal:
					goto handle_Signal

				case ffj_t_ContainerStateTerminated_Reason:
					goto handle_Reason

				case ffj_t_ContainerStateTerminated_Message:
					goto handle_Message

				case ffj_t_ContainerStateTerminated_StartedAt:
					goto handle_StartedAt

				case ffj_t_ContainerStateTerminated_FinishedAt:
					goto handle_FinishedAt

				case ffj_t_ContainerStateTerminated_ContainerID:
					goto handle_ContainerID

				case ffj_t_ContainerStateTerminatedno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExitCode:

	/* handler: uj.ExitCode type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ExitCode = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Signal:

	/* handler: uj.Signal type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Signal = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Reason = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartedAt:

	/* handler: uj.StartedAt type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.StartedAt.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinishedAt:

	/* handler: uj.FinishedAt type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.FinishedAt.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerID:

	/* handler: uj.ContainerID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ContainerID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerStateWaiting) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerStateWaiting) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Reason))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerStateWaitingbase = iota
	ffj_t_ContainerStateWaitingno_such_key

	ffj_t_ContainerStateWaiting_Reason
)

var ffj_key_ContainerStateWaiting_Reason = []byte("reason")

func (uj *ContainerStateWaiting) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerStateWaiting) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerStateWaitingbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerStateWaitingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_ContainerStateWaiting_Reason, kn) {
						currentKey = ffj_t_ContainerStateWaiting_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ContainerStateWaiting_Reason, kn) {
					currentKey = ffj_t_ContainerStateWaiting_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerStateWaitingno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerStateWaiting_Reason:
					goto handle_Reason

				case ffj_t_ContainerStateWaitingno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Reason:

	/* handler: uj.Reason type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Reason = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ContainerStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ContainerStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"state":`)

		{
			err = mj.State.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"lastState":`)

		{
			err = mj.LastTerminationState.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if mj.Ready {
		buf.WriteString(`"ready":true`)
	} else {
		buf.WriteString(`"ready":false`)
	}
	buf.WriteString(`,"restartCount":`)
	fflib.FormatBits2(buf, uint64(mj.RestartCount), 10, mj.RestartCount < 0)
	buf.WriteString(`,"image":`)
	fflib.WriteJsonString(buf, string(mj.Image))
	buf.WriteString(`,"imageID":`)
	fflib.WriteJsonString(buf, string(mj.ImageID))
	buf.WriteByte(',')
	if len(mj.ContainerID) != 0 {
		buf.WriteString(`"containerID":`)
		fflib.WriteJsonString(buf, string(mj.ContainerID))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ContainerStatusbase = iota
	ffj_t_ContainerStatusno_such_key

	ffj_t_ContainerStatus_Name

	ffj_t_ContainerStatus_State

	ffj_t_ContainerStatus_LastTerminationState

	ffj_t_ContainerStatus_Ready

	ffj_t_ContainerStatus_RestartCount

	ffj_t_ContainerStatus_Image

	ffj_t_ContainerStatus_ImageID

	ffj_t_ContainerStatus_ContainerID
)

var ffj_key_ContainerStatus_Name = []byte("name")

var ffj_key_ContainerStatus_State = []byte("state")

var ffj_key_ContainerStatus_LastTerminationState = []byte("lastState")

var ffj_key_ContainerStatus_Ready = []byte("ready")

var ffj_key_ContainerStatus_RestartCount = []byte("restartCount")

var ffj_key_ContainerStatus_Image = []byte("image")

var ffj_key_ContainerStatus_ImageID = []byte("imageID")

var ffj_key_ContainerStatus_ContainerID = []byte("containerID")

func (uj *ContainerStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ContainerStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ContainerStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ContainerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ContainerStatus_ContainerID, kn) {
						currentKey = ffj_t_ContainerStatus_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ContainerStatus_Image, kn) {
						currentKey = ffj_t_ContainerStatus_Image
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerStatus_ImageID, kn) {
						currentKey = ffj_t_ContainerStatus_ImageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ContainerStatus_LastTerminationState, kn) {
						currentKey = ffj_t_ContainerStatus_LastTerminationState
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ContainerStatus_Name, kn) {
						currentKey = ffj_t_ContainerStatus_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ContainerStatus_Ready, kn) {
						currentKey = ffj_t_ContainerStatus_Ready
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ContainerStatus_RestartCount, kn) {
						currentKey = ffj_t_ContainerStatus_RestartCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ContainerStatus_State, kn) {
						currentKey = ffj_t_ContainerStatus_State
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStatus_ContainerID, kn) {
					currentKey = ffj_t_ContainerStatus_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStatus_ImageID, kn) {
					currentKey = ffj_t_ContainerStatus_ImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStatus_Image, kn) {
					currentKey = ffj_t_ContainerStatus_Image
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStatus_RestartCount, kn) {
					currentKey = ffj_t_ContainerStatus_RestartCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStatus_Ready, kn) {
					currentKey = ffj_t_ContainerStatus_Ready
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStatus_LastTerminationState, kn) {
					currentKey = ffj_t_ContainerStatus_LastTerminationState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ContainerStatus_State, kn) {
					currentKey = ffj_t_ContainerStatus_State
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ContainerStatus_Name, kn) {
					currentKey = ffj_t_ContainerStatus_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ContainerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ContainerStatus_Name:
					goto handle_Name

				case ffj_t_ContainerStatus_State:
					goto handle_State

				case ffj_t_ContainerStatus_LastTerminationState:
					goto handle_LastTerminationState

				case ffj_t_ContainerStatus_Ready:
					goto handle_Ready

				case ffj_t_ContainerStatus_RestartCount:
					goto handle_RestartCount

				case ffj_t_ContainerStatus_Image:
					goto handle_Image

				case ffj_t_ContainerStatus_ImageID:
					goto handle_ImageID

				case ffj_t_ContainerStatus_ContainerID:
					goto handle_ContainerID

				case ffj_t_ContainerStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: uj.State type=v1.ContainerState kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.State.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastTerminationState:

	/* handler: uj.LastTerminationState type=v1.ContainerState kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.LastTerminationState.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ready:

	/* handler: uj.Ready type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Ready = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Ready = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RestartCount:

	/* handler: uj.RestartCount type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.RestartCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Image:

	/* handler: uj.Image type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Image = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageID:

	/* handler: uj.ImageID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ImageID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerID:

	/* handler: uj.ContainerID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ContainerID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *DeleteOptions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *DeleteOptions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.GracePeriodSeconds != nil {
		buf.WriteString(`{ "gracePeriodSeconds":`)
		fflib.FormatBits2(buf, uint64(*mj.GracePeriodSeconds), 10, *mj.GracePeriodSeconds < 0)
	} else {
		buf.WriteString(`{ "gracePeriodSeconds":null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_DeleteOptionsbase = iota
	ffj_t_DeleteOptionsno_such_key

	ffj_t_DeleteOptions_GracePeriodSeconds

	ffj_t_DeleteOptions_Kind

	ffj_t_DeleteOptions_APIVersion
)

var ffj_key_DeleteOptions_GracePeriodSeconds = []byte("gracePeriodSeconds")

var ffj_key_DeleteOptions_Kind = []byte("kind")

var ffj_key_DeleteOptions_APIVersion = []byte("apiVersion")

func (uj *DeleteOptions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *DeleteOptions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_DeleteOptionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_DeleteOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_DeleteOptions_APIVersion, kn) {
						currentKey = ffj_t_DeleteOptions_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_DeleteOptions_GracePeriodSeconds, kn) {
						currentKey = ffj_t_DeleteOptions_GracePeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_DeleteOptions_Kind, kn) {
						currentKey = ffj_t_DeleteOptions_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_DeleteOptions_APIVersion, kn) {
					currentKey = ffj_t_DeleteOptions_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DeleteOptions_Kind, kn) {
					currentKey = ffj_t_DeleteOptions_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_DeleteOptions_GracePeriodSeconds, kn) {
					currentKey = ffj_t_DeleteOptions_GracePeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_DeleteOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_DeleteOptions_GracePeriodSeconds:
					goto handle_GracePeriodSeconds

				case ffj_t_DeleteOptions_Kind:
					goto handle_Kind

				case ffj_t_DeleteOptions_APIVersion:
					goto handle_APIVersion

				case ffj_t_DeleteOptionsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GracePeriodSeconds:

	/* handler: uj.GracePeriodSeconds type=int64 kind=int64 */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.GracePeriodSeconds = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.GracePeriodSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EmptyDirVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EmptyDirVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Medium) != 0 {
		buf.WriteString(`"medium":`)
		fflib.WriteJsonString(buf, string(mj.Medium))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EmptyDirVolumeSourcebase = iota
	ffj_t_EmptyDirVolumeSourceno_such_key

	ffj_t_EmptyDirVolumeSource_Medium
)

var ffj_key_EmptyDirVolumeSource_Medium = []byte("medium")

func (uj *EmptyDirVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EmptyDirVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EmptyDirVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EmptyDirVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_EmptyDirVolumeSource_Medium, kn) {
						currentKey = ffj_t_EmptyDirVolumeSource_Medium
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmptyDirVolumeSource_Medium, kn) {
					currentKey = ffj_t_EmptyDirVolumeSource_Medium
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EmptyDirVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EmptyDirVolumeSource_Medium:
					goto handle_Medium

				case ffj_t_EmptyDirVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Medium:

	/* handler: uj.Medium type=v1.StorageMedium kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for StorageMedium", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Medium = StorageMedium(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EndpointAddress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EndpointAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "ip":`)
	fflib.WriteJsonString(buf, string(mj.IP))
	buf.WriteByte(',')
	if mj.TargetRef != nil {
		if true {
			buf.WriteString(`"targetRef":`)

			{
				err = mj.TargetRef.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EndpointAddressbase = iota
	ffj_t_EndpointAddressno_such_key

	ffj_t_EndpointAddress_IP

	ffj_t_EndpointAddress_TargetRef
)

var ffj_key_EndpointAddress_IP = []byte("ip")

var ffj_key_EndpointAddress_TargetRef = []byte("targetRef")

func (uj *EndpointAddress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EndpointAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EndpointAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EndpointAddressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_EndpointAddress_IP, kn) {
						currentKey = ffj_t_EndpointAddress_IP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_EndpointAddress_TargetRef, kn) {
						currentKey = ffj_t_EndpointAddress_TargetRef
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EndpointAddress_TargetRef, kn) {
					currentKey = ffj_t_EndpointAddress_TargetRef
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EndpointAddress_IP, kn) {
					currentKey = ffj_t_EndpointAddress_IP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EndpointAddressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EndpointAddress_IP:
					goto handle_IP

				case ffj_t_EndpointAddress_TargetRef:
					goto handle_TargetRef

				case ffj_t_EndpointAddressno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IP:

	/* handler: uj.IP type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.IP = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetRef:

	/* handler: uj.TargetRef type=v1.ObjectReference kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.TargetRef = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TargetRef == nil {
			uj.TargetRef = new(ObjectReference)
		}

		err = uj.TargetRef.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EndpointPort) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EndpointPort) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	buf.WriteString(`"port":`)
	fflib.FormatBits2(buf, uint64(mj.Port), 10, mj.Port < 0)
	buf.WriteByte(',')
	if len(mj.Protocol) != 0 {
		buf.WriteString(`"protocol":`)
		fflib.WriteJsonString(buf, string(mj.Protocol))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EndpointPortbase = iota
	ffj_t_EndpointPortno_such_key

	ffj_t_EndpointPort_Name

	ffj_t_EndpointPort_Port

	ffj_t_EndpointPort_Protocol
)

var ffj_key_EndpointPort_Name = []byte("name")

var ffj_key_EndpointPort_Port = []byte("port")

var ffj_key_EndpointPort_Protocol = []byte("protocol")

func (uj *EndpointPort) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EndpointPort) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EndpointPortbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EndpointPortno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_EndpointPort_Name, kn) {
						currentKey = ffj_t_EndpointPort_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_EndpointPort_Port, kn) {
						currentKey = ffj_t_EndpointPort_Port
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_EndpointPort_Protocol, kn) {
						currentKey = ffj_t_EndpointPort_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EndpointPort_Protocol, kn) {
					currentKey = ffj_t_EndpointPort_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EndpointPort_Port, kn) {
					currentKey = ffj_t_EndpointPort_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EndpointPort_Name, kn) {
					currentKey = ffj_t_EndpointPort_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EndpointPortno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EndpointPort_Name:
					goto handle_Name

				case ffj_t_EndpointPort_Port:
					goto handle_Port

				case ffj_t_EndpointPort_Protocol:
					goto handle_Protocol

				case ffj_t_EndpointPortno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Port = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=v1.Protocol kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Protocol", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Protocol = Protocol(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EndpointSubset) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EndpointSubset) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Addresses) != 0 {
		buf.WriteString(`"addresses":`)
		if mj.Addresses != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Addresses {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Ports) != 0 {
		buf.WriteString(`"ports":`)
		if mj.Ports != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Ports {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EndpointSubsetbase = iota
	ffj_t_EndpointSubsetno_such_key

	ffj_t_EndpointSubset_Addresses

	ffj_t_EndpointSubset_Ports
)

var ffj_key_EndpointSubset_Addresses = []byte("addresses")

var ffj_key_EndpointSubset_Ports = []byte("ports")

func (uj *EndpointSubset) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EndpointSubset) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EndpointSubsetbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EndpointSubsetno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_EndpointSubset_Addresses, kn) {
						currentKey = ffj_t_EndpointSubset_Addresses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_EndpointSubset_Ports, kn) {
						currentKey = ffj_t_EndpointSubset_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_EndpointSubset_Ports, kn) {
					currentKey = ffj_t_EndpointSubset_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EndpointSubset_Addresses, kn) {
					currentKey = ffj_t_EndpointSubset_Addresses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EndpointSubsetno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EndpointSubset_Addresses:
					goto handle_Addresses

				case ffj_t_EndpointSubset_Ports:
					goto handle_Ports

				case ffj_t_EndpointSubsetno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Addresses:

	/* handler: uj.Addresses type=[]v1.EndpointAddress kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Addresses = nil
		} else {

			uj.Addresses = make([]EndpointAddress, 0)

			wantVal := true

			for {

				var v EndpointAddress

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.EndpointAddress kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Addresses = append(uj.Addresses, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ports:

	/* handler: uj.Ports type=[]v1.EndpointPort kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ports = nil
		} else {

			uj.Ports = make([]EndpointPort, 0)

			wantVal := true

			for {

				var v EndpointPort

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.EndpointPort kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Ports = append(uj.Ports, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Endpoints) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Endpoints) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"subsets":`)
	if mj.Subsets != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Subsets {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Endpointsbase = iota
	ffj_t_Endpointsno_such_key

	ffj_t_Endpoints_ObjectMeta

	ffj_t_Endpoints_Subsets

	ffj_t_Endpoints_Kind

	ffj_t_Endpoints_APIVersion
)

var ffj_key_Endpoints_ObjectMeta = []byte("metadata")

var ffj_key_Endpoints_Subsets = []byte("subsets")

var ffj_key_Endpoints_Kind = []byte("kind")

var ffj_key_Endpoints_APIVersion = []byte("apiVersion")

func (uj *Endpoints) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Endpoints) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Endpointsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Endpointsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Endpoints_APIVersion, kn) {
						currentKey = ffj_t_Endpoints_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Endpoints_Kind, kn) {
						currentKey = ffj_t_Endpoints_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Endpoints_ObjectMeta, kn) {
						currentKey = ffj_t_Endpoints_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Endpoints_Subsets, kn) {
						currentKey = ffj_t_Endpoints_Subsets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Endpoints_APIVersion, kn) {
					currentKey = ffj_t_Endpoints_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Endpoints_Kind, kn) {
					currentKey = ffj_t_Endpoints_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Endpoints_Subsets, kn) {
					currentKey = ffj_t_Endpoints_Subsets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Endpoints_ObjectMeta, kn) {
					currentKey = ffj_t_Endpoints_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Endpointsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Endpoints_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Endpoints_Subsets:
					goto handle_Subsets

				case ffj_t_Endpoints_Kind:
					goto handle_Kind

				case ffj_t_Endpoints_APIVersion:
					goto handle_APIVersion

				case ffj_t_Endpointsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Subsets:

	/* handler: uj.Subsets type=[]v1.EndpointSubset kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Subsets = nil
		} else {

			uj.Subsets = make([]EndpointSubset, 0)

			wantVal := true

			for {

				var v EndpointSubset

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.EndpointSubset kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Subsets = append(uj.Subsets, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EndpointsList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EndpointsList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EndpointsListbase = iota
	ffj_t_EndpointsListno_such_key

	ffj_t_EndpointsList_ListMeta

	ffj_t_EndpointsList_Items

	ffj_t_EndpointsList_Kind

	ffj_t_EndpointsList_APIVersion
)

var ffj_key_EndpointsList_ListMeta = []byte("metadata")

var ffj_key_EndpointsList_Items = []byte("items")

var ffj_key_EndpointsList_Kind = []byte("kind")

var ffj_key_EndpointsList_APIVersion = []byte("apiVersion")

func (uj *EndpointsList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EndpointsList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EndpointsListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EndpointsListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_EndpointsList_APIVersion, kn) {
						currentKey = ffj_t_EndpointsList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_EndpointsList_Items, kn) {
						currentKey = ffj_t_EndpointsList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_EndpointsList_Kind, kn) {
						currentKey = ffj_t_EndpointsList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_EndpointsList_ListMeta, kn) {
						currentKey = ffj_t_EndpointsList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_EndpointsList_APIVersion, kn) {
					currentKey = ffj_t_EndpointsList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EndpointsList_Kind, kn) {
					currentKey = ffj_t_EndpointsList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EndpointsList_Items, kn) {
					currentKey = ffj_t_EndpointsList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EndpointsList_ListMeta, kn) {
					currentKey = ffj_t_EndpointsList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EndpointsListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EndpointsList_ListMeta:
					goto handle_ListMeta

				case ffj_t_EndpointsList_Items:
					goto handle_Items

				case ffj_t_EndpointsList_Kind:
					goto handle_Kind

				case ffj_t_EndpointsList_APIVersion:
					goto handle_APIVersion

				case ffj_t_EndpointsListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Endpoints kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Endpoints, 0)

			wantVal := true

			for {

				var v Endpoints

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Endpoints kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EnvVar) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EnvVar) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if len(mj.Value) != 0 {
		buf.WriteString(`"value":`)
		fflib.WriteJsonString(buf, string(mj.Value))
		buf.WriteByte(',')
	}
	if mj.ValueFrom != nil {
		if true {
			buf.WriteString(`"valueFrom":`)

			{
				err = mj.ValueFrom.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EnvVarbase = iota
	ffj_t_EnvVarno_such_key

	ffj_t_EnvVar_Name

	ffj_t_EnvVar_Value

	ffj_t_EnvVar_ValueFrom
)

var ffj_key_EnvVar_Name = []byte("name")

var ffj_key_EnvVar_Value = []byte("value")

var ffj_key_EnvVar_ValueFrom = []byte("valueFrom")

func (uj *EnvVar) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EnvVar) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EnvVarbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EnvVarno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_EnvVar_Name, kn) {
						currentKey = ffj_t_EnvVar_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_EnvVar_Value, kn) {
						currentKey = ffj_t_EnvVar_Value
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_EnvVar_ValueFrom, kn) {
						currentKey = ffj_t_EnvVar_ValueFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EnvVar_ValueFrom, kn) {
					currentKey = ffj_t_EnvVar_ValueFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EnvVar_Value, kn) {
					currentKey = ffj_t_EnvVar_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EnvVar_Name, kn) {
					currentKey = ffj_t_EnvVar_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EnvVarno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EnvVar_Name:
					goto handle_Name

				case ffj_t_EnvVar_Value:
					goto handle_Value

				case ffj_t_EnvVar_ValueFrom:
					goto handle_ValueFrom

				case ffj_t_EnvVarno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Value:

	/* handler: uj.Value type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Value = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ValueFrom:

	/* handler: uj.ValueFrom type=v1.EnvVarSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ValueFrom = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ValueFrom == nil {
			uj.ValueFrom = new(EnvVarSource)
		}

		err = uj.ValueFrom.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EnvVarSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EnvVarSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.FieldRef != nil {
		buf.WriteString(`{"fieldRef":`)

		{
			err = mj.FieldRef.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

	} else {
		buf.WriteString(`{"fieldRef":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EnvVarSourcebase = iota
	ffj_t_EnvVarSourceno_such_key

	ffj_t_EnvVarSource_FieldRef
)

var ffj_key_EnvVarSource_FieldRef = []byte("fieldRef")

func (uj *EnvVarSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EnvVarSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EnvVarSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EnvVarSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_EnvVarSource_FieldRef, kn) {
						currentKey = ffj_t_EnvVarSource_FieldRef
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EnvVarSource_FieldRef, kn) {
					currentKey = ffj_t_EnvVarSource_FieldRef
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EnvVarSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EnvVarSource_FieldRef:
					goto handle_FieldRef

				case ffj_t_EnvVarSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FieldRef:

	/* handler: uj.FieldRef type=v1.ObjectFieldSelector kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.FieldRef = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.FieldRef == nil {
			uj.FieldRef = new(ObjectFieldSelector)
		}

		err = uj.FieldRef.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Event) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Event) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "metadata":`)

	{
		err = mj.ObjectMeta.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}
	}

	buf.WriteString(`,"involvedObject":`)

	{
		err = mj.InvolvedObject.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}
	}

	buf.WriteByte(',')
	if len(mj.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Reason))
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"source":`)

		{
			err = mj.Source.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"firstTimestamp":`)

		{
			obj, err = mj.FirstTimestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"lastTimestamp":`)

		{
			obj, err = mj.LastTimestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if mj.Count != 0 {
		buf.WriteString(`"count":`)
		fflib.FormatBits2(buf, uint64(mj.Count), 10, mj.Count < 0)
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Eventbase = iota
	ffj_t_Eventno_such_key

	ffj_t_Event_ObjectMeta

	ffj_t_Event_InvolvedObject

	ffj_t_Event_Reason

	ffj_t_Event_Message

	ffj_t_Event_Source

	ffj_t_Event_FirstTimestamp

	ffj_t_Event_LastTimestamp

	ffj_t_Event_Count

	ffj_t_Event_Kind

	ffj_t_Event_APIVersion
)

var ffj_key_Event_ObjectMeta = []byte("metadata")

var ffj_key_Event_InvolvedObject = []byte("involvedObject")

var ffj_key_Event_Reason = []byte("reason")

var ffj_key_Event_Message = []byte("message")

var ffj_key_Event_Source = []byte("source")

var ffj_key_Event_FirstTimestamp = []byte("firstTimestamp")

var ffj_key_Event_LastTimestamp = []byte("lastTimestamp")

var ffj_key_Event_Count = []byte("count")

var ffj_key_Event_Kind = []byte("kind")

var ffj_key_Event_APIVersion = []byte("apiVersion")

func (uj *Event) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Event) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Eventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Eventno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Event_APIVersion, kn) {
						currentKey = ffj_t_Event_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Event_Count, kn) {
						currentKey = ffj_t_Event_Count
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Event_FirstTimestamp, kn) {
						currentKey = ffj_t_Event_FirstTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Event_InvolvedObject, kn) {
						currentKey = ffj_t_Event_InvolvedObject
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Event_Kind, kn) {
						currentKey = ffj_t_Event_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Event_LastTimestamp, kn) {
						currentKey = ffj_t_Event_LastTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Event_ObjectMeta, kn) {
						currentKey = ffj_t_Event_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Event_Message, kn) {
						currentKey = ffj_t_Event_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Event_Reason, kn) {
						currentKey = ffj_t_Event_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Event_Source, kn) {
						currentKey = ffj_t_Event_Source
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Event_APIVersion, kn) {
					currentKey = ffj_t_Event_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Event_Kind, kn) {
					currentKey = ffj_t_Event_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Event_Count, kn) {
					currentKey = ffj_t_Event_Count
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Event_LastTimestamp, kn) {
					currentKey = ffj_t_Event_LastTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Event_FirstTimestamp, kn) {
					currentKey = ffj_t_Event_FirstTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Event_Source, kn) {
					currentKey = ffj_t_Event_Source
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Event_Message, kn) {
					currentKey = ffj_t_Event_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Event_Reason, kn) {
					currentKey = ffj_t_Event_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Event_InvolvedObject, kn) {
					currentKey = ffj_t_Event_InvolvedObject
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Event_ObjectMeta, kn) {
					currentKey = ffj_t_Event_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Eventno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Event_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Event_InvolvedObject:
					goto handle_InvolvedObject

				case ffj_t_Event_Reason:
					goto handle_Reason

				case ffj_t_Event_Message:
					goto handle_Message

				case ffj_t_Event_Source:
					goto handle_Source

				case ffj_t_Event_FirstTimestamp:
					goto handle_FirstTimestamp

				case ffj_t_Event_LastTimestamp:
					goto handle_LastTimestamp

				case ffj_t_Event_Count:
					goto handle_Count

				case ffj_t_Event_Kind:
					goto handle_Kind

				case ffj_t_Event_APIVersion:
					goto handle_APIVersion

				case ffj_t_Eventno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InvolvedObject:

	/* handler: uj.InvolvedObject type=v1.ObjectReference kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.InvolvedObject.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Reason = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Source:

	/* handler: uj.Source type=v1.EventSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Source.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstTimestamp:

	/* handler: uj.FirstTimestamp type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.FirstTimestamp.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastTimestamp:

	/* handler: uj.LastTimestamp type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.LastTimestamp.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Count:

	/* handler: uj.Count type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Count = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EventList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EventList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EventListbase = iota
	ffj_t_EventListno_such_key

	ffj_t_EventList_ListMeta

	ffj_t_EventList_Items

	ffj_t_EventList_Kind

	ffj_t_EventList_APIVersion
)

var ffj_key_EventList_ListMeta = []byte("metadata")

var ffj_key_EventList_Items = []byte("items")

var ffj_key_EventList_Kind = []byte("kind")

var ffj_key_EventList_APIVersion = []byte("apiVersion")

func (uj *EventList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EventList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EventListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EventListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_EventList_APIVersion, kn) {
						currentKey = ffj_t_EventList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_EventList_Items, kn) {
						currentKey = ffj_t_EventList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_EventList_Kind, kn) {
						currentKey = ffj_t_EventList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_EventList_ListMeta, kn) {
						currentKey = ffj_t_EventList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_EventList_APIVersion, kn) {
					currentKey = ffj_t_EventList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EventList_Kind, kn) {
					currentKey = ffj_t_EventList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EventList_Items, kn) {
					currentKey = ffj_t_EventList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EventList_ListMeta, kn) {
					currentKey = ffj_t_EventList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EventListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EventList_ListMeta:
					goto handle_ListMeta

				case ffj_t_EventList_Items:
					goto handle_Items

				case ffj_t_EventList_Kind:
					goto handle_Kind

				case ffj_t_EventList_APIVersion:
					goto handle_APIVersion

				case ffj_t_EventListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Event kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Event, 0)

			wantVal := true

			for {

				var v Event

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Event kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EventSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EventSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Component) != 0 {
		buf.WriteString(`"component":`)
		fflib.WriteJsonString(buf, string(mj.Component))
		buf.WriteByte(',')
	}
	if len(mj.Host) != 0 {
		buf.WriteString(`"host":`)
		fflib.WriteJsonString(buf, string(mj.Host))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EventSourcebase = iota
	ffj_t_EventSourceno_such_key

	ffj_t_EventSource_Component

	ffj_t_EventSource_Host
)

var ffj_key_EventSource_Component = []byte("component")

var ffj_key_EventSource_Host = []byte("host")

func (uj *EventSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EventSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EventSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EventSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_EventSource_Component, kn) {
						currentKey = ffj_t_EventSource_Component
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_EventSource_Host, kn) {
						currentKey = ffj_t_EventSource_Host
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_EventSource_Host, kn) {
					currentKey = ffj_t_EventSource_Host
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EventSource_Component, kn) {
					currentKey = ffj_t_EventSource_Component
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EventSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EventSource_Component:
					goto handle_Component

				case ffj_t_EventSource_Host:
					goto handle_Host

				case ffj_t_EventSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Component:

	/* handler: uj.Component type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Component = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Host:

	/* handler: uj.Host type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Host = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ExecAction) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ExecAction) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Command) != 0 {
		buf.WriteString(`"command":`)
		if mj.Command != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Command {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ExecActionbase = iota
	ffj_t_ExecActionno_such_key

	ffj_t_ExecAction_Command
)

var ffj_key_ExecAction_Command = []byte("command")

func (uj *ExecAction) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ExecAction) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ExecActionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ExecActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ExecAction_Command, kn) {
						currentKey = ffj_t_ExecAction_Command
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ExecAction_Command, kn) {
					currentKey = ffj_t_ExecAction_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ExecActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ExecAction_Command:
					goto handle_Command

				case ffj_t_ExecActionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Command:

	/* handler: uj.Command type=[]string kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Command = nil
		} else {

			uj.Command = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = string(fs.Output.String())

					}
				}

				uj.Command = append(uj.Command, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *GCEPersistentDiskVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *GCEPersistentDiskVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "pdName":`)
	fflib.WriteJsonString(buf, string(mj.PDName))
	buf.WriteString(`,"fsType":`)
	fflib.WriteJsonString(buf, string(mj.FSType))
	buf.WriteByte(',')
	if mj.Partition != 0 {
		buf.WriteString(`"partition":`)
		fflib.FormatBits2(buf, uint64(mj.Partition), 10, mj.Partition < 0)
		buf.WriteByte(',')
	}
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_GCEPersistentDiskVolumeSourcebase = iota
	ffj_t_GCEPersistentDiskVolumeSourceno_such_key

	ffj_t_GCEPersistentDiskVolumeSource_PDName

	ffj_t_GCEPersistentDiskVolumeSource_FSType

	ffj_t_GCEPersistentDiskVolumeSource_Partition

	ffj_t_GCEPersistentDiskVolumeSource_ReadOnly
)

var ffj_key_GCEPersistentDiskVolumeSource_PDName = []byte("pdName")

var ffj_key_GCEPersistentDiskVolumeSource_FSType = []byte("fsType")

var ffj_key_GCEPersistentDiskVolumeSource_Partition = []byte("partition")

var ffj_key_GCEPersistentDiskVolumeSource_ReadOnly = []byte("readOnly")

func (uj *GCEPersistentDiskVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *GCEPersistentDiskVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_GCEPersistentDiskVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_GCEPersistentDiskVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_GCEPersistentDiskVolumeSource_FSType, kn) {
						currentKey = ffj_t_GCEPersistentDiskVolumeSource_FSType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_GCEPersistentDiskVolumeSource_PDName, kn) {
						currentKey = ffj_t_GCEPersistentDiskVolumeSource_PDName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_GCEPersistentDiskVolumeSource_Partition, kn) {
						currentKey = ffj_t_GCEPersistentDiskVolumeSource_Partition
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_GCEPersistentDiskVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_GCEPersistentDiskVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_GCEPersistentDiskVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_GCEPersistentDiskVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_GCEPersistentDiskVolumeSource_Partition, kn) {
					currentKey = ffj_t_GCEPersistentDiskVolumeSource_Partition
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_GCEPersistentDiskVolumeSource_FSType, kn) {
					currentKey = ffj_t_GCEPersistentDiskVolumeSource_FSType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_GCEPersistentDiskVolumeSource_PDName, kn) {
					currentKey = ffj_t_GCEPersistentDiskVolumeSource_PDName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_GCEPersistentDiskVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_GCEPersistentDiskVolumeSource_PDName:
					goto handle_PDName

				case ffj_t_GCEPersistentDiskVolumeSource_FSType:
					goto handle_FSType

				case ffj_t_GCEPersistentDiskVolumeSource_Partition:
					goto handle_Partition

				case ffj_t_GCEPersistentDiskVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_GCEPersistentDiskVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PDName:

	/* handler: uj.PDName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.PDName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FSType:

	/* handler: uj.FSType type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FSType = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Partition:

	/* handler: uj.Partition type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Partition = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *GitRepoVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *GitRepoVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"repository":`)
	fflib.WriteJsonString(buf, string(mj.Repository))
	buf.WriteString(`,"revision":`)
	fflib.WriteJsonString(buf, string(mj.Revision))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_GitRepoVolumeSourcebase = iota
	ffj_t_GitRepoVolumeSourceno_such_key

	ffj_t_GitRepoVolumeSource_Repository

	ffj_t_GitRepoVolumeSource_Revision
)

var ffj_key_GitRepoVolumeSource_Repository = []byte("repository")

var ffj_key_GitRepoVolumeSource_Revision = []byte("revision")

func (uj *GitRepoVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *GitRepoVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_GitRepoVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_GitRepoVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_GitRepoVolumeSource_Repository, kn) {
						currentKey = ffj_t_GitRepoVolumeSource_Repository
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_GitRepoVolumeSource_Revision, kn) {
						currentKey = ffj_t_GitRepoVolumeSource_Revision
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_GitRepoVolumeSource_Revision, kn) {
					currentKey = ffj_t_GitRepoVolumeSource_Revision
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_GitRepoVolumeSource_Repository, kn) {
					currentKey = ffj_t_GitRepoVolumeSource_Repository
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_GitRepoVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_GitRepoVolumeSource_Repository:
					goto handle_Repository

				case ffj_t_GitRepoVolumeSource_Revision:
					goto handle_Revision

				case ffj_t_GitRepoVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Repository:

	/* handler: uj.Repository type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Repository = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Revision:

	/* handler: uj.Revision type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Revision = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *GlusterfsVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *GlusterfsVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "endpoints":`)
	fflib.WriteJsonString(buf, string(mj.EndpointsName))
	buf.WriteString(`,"path":`)
	fflib.WriteJsonString(buf, string(mj.Path))
	buf.WriteByte(',')
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_GlusterfsVolumeSourcebase = iota
	ffj_t_GlusterfsVolumeSourceno_such_key

	ffj_t_GlusterfsVolumeSource_EndpointsName

	ffj_t_GlusterfsVolumeSource_Path

	ffj_t_GlusterfsVolumeSource_ReadOnly
)

var ffj_key_GlusterfsVolumeSource_EndpointsName = []byte("endpoints")

var ffj_key_GlusterfsVolumeSource_Path = []byte("path")

var ffj_key_GlusterfsVolumeSource_ReadOnly = []byte("readOnly")

func (uj *GlusterfsVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *GlusterfsVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_GlusterfsVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_GlusterfsVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_GlusterfsVolumeSource_EndpointsName, kn) {
						currentKey = ffj_t_GlusterfsVolumeSource_EndpointsName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_GlusterfsVolumeSource_Path, kn) {
						currentKey = ffj_t_GlusterfsVolumeSource_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_GlusterfsVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_GlusterfsVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_GlusterfsVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_GlusterfsVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_GlusterfsVolumeSource_Path, kn) {
					currentKey = ffj_t_GlusterfsVolumeSource_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_GlusterfsVolumeSource_EndpointsName, kn) {
					currentKey = ffj_t_GlusterfsVolumeSource_EndpointsName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_GlusterfsVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_GlusterfsVolumeSource_EndpointsName:
					goto handle_EndpointsName

				case ffj_t_GlusterfsVolumeSource_Path:
					goto handle_Path

				case ffj_t_GlusterfsVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_GlusterfsVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_EndpointsName:

	/* handler: uj.EndpointsName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.EndpointsName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Path = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *HTTPGetAction) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HTTPGetAction) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Path) != 0 {
		buf.WriteString(`"path":`)
		fflib.WriteJsonString(buf, string(mj.Path))
		buf.WriteByte(',')
	}
	buf.WriteString(`"port":`)

	{
		obj, err = mj.Port.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)
	}

	buf.WriteByte(',')
	if len(mj.Host) != 0 {
		buf.WriteString(`"host":`)
		fflib.WriteJsonString(buf, string(mj.Host))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HTTPGetActionbase = iota
	ffj_t_HTTPGetActionno_such_key

	ffj_t_HTTPGetAction_Path

	ffj_t_HTTPGetAction_Port

	ffj_t_HTTPGetAction_Host
)

var ffj_key_HTTPGetAction_Path = []byte("path")

var ffj_key_HTTPGetAction_Port = []byte("port")

var ffj_key_HTTPGetAction_Host = []byte("host")

func (uj *HTTPGetAction) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HTTPGetAction) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HTTPGetActionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HTTPGetActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_HTTPGetAction_Host, kn) {
						currentKey = ffj_t_HTTPGetAction_Host
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_HTTPGetAction_Path, kn) {
						currentKey = ffj_t_HTTPGetAction_Path
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_HTTPGetAction_Port, kn) {
						currentKey = ffj_t_HTTPGetAction_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_HTTPGetAction_Host, kn) {
					currentKey = ffj_t_HTTPGetAction_Host
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HTTPGetAction_Port, kn) {
					currentKey = ffj_t_HTTPGetAction_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_HTTPGetAction_Path, kn) {
					currentKey = ffj_t_HTTPGetAction_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HTTPGetActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HTTPGetAction_Path:
					goto handle_Path

				case ffj_t_HTTPGetAction_Port:
					goto handle_Port

				case ffj_t_HTTPGetAction_Host:
					goto handle_Host

				case ffj_t_HTTPGetActionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Path:

	/* handler: uj.Path type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Path = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=util.IntOrString kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Port.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Host:

	/* handler: uj.Host type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Host = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Handler) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Handler) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Exec != nil {
		if true {
			buf.WriteString(`"exec":`)

			{
				err = mj.Exec.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.HTTPGet != nil {
		if true {
			buf.WriteString(`"httpGet":`)

			{
				err = mj.HTTPGet.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.TCPSocket != nil {
		if true {
			buf.WriteString(`"tcpSocket":`)

			{
				err = mj.TCPSocket.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Handlerbase = iota
	ffj_t_Handlerno_such_key

	ffj_t_Handler_Exec

	ffj_t_Handler_HTTPGet

	ffj_t_Handler_TCPSocket
)

var ffj_key_Handler_Exec = []byte("exec")

var ffj_key_Handler_HTTPGet = []byte("httpGet")

var ffj_key_Handler_TCPSocket = []byte("tcpSocket")

func (uj *Handler) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Handler) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Handlerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Handlerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_Handler_Exec, kn) {
						currentKey = ffj_t_Handler_Exec
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Handler_HTTPGet, kn) {
						currentKey = ffj_t_Handler_HTTPGet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Handler_TCPSocket, kn) {
						currentKey = ffj_t_Handler_TCPSocket
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Handler_TCPSocket, kn) {
					currentKey = ffj_t_Handler_TCPSocket
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Handler_HTTPGet, kn) {
					currentKey = ffj_t_Handler_HTTPGet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Handler_Exec, kn) {
					currentKey = ffj_t_Handler_Exec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Handlerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Handler_Exec:
					goto handle_Exec

				case ffj_t_Handler_HTTPGet:
					goto handle_HTTPGet

				case ffj_t_Handler_TCPSocket:
					goto handle_TCPSocket

				case ffj_t_Handlerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Exec:

	/* handler: uj.Exec type=v1.ExecAction kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Exec = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Exec == nil {
			uj.Exec = new(ExecAction)
		}

		err = uj.Exec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HTTPGet:

	/* handler: uj.HTTPGet type=v1.HTTPGetAction kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.HTTPGet = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HTTPGet == nil {
			uj.HTTPGet = new(HTTPGetAction)
		}

		err = uj.HTTPGet.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TCPSocket:

	/* handler: uj.TCPSocket type=v1.TCPSocketAction kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.TCPSocket = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TCPSocket == nil {
			uj.TCPSocket = new(TCPSocketAction)
		}

		err = uj.TCPSocket.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *HostPathVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *HostPathVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"path":`)
	fflib.WriteJsonString(buf, string(mj.Path))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_HostPathVolumeSourcebase = iota
	ffj_t_HostPathVolumeSourceno_such_key

	ffj_t_HostPathVolumeSource_Path
)

var ffj_key_HostPathVolumeSource_Path = []byte("path")

func (uj *HostPathVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *HostPathVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_HostPathVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_HostPathVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_HostPathVolumeSource_Path, kn) {
						currentKey = ffj_t_HostPathVolumeSource_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_HostPathVolumeSource_Path, kn) {
					currentKey = ffj_t_HostPathVolumeSource_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_HostPathVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_HostPathVolumeSource_Path:
					goto handle_Path

				case ffj_t_HostPathVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Path:

	/* handler: uj.Path type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Path = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ISCSIVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ISCSIVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "targetPortal":`)
	fflib.WriteJsonString(buf, string(mj.TargetPortal))
	buf.WriteString(`,"iqn":`)
	fflib.WriteJsonString(buf, string(mj.IQN))
	buf.WriteString(`,"lun":`)
	fflib.FormatBits2(buf, uint64(mj.Lun), 10, mj.Lun < 0)
	buf.WriteString(`,"fsType":`)
	fflib.WriteJsonString(buf, string(mj.FSType))
	buf.WriteByte(',')
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ISCSIVolumeSourcebase = iota
	ffj_t_ISCSIVolumeSourceno_such_key

	ffj_t_ISCSIVolumeSource_TargetPortal

	ffj_t_ISCSIVolumeSource_IQN

	ffj_t_ISCSIVolumeSource_Lun

	ffj_t_ISCSIVolumeSource_FSType

	ffj_t_ISCSIVolumeSource_ReadOnly
)

var ffj_key_ISCSIVolumeSource_TargetPortal = []byte("targetPortal")

var ffj_key_ISCSIVolumeSource_IQN = []byte("iqn")

var ffj_key_ISCSIVolumeSource_Lun = []byte("lun")

var ffj_key_ISCSIVolumeSource_FSType = []byte("fsType")

var ffj_key_ISCSIVolumeSource_ReadOnly = []byte("readOnly")

func (uj *ISCSIVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ISCSIVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ISCSIVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ISCSIVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_ISCSIVolumeSource_FSType, kn) {
						currentKey = ffj_t_ISCSIVolumeSource_FSType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ISCSIVolumeSource_IQN, kn) {
						currentKey = ffj_t_ISCSIVolumeSource_IQN
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ISCSIVolumeSource_Lun, kn) {
						currentKey = ffj_t_ISCSIVolumeSource_Lun
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ISCSIVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_ISCSIVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ISCSIVolumeSource_TargetPortal, kn) {
						currentKey = ffj_t_ISCSIVolumeSource_TargetPortal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ISCSIVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_ISCSIVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ISCSIVolumeSource_FSType, kn) {
					currentKey = ffj_t_ISCSIVolumeSource_FSType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ISCSIVolumeSource_Lun, kn) {
					currentKey = ffj_t_ISCSIVolumeSource_Lun
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ISCSIVolumeSource_IQN, kn) {
					currentKey = ffj_t_ISCSIVolumeSource_IQN
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ISCSIVolumeSource_TargetPortal, kn) {
					currentKey = ffj_t_ISCSIVolumeSource_TargetPortal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ISCSIVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ISCSIVolumeSource_TargetPortal:
					goto handle_TargetPortal

				case ffj_t_ISCSIVolumeSource_IQN:
					goto handle_IQN

				case ffj_t_ISCSIVolumeSource_Lun:
					goto handle_Lun

				case ffj_t_ISCSIVolumeSource_FSType:
					goto handle_FSType

				case ffj_t_ISCSIVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_ISCSIVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TargetPortal:

	/* handler: uj.TargetPortal type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.TargetPortal = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IQN:

	/* handler: uj.IQN type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.IQN = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lun:

	/* handler: uj.Lun type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Lun = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FSType:

	/* handler: uj.FSType type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FSType = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Lifecycle) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Lifecycle) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.PostStart != nil {
		if true {
			buf.WriteString(`"postStart":`)

			{
				err = mj.PostStart.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.PreStop != nil {
		if true {
			buf.WriteString(`"preStop":`)

			{
				err = mj.PreStop.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Lifecyclebase = iota
	ffj_t_Lifecycleno_such_key

	ffj_t_Lifecycle_PostStart

	ffj_t_Lifecycle_PreStop
)

var ffj_key_Lifecycle_PostStart = []byte("postStart")

var ffj_key_Lifecycle_PreStop = []byte("preStop")

func (uj *Lifecycle) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Lifecycle) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Lifecyclebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Lifecycleno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Lifecycle_PostStart, kn) {
						currentKey = ffj_t_Lifecycle_PostStart
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Lifecycle_PreStop, kn) {
						currentKey = ffj_t_Lifecycle_PreStop
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Lifecycle_PreStop, kn) {
					currentKey = ffj_t_Lifecycle_PreStop
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Lifecycle_PostStart, kn) {
					currentKey = ffj_t_Lifecycle_PostStart
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Lifecycleno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Lifecycle_PostStart:
					goto handle_PostStart

				case ffj_t_Lifecycle_PreStop:
					goto handle_PreStop

				case ffj_t_Lifecycleno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PostStart:

	/* handler: uj.PostStart type=v1.Handler kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.PostStart = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PostStart == nil {
			uj.PostStart = new(Handler)
		}

		err = uj.PostStart.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PreStop:

	/* handler: uj.PreStop type=v1.Handler kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.PreStop = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PreStop == nil {
			uj.PreStop = new(Handler)
		}

		err = uj.PreStop.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LimitRange) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LimitRange) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LimitRangebase = iota
	ffj_t_LimitRangeno_such_key

	ffj_t_LimitRange_ObjectMeta

	ffj_t_LimitRange_Spec

	ffj_t_LimitRange_Kind

	ffj_t_LimitRange_APIVersion
)

var ffj_key_LimitRange_ObjectMeta = []byte("metadata")

var ffj_key_LimitRange_Spec = []byte("spec")

var ffj_key_LimitRange_Kind = []byte("kind")

var ffj_key_LimitRange_APIVersion = []byte("apiVersion")

func (uj *LimitRange) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LimitRange) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LimitRangebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LimitRangeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_LimitRange_APIVersion, kn) {
						currentKey = ffj_t_LimitRange_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_LimitRange_Kind, kn) {
						currentKey = ffj_t_LimitRange_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_LimitRange_ObjectMeta, kn) {
						currentKey = ffj_t_LimitRange_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_LimitRange_Spec, kn) {
						currentKey = ffj_t_LimitRange_Spec
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_LimitRange_APIVersion, kn) {
					currentKey = ffj_t_LimitRange_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_LimitRange_Kind, kn) {
					currentKey = ffj_t_LimitRange_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_LimitRange_Spec, kn) {
					currentKey = ffj_t_LimitRange_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_LimitRange_ObjectMeta, kn) {
					currentKey = ffj_t_LimitRange_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LimitRangeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LimitRange_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_LimitRange_Spec:
					goto handle_Spec

				case ffj_t_LimitRange_Kind:
					goto handle_Kind

				case ffj_t_LimitRange_APIVersion:
					goto handle_APIVersion

				case ffj_t_LimitRangeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.LimitRangeSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LimitRangeItem) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LimitRangeItem) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(mj.Type))
		buf.WriteByte(',')
	}
	if len(mj.Max) != 0 {
		buf.WriteString(`"max":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Max)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.Min) != 0 {
		buf.WriteString(`"min":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Min)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.Default) != 0 {
		buf.WriteString(`"default":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Default)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LimitRangeItembase = iota
	ffj_t_LimitRangeItemno_such_key

	ffj_t_LimitRangeItem_Type

	ffj_t_LimitRangeItem_Max

	ffj_t_LimitRangeItem_Min

	ffj_t_LimitRangeItem_Default
)

var ffj_key_LimitRangeItem_Type = []byte("type")

var ffj_key_LimitRangeItem_Max = []byte("max")

var ffj_key_LimitRangeItem_Min = []byte("min")

var ffj_key_LimitRangeItem_Default = []byte("default")

func (uj *LimitRangeItem) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LimitRangeItem) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LimitRangeItembase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LimitRangeItemno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_LimitRangeItem_Default, kn) {
						currentKey = ffj_t_LimitRangeItem_Default
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_LimitRangeItem_Max, kn) {
						currentKey = ffj_t_LimitRangeItem_Max
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_LimitRangeItem_Min, kn) {
						currentKey = ffj_t_LimitRangeItem_Min
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_LimitRangeItem_Type, kn) {
						currentKey = ffj_t_LimitRangeItem_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_LimitRangeItem_Default, kn) {
					currentKey = ffj_t_LimitRangeItem_Default
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_LimitRangeItem_Min, kn) {
					currentKey = ffj_t_LimitRangeItem_Min
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_LimitRangeItem_Max, kn) {
					currentKey = ffj_t_LimitRangeItem_Max
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_LimitRangeItem_Type, kn) {
					currentKey = ffj_t_LimitRangeItem_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LimitRangeItemno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LimitRangeItem_Type:
					goto handle_Type

				case ffj_t_LimitRangeItem_Max:
					goto handle_Max

				case ffj_t_LimitRangeItem_Min:
					goto handle_Min

				case ffj_t_LimitRangeItem_Default:
					goto handle_Default

				case ffj_t_LimitRangeItemno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=v1.LimitType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for LimitType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = LimitType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Max:

	/* handler: uj.Max type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Max)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Min:

	/* handler: uj.Min type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Min)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Default:

	/* handler: uj.Default type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Default)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LimitRangeList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LimitRangeList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LimitRangeListbase = iota
	ffj_t_LimitRangeListno_such_key

	ffj_t_LimitRangeList_ListMeta

	ffj_t_LimitRangeList_Items

	ffj_t_LimitRangeList_Kind

	ffj_t_LimitRangeList_APIVersion
)

var ffj_key_LimitRangeList_ListMeta = []byte("metadata")

var ffj_key_LimitRangeList_Items = []byte("items")

var ffj_key_LimitRangeList_Kind = []byte("kind")

var ffj_key_LimitRangeList_APIVersion = []byte("apiVersion")

func (uj *LimitRangeList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LimitRangeList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LimitRangeListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LimitRangeListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_LimitRangeList_APIVersion, kn) {
						currentKey = ffj_t_LimitRangeList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_LimitRangeList_Items, kn) {
						currentKey = ffj_t_LimitRangeList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_LimitRangeList_Kind, kn) {
						currentKey = ffj_t_LimitRangeList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_LimitRangeList_ListMeta, kn) {
						currentKey = ffj_t_LimitRangeList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_LimitRangeList_APIVersion, kn) {
					currentKey = ffj_t_LimitRangeList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_LimitRangeList_Kind, kn) {
					currentKey = ffj_t_LimitRangeList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_LimitRangeList_Items, kn) {
					currentKey = ffj_t_LimitRangeList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_LimitRangeList_ListMeta, kn) {
					currentKey = ffj_t_LimitRangeList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LimitRangeListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LimitRangeList_ListMeta:
					goto handle_ListMeta

				case ffj_t_LimitRangeList_Items:
					goto handle_Items

				case ffj_t_LimitRangeList_Kind:
					goto handle_Kind

				case ffj_t_LimitRangeList_APIVersion:
					goto handle_APIVersion

				case ffj_t_LimitRangeListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.LimitRange kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]LimitRange, 0)

			wantVal := true

			for {

				var v LimitRange

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.LimitRange kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LimitRangeSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LimitRangeSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"limits":`)
	if mj.Limits != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Limits {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LimitRangeSpecbase = iota
	ffj_t_LimitRangeSpecno_such_key

	ffj_t_LimitRangeSpec_Limits
)

var ffj_key_LimitRangeSpec_Limits = []byte("limits")

func (uj *LimitRangeSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LimitRangeSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LimitRangeSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LimitRangeSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_LimitRangeSpec_Limits, kn) {
						currentKey = ffj_t_LimitRangeSpec_Limits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_LimitRangeSpec_Limits, kn) {
					currentKey = ffj_t_LimitRangeSpec_Limits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LimitRangeSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LimitRangeSpec_Limits:
					goto handle_Limits

				case ffj_t_LimitRangeSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Limits:

	/* handler: uj.Limits type=[]v1.LimitRangeItem kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Limits = nil
		} else {

			uj.Limits = make([]LimitRangeItem, 0)

			wantVal := true

			for {

				var v LimitRangeItem

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.LimitRangeItem kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Limits = append(uj.Limits, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *List) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *List) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Listbase = iota
	ffj_t_Listno_such_key

	ffj_t_List_ListMeta

	ffj_t_List_Items

	ffj_t_List_Kind

	ffj_t_List_APIVersion
)

var ffj_key_List_ListMeta = []byte("metadata")

var ffj_key_List_Items = []byte("items")

var ffj_key_List_Kind = []byte("kind")

var ffj_key_List_APIVersion = []byte("apiVersion")

func (uj *List) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *List) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Listbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Listno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_List_APIVersion, kn) {
						currentKey = ffj_t_List_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_List_Items, kn) {
						currentKey = ffj_t_List_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_List_Kind, kn) {
						currentKey = ffj_t_List_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_List_ListMeta, kn) {
						currentKey = ffj_t_List_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_List_APIVersion, kn) {
					currentKey = ffj_t_List_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_List_Kind, kn) {
					currentKey = ffj_t_List_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_List_Items, kn) {
					currentKey = ffj_t_List_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_List_ListMeta, kn) {
					currentKey = ffj_t_List_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Listno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_List_ListMeta:
					goto handle_ListMeta

				case ffj_t_List_Items:
					goto handle_Items

				case ffj_t_List_Kind:
					goto handle_Kind

				case ffj_t_List_APIVersion:
					goto handle_APIVersion

				case ffj_t_Listno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]runtime.RawExtension kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]runtime.RawExtension, 0)

			wantVal := true

			for {

				var v runtime.RawExtension

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=runtime.RawExtension kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = v.UnmarshalJSON(tbuf)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ListMeta) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ListMeta) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.SelfLink) != 0 {
		buf.WriteString(`"selfLink":`)
		fflib.WriteJsonString(buf, string(mj.SelfLink))
		buf.WriteByte(',')
	}
	if len(mj.ResourceVersion) != 0 {
		buf.WriteString(`"resourceVersion":`)
		fflib.WriteJsonString(buf, string(mj.ResourceVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ListMetabase = iota
	ffj_t_ListMetano_such_key

	ffj_t_ListMeta_SelfLink

	ffj_t_ListMeta_ResourceVersion
)

var ffj_key_ListMeta_SelfLink = []byte("selfLink")

var ffj_key_ListMeta_ResourceVersion = []byte("resourceVersion")

func (uj *ListMeta) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ListMeta) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ListMetabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ListMetano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_ListMeta_ResourceVersion, kn) {
						currentKey = ffj_t_ListMeta_ResourceVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ListMeta_SelfLink, kn) {
						currentKey = ffj_t_ListMeta_SelfLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ListMeta_ResourceVersion, kn) {
					currentKey = ffj_t_ListMeta_ResourceVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ListMeta_SelfLink, kn) {
					currentKey = ffj_t_ListMeta_SelfLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ListMetano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ListMeta_SelfLink:
					goto handle_SelfLink

				case ffj_t_ListMeta_ResourceVersion:
					goto handle_ResourceVersion

				case ffj_t_ListMetano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SelfLink:

	/* handler: uj.SelfLink type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.SelfLink = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResourceVersion:

	/* handler: uj.ResourceVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ResourceVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ListOptions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ListOptions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.LabelSelector) != 0 {
		buf.WriteString(`"labelSelector":`)
		fflib.WriteJsonString(buf, string(mj.LabelSelector))
		buf.WriteByte(',')
	}
	if len(mj.FieldSelector) != 0 {
		buf.WriteString(`"fieldSelector":`)
		fflib.WriteJsonString(buf, string(mj.FieldSelector))
		buf.WriteByte(',')
	}
	if mj.Watch != false {
		if mj.Watch {
			buf.WriteString(`"watch":true`)
		} else {
			buf.WriteString(`"watch":false`)
		}
		buf.WriteByte(',')
	}
	if len(mj.ResourceVersion) != 0 {
		buf.WriteString(`"resourceVersion":`)
		fflib.WriteJsonString(buf, string(mj.ResourceVersion))
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ListOptionsbase = iota
	ffj_t_ListOptionsno_such_key

	ffj_t_ListOptions_LabelSelector

	ffj_t_ListOptions_FieldSelector

	ffj_t_ListOptions_Watch

	ffj_t_ListOptions_ResourceVersion

	ffj_t_ListOptions_Kind

	ffj_t_ListOptions_APIVersion
)

var ffj_key_ListOptions_LabelSelector = []byte("labelSelector")

var ffj_key_ListOptions_FieldSelector = []byte("fieldSelector")

var ffj_key_ListOptions_Watch = []byte("watch")

var ffj_key_ListOptions_ResourceVersion = []byte("resourceVersion")

var ffj_key_ListOptions_Kind = []byte("kind")

var ffj_key_ListOptions_APIVersion = []byte("apiVersion")

func (uj *ListOptions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ListOptions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ListOptionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ListOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ListOptions_APIVersion, kn) {
						currentKey = ffj_t_ListOptions_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ListOptions_FieldSelector, kn) {
						currentKey = ffj_t_ListOptions_FieldSelector
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ListOptions_Kind, kn) {
						currentKey = ffj_t_ListOptions_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ListOptions_LabelSelector, kn) {
						currentKey = ffj_t_ListOptions_LabelSelector
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ListOptions_ResourceVersion, kn) {
						currentKey = ffj_t_ListOptions_ResourceVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_ListOptions_Watch, kn) {
						currentKey = ffj_t_ListOptions_Watch
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ListOptions_APIVersion, kn) {
					currentKey = ffj_t_ListOptions_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ListOptions_Kind, kn) {
					currentKey = ffj_t_ListOptions_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ListOptions_ResourceVersion, kn) {
					currentKey = ffj_t_ListOptions_ResourceVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ListOptions_Watch, kn) {
					currentKey = ffj_t_ListOptions_Watch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ListOptions_FieldSelector, kn) {
					currentKey = ffj_t_ListOptions_FieldSelector
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ListOptions_LabelSelector, kn) {
					currentKey = ffj_t_ListOptions_LabelSelector
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ListOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ListOptions_LabelSelector:
					goto handle_LabelSelector

				case ffj_t_ListOptions_FieldSelector:
					goto handle_FieldSelector

				case ffj_t_ListOptions_Watch:
					goto handle_Watch

				case ffj_t_ListOptions_ResourceVersion:
					goto handle_ResourceVersion

				case ffj_t_ListOptions_Kind:
					goto handle_Kind

				case ffj_t_ListOptions_APIVersion:
					goto handle_APIVersion

				case ffj_t_ListOptionsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_LabelSelector:

	/* handler: uj.LabelSelector type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.LabelSelector = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FieldSelector:

	/* handler: uj.FieldSelector type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FieldSelector = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Watch:

	/* handler: uj.Watch type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Watch = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Watch = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResourceVersion:

	/* handler: uj.ResourceVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ResourceVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LoadBalancerIngress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LoadBalancerIngress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.IP) != 0 {
		buf.WriteString(`"ip":`)
		fflib.WriteJsonString(buf, string(mj.IP))
		buf.WriteByte(',')
	}
	if len(mj.Hostname) != 0 {
		buf.WriteString(`"hostname":`)
		fflib.WriteJsonString(buf, string(mj.Hostname))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LoadBalancerIngressbase = iota
	ffj_t_LoadBalancerIngressno_such_key

	ffj_t_LoadBalancerIngress_IP

	ffj_t_LoadBalancerIngress_Hostname
)

var ffj_key_LoadBalancerIngress_IP = []byte("ip")

var ffj_key_LoadBalancerIngress_Hostname = []byte("hostname")

func (uj *LoadBalancerIngress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LoadBalancerIngress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LoadBalancerIngressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LoadBalancerIngressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_LoadBalancerIngress_Hostname, kn) {
						currentKey = ffj_t_LoadBalancerIngress_Hostname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_LoadBalancerIngress_IP, kn) {
						currentKey = ffj_t_LoadBalancerIngress_IP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_LoadBalancerIngress_Hostname, kn) {
					currentKey = ffj_t_LoadBalancerIngress_Hostname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_LoadBalancerIngress_IP, kn) {
					currentKey = ffj_t_LoadBalancerIngress_IP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LoadBalancerIngressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LoadBalancerIngress_IP:
					goto handle_IP

				case ffj_t_LoadBalancerIngress_Hostname:
					goto handle_Hostname

				case ffj_t_LoadBalancerIngressno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IP:

	/* handler: uj.IP type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.IP = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hostname:

	/* handler: uj.Hostname type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Hostname = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LoadBalancerStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LoadBalancerStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Ingress) != 0 {
		buf.WriteString(`"ingress":`)
		if mj.Ingress != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Ingress {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LoadBalancerStatusbase = iota
	ffj_t_LoadBalancerStatusno_such_key

	ffj_t_LoadBalancerStatus_Ingress
)

var ffj_key_LoadBalancerStatus_Ingress = []byte("ingress")

func (uj *LoadBalancerStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LoadBalancerStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LoadBalancerStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LoadBalancerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_LoadBalancerStatus_Ingress, kn) {
						currentKey = ffj_t_LoadBalancerStatus_Ingress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_LoadBalancerStatus_Ingress, kn) {
					currentKey = ffj_t_LoadBalancerStatus_Ingress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LoadBalancerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LoadBalancerStatus_Ingress:
					goto handle_Ingress

				case ffj_t_LoadBalancerStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ingress:

	/* handler: uj.Ingress type=[]v1.LoadBalancerIngress kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ingress = nil
		} else {

			uj.Ingress = make([]LoadBalancerIngress, 0)

			wantVal := true

			for {

				var v LoadBalancerIngress

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.LoadBalancerIngress kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Ingress = append(uj.Ingress, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *LocalObjectReference) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *LocalObjectReference) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_LocalObjectReferencebase = iota
	ffj_t_LocalObjectReferenceno_such_key

	ffj_t_LocalObjectReference_Name
)

var ffj_key_LocalObjectReference_Name = []byte("name")

func (uj *LocalObjectReference) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *LocalObjectReference) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_LocalObjectReferencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_LocalObjectReferenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_LocalObjectReference_Name, kn) {
						currentKey = ffj_t_LocalObjectReference_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_LocalObjectReference_Name, kn) {
					currentKey = ffj_t_LocalObjectReference_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_LocalObjectReferenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_LocalObjectReference_Name:
					goto handle_Name

				case ffj_t_LocalObjectReferenceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NFSVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NFSVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "server":`)
	fflib.WriteJsonString(buf, string(mj.Server))
	buf.WriteString(`,"path":`)
	fflib.WriteJsonString(buf, string(mj.Path))
	buf.WriteByte(',')
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NFSVolumeSourcebase = iota
	ffj_t_NFSVolumeSourceno_such_key

	ffj_t_NFSVolumeSource_Server

	ffj_t_NFSVolumeSource_Path

	ffj_t_NFSVolumeSource_ReadOnly
)

var ffj_key_NFSVolumeSource_Server = []byte("server")

var ffj_key_NFSVolumeSource_Path = []byte("path")

var ffj_key_NFSVolumeSource_ReadOnly = []byte("readOnly")

func (uj *NFSVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NFSVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NFSVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NFSVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_NFSVolumeSource_Path, kn) {
						currentKey = ffj_t_NFSVolumeSource_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_NFSVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_NFSVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_NFSVolumeSource_Server, kn) {
						currentKey = ffj_t_NFSVolumeSource_Server
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_NFSVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_NFSVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NFSVolumeSource_Path, kn) {
					currentKey = ffj_t_NFSVolumeSource_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NFSVolumeSource_Server, kn) {
					currentKey = ffj_t_NFSVolumeSource_Server
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NFSVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NFSVolumeSource_Server:
					goto handle_Server

				case ffj_t_NFSVolumeSource_Path:
					goto handle_Path

				case ffj_t_NFSVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_NFSVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Server:

	/* handler: uj.Server type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Server = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Path:

	/* handler: uj.Path type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Path = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Namespace) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Namespace) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Namespacebase = iota
	ffj_t_Namespaceno_such_key

	ffj_t_Namespace_ObjectMeta

	ffj_t_Namespace_Spec

	ffj_t_Namespace_Status

	ffj_t_Namespace_Kind

	ffj_t_Namespace_APIVersion
)

var ffj_key_Namespace_ObjectMeta = []byte("metadata")

var ffj_key_Namespace_Spec = []byte("spec")

var ffj_key_Namespace_Status = []byte("status")

var ffj_key_Namespace_Kind = []byte("kind")

var ffj_key_Namespace_APIVersion = []byte("apiVersion")

func (uj *Namespace) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Namespace) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Namespacebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Namespaceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Namespace_APIVersion, kn) {
						currentKey = ffj_t_Namespace_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Namespace_Kind, kn) {
						currentKey = ffj_t_Namespace_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Namespace_ObjectMeta, kn) {
						currentKey = ffj_t_Namespace_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Namespace_Spec, kn) {
						currentKey = ffj_t_Namespace_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Namespace_Status, kn) {
						currentKey = ffj_t_Namespace_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Namespace_APIVersion, kn) {
					currentKey = ffj_t_Namespace_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Namespace_Kind, kn) {
					currentKey = ffj_t_Namespace_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Namespace_Status, kn) {
					currentKey = ffj_t_Namespace_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Namespace_Spec, kn) {
					currentKey = ffj_t_Namespace_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Namespace_ObjectMeta, kn) {
					currentKey = ffj_t_Namespace_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Namespaceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Namespace_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Namespace_Spec:
					goto handle_Spec

				case ffj_t_Namespace_Status:
					goto handle_Status

				case ffj_t_Namespace_Kind:
					goto handle_Kind

				case ffj_t_Namespace_APIVersion:
					goto handle_APIVersion

				case ffj_t_Namespaceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.NamespaceSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.NamespaceStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NamespaceList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NamespaceList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NamespaceListbase = iota
	ffj_t_NamespaceListno_such_key

	ffj_t_NamespaceList_ListMeta

	ffj_t_NamespaceList_Items

	ffj_t_NamespaceList_Kind

	ffj_t_NamespaceList_APIVersion
)

var ffj_key_NamespaceList_ListMeta = []byte("metadata")

var ffj_key_NamespaceList_Items = []byte("items")

var ffj_key_NamespaceList_Kind = []byte("kind")

var ffj_key_NamespaceList_APIVersion = []byte("apiVersion")

func (uj *NamespaceList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NamespaceList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NamespaceListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NamespaceListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_NamespaceList_APIVersion, kn) {
						currentKey = ffj_t_NamespaceList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_NamespaceList_Items, kn) {
						currentKey = ffj_t_NamespaceList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_NamespaceList_Kind, kn) {
						currentKey = ffj_t_NamespaceList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_NamespaceList_ListMeta, kn) {
						currentKey = ffj_t_NamespaceList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NamespaceList_APIVersion, kn) {
					currentKey = ffj_t_NamespaceList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NamespaceList_Kind, kn) {
					currentKey = ffj_t_NamespaceList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NamespaceList_Items, kn) {
					currentKey = ffj_t_NamespaceList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NamespaceList_ListMeta, kn) {
					currentKey = ffj_t_NamespaceList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NamespaceListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NamespaceList_ListMeta:
					goto handle_ListMeta

				case ffj_t_NamespaceList_Items:
					goto handle_Items

				case ffj_t_NamespaceList_Kind:
					goto handle_Kind

				case ffj_t_NamespaceList_APIVersion:
					goto handle_APIVersion

				case ffj_t_NamespaceListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Namespace kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Namespace, 0)

			wantVal := true

			for {

				var v Namespace

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Namespace kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NamespaceSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NamespaceSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Finalizers) != 0 {
		buf.WriteString(`"finalizers":`)
		if mj.Finalizers != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Finalizers {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NamespaceSpecbase = iota
	ffj_t_NamespaceSpecno_such_key

	ffj_t_NamespaceSpec_Finalizers
)

var ffj_key_NamespaceSpec_Finalizers = []byte("finalizers")

func (uj *NamespaceSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NamespaceSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NamespaceSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NamespaceSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_NamespaceSpec_Finalizers, kn) {
						currentKey = ffj_t_NamespaceSpec_Finalizers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NamespaceSpec_Finalizers, kn) {
					currentKey = ffj_t_NamespaceSpec_Finalizers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NamespaceSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NamespaceSpec_Finalizers:
					goto handle_Finalizers

				case ffj_t_NamespaceSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Finalizers:

	/* handler: uj.Finalizers type=[]v1.FinalizerName kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Finalizers = nil
		} else {

			uj.Finalizers = make([]FinalizerName, 0)

			wantVal := true

			for {

				var v FinalizerName

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.FinalizerName kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for FinalizerName", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = FinalizerName(fs.Output.String())

					}
				}

				uj.Finalizers = append(uj.Finalizers, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NamespaceStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NamespaceStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Phase) != 0 {
		buf.WriteString(`"phase":`)
		fflib.WriteJsonString(buf, string(mj.Phase))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NamespaceStatusbase = iota
	ffj_t_NamespaceStatusno_such_key

	ffj_t_NamespaceStatus_Phase
)

var ffj_key_NamespaceStatus_Phase = []byte("phase")

func (uj *NamespaceStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NamespaceStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NamespaceStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NamespaceStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_NamespaceStatus_Phase, kn) {
						currentKey = ffj_t_NamespaceStatus_Phase
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NamespaceStatus_Phase, kn) {
					currentKey = ffj_t_NamespaceStatus_Phase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NamespaceStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NamespaceStatus_Phase:
					goto handle_Phase

				case ffj_t_NamespaceStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Phase:

	/* handler: uj.Phase type=v1.NamespacePhase kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NamespacePhase", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Phase = NamespacePhase(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Node) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Node) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Nodebase = iota
	ffj_t_Nodeno_such_key

	ffj_t_Node_ObjectMeta

	ffj_t_Node_Spec

	ffj_t_Node_Status

	ffj_t_Node_Kind

	ffj_t_Node_APIVersion
)

var ffj_key_Node_ObjectMeta = []byte("metadata")

var ffj_key_Node_Spec = []byte("spec")

var ffj_key_Node_Status = []byte("status")

var ffj_key_Node_Kind = []byte("kind")

var ffj_key_Node_APIVersion = []byte("apiVersion")

func (uj *Node) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Node) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Nodebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Nodeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Node_APIVersion, kn) {
						currentKey = ffj_t_Node_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Node_Kind, kn) {
						currentKey = ffj_t_Node_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Node_ObjectMeta, kn) {
						currentKey = ffj_t_Node_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Node_Spec, kn) {
						currentKey = ffj_t_Node_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Node_Status, kn) {
						currentKey = ffj_t_Node_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Node_APIVersion, kn) {
					currentKey = ffj_t_Node_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Node_Kind, kn) {
					currentKey = ffj_t_Node_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Node_Status, kn) {
					currentKey = ffj_t_Node_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Node_Spec, kn) {
					currentKey = ffj_t_Node_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Node_ObjectMeta, kn) {
					currentKey = ffj_t_Node_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Nodeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Node_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Node_Spec:
					goto handle_Spec

				case ffj_t_Node_Status:
					goto handle_Status

				case ffj_t_Node_Kind:
					goto handle_Kind

				case ffj_t_Node_APIVersion:
					goto handle_APIVersion

				case ffj_t_Nodeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.NodeSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.NodeStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NodeAddress) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NodeAddress) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(mj.Address))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NodeAddressbase = iota
	ffj_t_NodeAddressno_such_key

	ffj_t_NodeAddress_Type

	ffj_t_NodeAddress_Address
)

var ffj_key_NodeAddress_Type = []byte("type")

var ffj_key_NodeAddress_Address = []byte("address")

func (uj *NodeAddress) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NodeAddress) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NodeAddressbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NodeAddressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_NodeAddress_Address, kn) {
						currentKey = ffj_t_NodeAddress_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_NodeAddress_Type, kn) {
						currentKey = ffj_t_NodeAddress_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NodeAddress_Address, kn) {
					currentKey = ffj_t_NodeAddress_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeAddress_Type, kn) {
					currentKey = ffj_t_NodeAddress_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NodeAddressno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NodeAddress_Type:
					goto handle_Type

				case ffj_t_NodeAddress_Address:
					goto handle_Address

				case ffj_t_NodeAddressno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=v1.NodeAddressType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NodeAddressType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = NodeAddressType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Address = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NodeCondition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NodeCondition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(mj.Status))
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"lastHeartbeatTime":`)

		{
			obj, err = mj.LastHeartbeatTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"lastTransitionTime":`)

		{
			obj, err = mj.LastTransitionTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if len(mj.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Reason))
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NodeConditionbase = iota
	ffj_t_NodeConditionno_such_key

	ffj_t_NodeCondition_Type

	ffj_t_NodeCondition_Status

	ffj_t_NodeCondition_LastHeartbeatTime

	ffj_t_NodeCondition_LastTransitionTime

	ffj_t_NodeCondition_Reason

	ffj_t_NodeCondition_Message
)

var ffj_key_NodeCondition_Type = []byte("type")

var ffj_key_NodeCondition_Status = []byte("status")

var ffj_key_NodeCondition_LastHeartbeatTime = []byte("lastHeartbeatTime")

var ffj_key_NodeCondition_LastTransitionTime = []byte("lastTransitionTime")

var ffj_key_NodeCondition_Reason = []byte("reason")

var ffj_key_NodeCondition_Message = []byte("message")

func (uj *NodeCondition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NodeCondition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NodeConditionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NodeConditionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_NodeCondition_LastHeartbeatTime, kn) {
						currentKey = ffj_t_NodeCondition_LastHeartbeatTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NodeCondition_LastTransitionTime, kn) {
						currentKey = ffj_t_NodeCondition_LastTransitionTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_NodeCondition_Message, kn) {
						currentKey = ffj_t_NodeCondition_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_NodeCondition_Reason, kn) {
						currentKey = ffj_t_NodeCondition_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_NodeCondition_Status, kn) {
						currentKey = ffj_t_NodeCondition_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_NodeCondition_Type, kn) {
						currentKey = ffj_t_NodeCondition_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NodeCondition_Message, kn) {
					currentKey = ffj_t_NodeCondition_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeCondition_Reason, kn) {
					currentKey = ffj_t_NodeCondition_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeCondition_LastTransitionTime, kn) {
					currentKey = ffj_t_NodeCondition_LastTransitionTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeCondition_LastHeartbeatTime, kn) {
					currentKey = ffj_t_NodeCondition_LastHeartbeatTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeCondition_Status, kn) {
					currentKey = ffj_t_NodeCondition_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeCondition_Type, kn) {
					currentKey = ffj_t_NodeCondition_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NodeConditionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NodeCondition_Type:
					goto handle_Type

				case ffj_t_NodeCondition_Status:
					goto handle_Status

				case ffj_t_NodeCondition_LastHeartbeatTime:
					goto handle_LastHeartbeatTime

				case ffj_t_NodeCondition_LastTransitionTime:
					goto handle_LastTransitionTime

				case ffj_t_NodeCondition_Reason:
					goto handle_Reason

				case ffj_t_NodeCondition_Message:
					goto handle_Message

				case ffj_t_NodeConditionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=v1.NodeConditionType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NodeConditionType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = NodeConditionType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.ConditionStatus kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ConditionStatus", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Status = ConditionStatus(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastHeartbeatTime:

	/* handler: uj.LastHeartbeatTime type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.LastHeartbeatTime.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastTransitionTime:

	/* handler: uj.LastTransitionTime type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.LastTransitionTime.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Reason = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NodeList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NodeList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NodeListbase = iota
	ffj_t_NodeListno_such_key

	ffj_t_NodeList_ListMeta

	ffj_t_NodeList_Items

	ffj_t_NodeList_Kind

	ffj_t_NodeList_APIVersion
)

var ffj_key_NodeList_ListMeta = []byte("metadata")

var ffj_key_NodeList_Items = []byte("items")

var ffj_key_NodeList_Kind = []byte("kind")

var ffj_key_NodeList_APIVersion = []byte("apiVersion")

func (uj *NodeList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NodeList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NodeListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NodeListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_NodeList_APIVersion, kn) {
						currentKey = ffj_t_NodeList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_NodeList_Items, kn) {
						currentKey = ffj_t_NodeList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_NodeList_Kind, kn) {
						currentKey = ffj_t_NodeList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_NodeList_ListMeta, kn) {
						currentKey = ffj_t_NodeList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NodeList_APIVersion, kn) {
					currentKey = ffj_t_NodeList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeList_Kind, kn) {
					currentKey = ffj_t_NodeList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeList_Items, kn) {
					currentKey = ffj_t_NodeList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeList_ListMeta, kn) {
					currentKey = ffj_t_NodeList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NodeListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NodeList_ListMeta:
					goto handle_ListMeta

				case ffj_t_NodeList_Items:
					goto handle_Items

				case ffj_t_NodeList_Kind:
					goto handle_Kind

				case ffj_t_NodeList_APIVersion:
					goto handle_APIVersion

				case ffj_t_NodeListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Node kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Node, 0)

			wantVal := true

			for {

				var v Node

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Node kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NodeSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NodeSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.PodCIDR) != 0 {
		buf.WriteString(`"podCIDR":`)
		fflib.WriteJsonString(buf, string(mj.PodCIDR))
		buf.WriteByte(',')
	}
	if len(mj.ExternalID) != 0 {
		buf.WriteString(`"externalID":`)
		fflib.WriteJsonString(buf, string(mj.ExternalID))
		buf.WriteByte(',')
	}
	if len(mj.ProviderID) != 0 {
		buf.WriteString(`"providerID":`)
		fflib.WriteJsonString(buf, string(mj.ProviderID))
		buf.WriteByte(',')
	}
	if mj.Unschedulable != false {
		if mj.Unschedulable {
			buf.WriteString(`"unschedulable":true`)
		} else {
			buf.WriteString(`"unschedulable":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NodeSpecbase = iota
	ffj_t_NodeSpecno_such_key

	ffj_t_NodeSpec_PodCIDR

	ffj_t_NodeSpec_ExternalID

	ffj_t_NodeSpec_ProviderID

	ffj_t_NodeSpec_Unschedulable
)

var ffj_key_NodeSpec_PodCIDR = []byte("podCIDR")

var ffj_key_NodeSpec_ExternalID = []byte("externalID")

var ffj_key_NodeSpec_ProviderID = []byte("providerID")

var ffj_key_NodeSpec_Unschedulable = []byte("unschedulable")

func (uj *NodeSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NodeSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NodeSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NodeSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_NodeSpec_ExternalID, kn) {
						currentKey = ffj_t_NodeSpec_ExternalID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_NodeSpec_PodCIDR, kn) {
						currentKey = ffj_t_NodeSpec_PodCIDR
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NodeSpec_ProviderID, kn) {
						currentKey = ffj_t_NodeSpec_ProviderID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_NodeSpec_Unschedulable, kn) {
						currentKey = ffj_t_NodeSpec_Unschedulable
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NodeSpec_Unschedulable, kn) {
					currentKey = ffj_t_NodeSpec_Unschedulable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeSpec_ProviderID, kn) {
					currentKey = ffj_t_NodeSpec_ProviderID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeSpec_ExternalID, kn) {
					currentKey = ffj_t_NodeSpec_ExternalID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeSpec_PodCIDR, kn) {
					currentKey = ffj_t_NodeSpec_PodCIDR
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NodeSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NodeSpec_PodCIDR:
					goto handle_PodCIDR

				case ffj_t_NodeSpec_ExternalID:
					goto handle_ExternalID

				case ffj_t_NodeSpec_ProviderID:
					goto handle_ProviderID

				case ffj_t_NodeSpec_Unschedulable:
					goto handle_Unschedulable

				case ffj_t_NodeSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PodCIDR:

	/* handler: uj.PodCIDR type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.PodCIDR = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExternalID:

	/* handler: uj.ExternalID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ExternalID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderID:

	/* handler: uj.ProviderID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ProviderID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Unschedulable:

	/* handler: uj.Unschedulable type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Unschedulable = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Unschedulable = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NodeStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NodeStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Capacity) != 0 {
		buf.WriteString(`"capacity":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Capacity)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.Phase) != 0 {
		buf.WriteString(`"phase":`)
		fflib.WriteJsonString(buf, string(mj.Phase))
		buf.WriteByte(',')
	}
	if len(mj.Conditions) != 0 {
		buf.WriteString(`"conditions":`)
		if mj.Conditions != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Conditions {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Addresses) != 0 {
		buf.WriteString(`"addresses":`)
		if mj.Addresses != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Addresses {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"nodeInfo":`)

		{
			err = mj.NodeInfo.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NodeStatusbase = iota
	ffj_t_NodeStatusno_such_key

	ffj_t_NodeStatus_Capacity

	ffj_t_NodeStatus_Phase

	ffj_t_NodeStatus_Conditions

	ffj_t_NodeStatus_Addresses

	ffj_t_NodeStatus_NodeInfo
)

var ffj_key_NodeStatus_Capacity = []byte("capacity")

var ffj_key_NodeStatus_Phase = []byte("phase")

var ffj_key_NodeStatus_Conditions = []byte("conditions")

var ffj_key_NodeStatus_Addresses = []byte("addresses")

var ffj_key_NodeStatus_NodeInfo = []byte("nodeInfo")

func (uj *NodeStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NodeStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NodeStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NodeStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_NodeStatus_Addresses, kn) {
						currentKey = ffj_t_NodeStatus_Addresses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_NodeStatus_Capacity, kn) {
						currentKey = ffj_t_NodeStatus_Capacity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NodeStatus_Conditions, kn) {
						currentKey = ffj_t_NodeStatus_Conditions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_NodeStatus_NodeInfo, kn) {
						currentKey = ffj_t_NodeStatus_NodeInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_NodeStatus_Phase, kn) {
						currentKey = ffj_t_NodeStatus_Phase
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeStatus_NodeInfo, kn) {
					currentKey = ffj_t_NodeStatus_NodeInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeStatus_Addresses, kn) {
					currentKey = ffj_t_NodeStatus_Addresses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeStatus_Conditions, kn) {
					currentKey = ffj_t_NodeStatus_Conditions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeStatus_Phase, kn) {
					currentKey = ffj_t_NodeStatus_Phase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeStatus_Capacity, kn) {
					currentKey = ffj_t_NodeStatus_Capacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NodeStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NodeStatus_Capacity:
					goto handle_Capacity

				case ffj_t_NodeStatus_Phase:
					goto handle_Phase

				case ffj_t_NodeStatus_Conditions:
					goto handle_Conditions

				case ffj_t_NodeStatus_Addresses:
					goto handle_Addresses

				case ffj_t_NodeStatus_NodeInfo:
					goto handle_NodeInfo

				case ffj_t_NodeStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Capacity:

	/* handler: uj.Capacity type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Capacity)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Phase:

	/* handler: uj.Phase type=v1.NodePhase kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for NodePhase", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Phase = NodePhase(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Conditions:

	/* handler: uj.Conditions type=[]v1.NodeCondition kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Conditions = nil
		} else {

			uj.Conditions = make([]NodeCondition, 0)

			wantVal := true

			for {

				var v NodeCondition

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.NodeCondition kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Conditions = append(uj.Conditions, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Addresses:

	/* handler: uj.Addresses type=[]v1.NodeAddress kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Addresses = nil
		} else {

			uj.Addresses = make([]NodeAddress, 0)

			wantVal := true

			for {

				var v NodeAddress

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.NodeAddress kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Addresses = append(uj.Addresses, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeInfo:

	/* handler: uj.NodeInfo type=v1.NodeSystemInfo kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.NodeInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NodeSystemInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NodeSystemInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"machineID":`)
	fflib.WriteJsonString(buf, string(mj.MachineID))
	buf.WriteString(`,"systemUUID":`)
	fflib.WriteJsonString(buf, string(mj.SystemUUID))
	buf.WriteString(`,"bootID":`)
	fflib.WriteJsonString(buf, string(mj.BootID))
	buf.WriteString(`,"kernelVersion":`)
	fflib.WriteJsonString(buf, string(mj.KernelVersion))
	buf.WriteString(`,"osImage":`)
	fflib.WriteJsonString(buf, string(mj.OsImage))
	buf.WriteString(`,"containerRuntimeVersion":`)
	fflib.WriteJsonString(buf, string(mj.ContainerRuntimeVersion))
	buf.WriteString(`,"kubeletVersion":`)
	fflib.WriteJsonString(buf, string(mj.KubeletVersion))
	buf.WriteString(`,"kubeProxyVersion":`)
	fflib.WriteJsonString(buf, string(mj.KubeProxyVersion))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NodeSystemInfobase = iota
	ffj_t_NodeSystemInfono_such_key

	ffj_t_NodeSystemInfo_MachineID

	ffj_t_NodeSystemInfo_SystemUUID

	ffj_t_NodeSystemInfo_BootID

	ffj_t_NodeSystemInfo_KernelVersion

	ffj_t_NodeSystemInfo_OsImage

	ffj_t_NodeSystemInfo_ContainerRuntimeVersion

	ffj_t_NodeSystemInfo_KubeletVersion

	ffj_t_NodeSystemInfo_KubeProxyVersion
)

var ffj_key_NodeSystemInfo_MachineID = []byte("machineID")

var ffj_key_NodeSystemInfo_SystemUUID = []byte("systemUUID")

var ffj_key_NodeSystemInfo_BootID = []byte("bootID")

var ffj_key_NodeSystemInfo_KernelVersion = []byte("kernelVersion")

var ffj_key_NodeSystemInfo_OsImage = []byte("osImage")

var ffj_key_NodeSystemInfo_ContainerRuntimeVersion = []byte("containerRuntimeVersion")

var ffj_key_NodeSystemInfo_KubeletVersion = []byte("kubeletVersion")

var ffj_key_NodeSystemInfo_KubeProxyVersion = []byte("kubeProxyVersion")

func (uj *NodeSystemInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NodeSystemInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NodeSystemInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NodeSystemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_NodeSystemInfo_BootID, kn) {
						currentKey = ffj_t_NodeSystemInfo_BootID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_NodeSystemInfo_ContainerRuntimeVersion, kn) {
						currentKey = ffj_t_NodeSystemInfo_ContainerRuntimeVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_NodeSystemInfo_KernelVersion, kn) {
						currentKey = ffj_t_NodeSystemInfo_KernelVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NodeSystemInfo_KubeletVersion, kn) {
						currentKey = ffj_t_NodeSystemInfo_KubeletVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NodeSystemInfo_KubeProxyVersion, kn) {
						currentKey = ffj_t_NodeSystemInfo_KubeProxyVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_NodeSystemInfo_MachineID, kn) {
						currentKey = ffj_t_NodeSystemInfo_MachineID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_NodeSystemInfo_OsImage, kn) {
						currentKey = ffj_t_NodeSystemInfo_OsImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_NodeSystemInfo_SystemUUID, kn) {
						currentKey = ffj_t_NodeSystemInfo_SystemUUID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NodeSystemInfo_KubeProxyVersion, kn) {
					currentKey = ffj_t_NodeSystemInfo_KubeProxyVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeSystemInfo_KubeletVersion, kn) {
					currentKey = ffj_t_NodeSystemInfo_KubeletVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeSystemInfo_ContainerRuntimeVersion, kn) {
					currentKey = ffj_t_NodeSystemInfo_ContainerRuntimeVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeSystemInfo_OsImage, kn) {
					currentKey = ffj_t_NodeSystemInfo_OsImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeSystemInfo_KernelVersion, kn) {
					currentKey = ffj_t_NodeSystemInfo_KernelVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeSystemInfo_BootID, kn) {
					currentKey = ffj_t_NodeSystemInfo_BootID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NodeSystemInfo_SystemUUID, kn) {
					currentKey = ffj_t_NodeSystemInfo_SystemUUID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NodeSystemInfo_MachineID, kn) {
					currentKey = ffj_t_NodeSystemInfo_MachineID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NodeSystemInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NodeSystemInfo_MachineID:
					goto handle_MachineID

				case ffj_t_NodeSystemInfo_SystemUUID:
					goto handle_SystemUUID

				case ffj_t_NodeSystemInfo_BootID:
					goto handle_BootID

				case ffj_t_NodeSystemInfo_KernelVersion:
					goto handle_KernelVersion

				case ffj_t_NodeSystemInfo_OsImage:
					goto handle_OsImage

				case ffj_t_NodeSystemInfo_ContainerRuntimeVersion:
					goto handle_ContainerRuntimeVersion

				case ffj_t_NodeSystemInfo_KubeletVersion:
					goto handle_KubeletVersion

				case ffj_t_NodeSystemInfo_KubeProxyVersion:
					goto handle_KubeProxyVersion

				case ffj_t_NodeSystemInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MachineID:

	/* handler: uj.MachineID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.MachineID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SystemUUID:

	/* handler: uj.SystemUUID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.SystemUUID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BootID:

	/* handler: uj.BootID type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.BootID = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KernelVersion:

	/* handler: uj.KernelVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.KernelVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OsImage:

	/* handler: uj.OsImage type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.OsImage = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerRuntimeVersion:

	/* handler: uj.ContainerRuntimeVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ContainerRuntimeVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KubeletVersion:

	/* handler: uj.KubeletVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.KubeletVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KubeProxyVersion:

	/* handler: uj.KubeProxyVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.KubeProxyVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ObjectFieldSelector) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ObjectFieldSelector) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.WriteString(`"fieldPath":`)
	fflib.WriteJsonString(buf, string(mj.FieldPath))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ObjectFieldSelectorbase = iota
	ffj_t_ObjectFieldSelectorno_such_key

	ffj_t_ObjectFieldSelector_APIVersion

	ffj_t_ObjectFieldSelector_FieldPath
)

var ffj_key_ObjectFieldSelector_APIVersion = []byte("apiVersion")

var ffj_key_ObjectFieldSelector_FieldPath = []byte("fieldPath")

func (uj *ObjectFieldSelector) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ObjectFieldSelector) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ObjectFieldSelectorbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ObjectFieldSelectorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ObjectFieldSelector_APIVersion, kn) {
						currentKey = ffj_t_ObjectFieldSelector_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ObjectFieldSelector_FieldPath, kn) {
						currentKey = ffj_t_ObjectFieldSelector_FieldPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectFieldSelector_FieldPath, kn) {
					currentKey = ffj_t_ObjectFieldSelector_FieldPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectFieldSelector_APIVersion, kn) {
					currentKey = ffj_t_ObjectFieldSelector_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ObjectFieldSelectorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ObjectFieldSelector_APIVersion:
					goto handle_APIVersion

				case ffj_t_ObjectFieldSelector_FieldPath:
					goto handle_FieldPath

				case ffj_t_ObjectFieldSelectorno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FieldPath:

	/* handler: uj.FieldPath type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FieldPath = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ObjectMeta) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ObjectMeta) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	if len(mj.GenerateName) != 0 {
		buf.WriteString(`"generateName":`)
		fflib.WriteJsonString(buf, string(mj.GenerateName))
		buf.WriteByte(',')
	}
	if len(mj.Namespace) != 0 {
		buf.WriteString(`"namespace":`)
		fflib.WriteJsonString(buf, string(mj.Namespace))
		buf.WriteByte(',')
	}
	if len(mj.SelfLink) != 0 {
		buf.WriteString(`"selfLink":`)
		fflib.WriteJsonString(buf, string(mj.SelfLink))
		buf.WriteByte(',')
	}
	if len(mj.UID) != 0 {
		buf.WriteString(`"uid":`)
		fflib.WriteJsonString(buf, string(mj.UID))
		buf.WriteByte(',')
	}
	if len(mj.ResourceVersion) != 0 {
		buf.WriteString(`"resourceVersion":`)
		fflib.WriteJsonString(buf, string(mj.ResourceVersion))
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"creationTimestamp":`)

		{
			obj, err = mj.CreationTimestamp.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	if mj.DeletionTimestamp != nil {
		if true {
			buf.WriteString(`"deletionTimestamp":`)

			{
				obj, err = mj.DeletionTimestamp.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)
			}

			buf.WriteByte(',')
		}
	}
	if len(mj.Labels) != 0 {
		if mj.Labels == nil {
			buf.WriteString(`"labels":null`)
		} else {
			buf.WriteString(`"labels":{ `)
			for key, value := range mj.Labels {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if len(mj.Annotations) != 0 {
		if mj.Annotations == nil {
			buf.WriteString(`"annotations":null`)
		} else {
			buf.WriteString(`"annotations":{ `)
			for key, value := range mj.Annotations {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ObjectMetabase = iota
	ffj_t_ObjectMetano_such_key

	ffj_t_ObjectMeta_Name

	ffj_t_ObjectMeta_GenerateName

	ffj_t_ObjectMeta_Namespace

	ffj_t_ObjectMeta_SelfLink

	ffj_t_ObjectMeta_UID

	ffj_t_ObjectMeta_ResourceVersion

	ffj_t_ObjectMeta_CreationTimestamp

	ffj_t_ObjectMeta_DeletionTimestamp

	ffj_t_ObjectMeta_Labels

	ffj_t_ObjectMeta_Annotations
)

var ffj_key_ObjectMeta_Name = []byte("name")

var ffj_key_ObjectMeta_GenerateName = []byte("generateName")

var ffj_key_ObjectMeta_Namespace = []byte("namespace")

var ffj_key_ObjectMeta_SelfLink = []byte("selfLink")

var ffj_key_ObjectMeta_UID = []byte("uid")

var ffj_key_ObjectMeta_ResourceVersion = []byte("resourceVersion")

var ffj_key_ObjectMeta_CreationTimestamp = []byte("creationTimestamp")

var ffj_key_ObjectMeta_DeletionTimestamp = []byte("deletionTimestamp")

var ffj_key_ObjectMeta_Labels = []byte("labels")

var ffj_key_ObjectMeta_Annotations = []byte("annotations")

func (uj *ObjectMeta) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ObjectMeta) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ObjectMetabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ObjectMetano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ObjectMeta_Annotations, kn) {
						currentKey = ffj_t_ObjectMeta_Annotations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_ObjectMeta_CreationTimestamp, kn) {
						currentKey = ffj_t_ObjectMeta_CreationTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ObjectMeta_DeletionTimestamp, kn) {
						currentKey = ffj_t_ObjectMeta_DeletionTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_ObjectMeta_GenerateName, kn) {
						currentKey = ffj_t_ObjectMeta_GenerateName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ObjectMeta_Labels, kn) {
						currentKey = ffj_t_ObjectMeta_Labels
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ObjectMeta_Name, kn) {
						currentKey = ffj_t_ObjectMeta_Name
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ObjectMeta_Namespace, kn) {
						currentKey = ffj_t_ObjectMeta_Namespace
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ObjectMeta_ResourceVersion, kn) {
						currentKey = ffj_t_ObjectMeta_ResourceVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ObjectMeta_SelfLink, kn) {
						currentKey = ffj_t_ObjectMeta_SelfLink
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ObjectMeta_UID, kn) {
						currentKey = ffj_t_ObjectMeta_UID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_Annotations, kn) {
					currentKey = ffj_t_ObjectMeta_Annotations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_Labels, kn) {
					currentKey = ffj_t_ObjectMeta_Labels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_DeletionTimestamp, kn) {
					currentKey = ffj_t_ObjectMeta_DeletionTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_CreationTimestamp, kn) {
					currentKey = ffj_t_ObjectMeta_CreationTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_ResourceVersion, kn) {
					currentKey = ffj_t_ObjectMeta_ResourceVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectMeta_UID, kn) {
					currentKey = ffj_t_ObjectMeta_UID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_SelfLink, kn) {
					currentKey = ffj_t_ObjectMeta_SelfLink
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectMeta_Namespace, kn) {
					currentKey = ffj_t_ObjectMeta_Namespace
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectMeta_GenerateName, kn) {
					currentKey = ffj_t_ObjectMeta_GenerateName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectMeta_Name, kn) {
					currentKey = ffj_t_ObjectMeta_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ObjectMetano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ObjectMeta_Name:
					goto handle_Name

				case ffj_t_ObjectMeta_GenerateName:
					goto handle_GenerateName

				case ffj_t_ObjectMeta_Namespace:
					goto handle_Namespace

				case ffj_t_ObjectMeta_SelfLink:
					goto handle_SelfLink

				case ffj_t_ObjectMeta_UID:
					goto handle_UID

				case ffj_t_ObjectMeta_ResourceVersion:
					goto handle_ResourceVersion

				case ffj_t_ObjectMeta_CreationTimestamp:
					goto handle_CreationTimestamp

				case ffj_t_ObjectMeta_DeletionTimestamp:
					goto handle_DeletionTimestamp

				case ffj_t_ObjectMeta_Labels:
					goto handle_Labels

				case ffj_t_ObjectMeta_Annotations:
					goto handle_Annotations

				case ffj_t_ObjectMetano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GenerateName:

	/* handler: uj.GenerateName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.GenerateName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Namespace:

	/* handler: uj.Namespace type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Namespace = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SelfLink:

	/* handler: uj.SelfLink type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.SelfLink = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UID:

	/* handler: uj.UID type=types.UID kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UID", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.UID = types.UID(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResourceVersion:

	/* handler: uj.ResourceVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ResourceVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreationTimestamp:

	/* handler: uj.CreationTimestamp type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.CreationTimestamp.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeletionTimestamp:

	/* handler: uj.DeletionTimestamp type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.DeletionTimestamp = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.DeletionTimestamp == nil {
			uj.DeletionTimestamp = new(util.Time)
		}

		err = uj.DeletionTimestamp.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: uj.Labels type=map[string]string kind=map */

	{
		/* Falling back. type=map[string]string kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Labels)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Annotations:

	/* handler: uj.Annotations type=map[string]string kind=map */

	{
		/* Falling back. type=map[string]string kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Annotations)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ObjectReference) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ObjectReference) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.Namespace) != 0 {
		buf.WriteString(`"namespace":`)
		fflib.WriteJsonString(buf, string(mj.Namespace))
		buf.WriteByte(',')
	}
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	if len(mj.UID) != 0 {
		buf.WriteString(`"uid":`)
		fflib.WriteJsonString(buf, string(mj.UID))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	if len(mj.ResourceVersion) != 0 {
		buf.WriteString(`"resourceVersion":`)
		fflib.WriteJsonString(buf, string(mj.ResourceVersion))
		buf.WriteByte(',')
	}
	if len(mj.FieldPath) != 0 {
		buf.WriteString(`"fieldPath":`)
		fflib.WriteJsonString(buf, string(mj.FieldPath))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ObjectReferencebase = iota
	ffj_t_ObjectReferenceno_such_key

	ffj_t_ObjectReference_Kind

	ffj_t_ObjectReference_Namespace

	ffj_t_ObjectReference_Name

	ffj_t_ObjectReference_UID

	ffj_t_ObjectReference_APIVersion

	ffj_t_ObjectReference_ResourceVersion

	ffj_t_ObjectReference_FieldPath
)

var ffj_key_ObjectReference_Kind = []byte("kind")

var ffj_key_ObjectReference_Namespace = []byte("namespace")

var ffj_key_ObjectReference_Name = []byte("name")

var ffj_key_ObjectReference_UID = []byte("uid")

var ffj_key_ObjectReference_APIVersion = []byte("apiVersion")

var ffj_key_ObjectReference_ResourceVersion = []byte("resourceVersion")

var ffj_key_ObjectReference_FieldPath = []byte("fieldPath")

func (uj *ObjectReference) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ObjectReference) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ObjectReferencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ObjectReferenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ObjectReference_APIVersion, kn) {
						currentKey = ffj_t_ObjectReference_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_ObjectReference_FieldPath, kn) {
						currentKey = ffj_t_ObjectReference_FieldPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ObjectReference_Kind, kn) {
						currentKey = ffj_t_ObjectReference_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_ObjectReference_Namespace, kn) {
						currentKey = ffj_t_ObjectReference_Namespace
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ObjectReference_Name, kn) {
						currentKey = ffj_t_ObjectReference_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ObjectReference_ResourceVersion, kn) {
						currentKey = ffj_t_ObjectReference_ResourceVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ObjectReference_UID, kn) {
						currentKey = ffj_t_ObjectReference_UID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectReference_FieldPath, kn) {
					currentKey = ffj_t_ObjectReference_FieldPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectReference_ResourceVersion, kn) {
					currentKey = ffj_t_ObjectReference_ResourceVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectReference_APIVersion, kn) {
					currentKey = ffj_t_ObjectReference_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectReference_UID, kn) {
					currentKey = ffj_t_ObjectReference_UID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ObjectReference_Name, kn) {
					currentKey = ffj_t_ObjectReference_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectReference_Namespace, kn) {
					currentKey = ffj_t_ObjectReference_Namespace
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ObjectReference_Kind, kn) {
					currentKey = ffj_t_ObjectReference_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ObjectReferenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ObjectReference_Kind:
					goto handle_Kind

				case ffj_t_ObjectReference_Namespace:
					goto handle_Namespace

				case ffj_t_ObjectReference_Name:
					goto handle_Name

				case ffj_t_ObjectReference_UID:
					goto handle_UID

				case ffj_t_ObjectReference_APIVersion:
					goto handle_APIVersion

				case ffj_t_ObjectReference_ResourceVersion:
					goto handle_ResourceVersion

				case ffj_t_ObjectReference_FieldPath:
					goto handle_FieldPath

				case ffj_t_ObjectReferenceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Namespace:

	/* handler: uj.Namespace type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Namespace = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UID:

	/* handler: uj.UID type=types.UID kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for UID", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.UID = types.UID(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResourceVersion:

	/* handler: uj.ResourceVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ResourceVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FieldPath:

	/* handler: uj.FieldPath type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FieldPath = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolume) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolume) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumebase = iota
	ffj_t_PersistentVolumeno_such_key

	ffj_t_PersistentVolume_ObjectMeta

	ffj_t_PersistentVolume_Spec

	ffj_t_PersistentVolume_Status

	ffj_t_PersistentVolume_Kind

	ffj_t_PersistentVolume_APIVersion
)

var ffj_key_PersistentVolume_ObjectMeta = []byte("metadata")

var ffj_key_PersistentVolume_Spec = []byte("spec")

var ffj_key_PersistentVolume_Status = []byte("status")

var ffj_key_PersistentVolume_Kind = []byte("kind")

var ffj_key_PersistentVolume_APIVersion = []byte("apiVersion")

func (uj *PersistentVolume) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolume) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolume_APIVersion, kn) {
						currentKey = ffj_t_PersistentVolume_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PersistentVolume_Kind, kn) {
						currentKey = ffj_t_PersistentVolume_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PersistentVolume_ObjectMeta, kn) {
						currentKey = ffj_t_PersistentVolume_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PersistentVolume_Spec, kn) {
						currentKey = ffj_t_PersistentVolume_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PersistentVolume_Status, kn) {
						currentKey = ffj_t_PersistentVolume_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolume_APIVersion, kn) {
					currentKey = ffj_t_PersistentVolume_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolume_Kind, kn) {
					currentKey = ffj_t_PersistentVolume_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolume_Status, kn) {
					currentKey = ffj_t_PersistentVolume_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolume_Spec, kn) {
					currentKey = ffj_t_PersistentVolume_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolume_ObjectMeta, kn) {
					currentKey = ffj_t_PersistentVolume_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolume_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_PersistentVolume_Spec:
					goto handle_Spec

				case ffj_t_PersistentVolume_Status:
					goto handle_Status

				case ffj_t_PersistentVolume_Kind:
					goto handle_Kind

				case ffj_t_PersistentVolume_APIVersion:
					goto handle_APIVersion

				case ffj_t_PersistentVolumeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.PersistentVolumeSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.PersistentVolumeStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeClaim) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeClaim) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeClaimbase = iota
	ffj_t_PersistentVolumeClaimno_such_key

	ffj_t_PersistentVolumeClaim_ObjectMeta

	ffj_t_PersistentVolumeClaim_Spec

	ffj_t_PersistentVolumeClaim_Status

	ffj_t_PersistentVolumeClaim_Kind

	ffj_t_PersistentVolumeClaim_APIVersion
)

var ffj_key_PersistentVolumeClaim_ObjectMeta = []byte("metadata")

var ffj_key_PersistentVolumeClaim_Spec = []byte("spec")

var ffj_key_PersistentVolumeClaim_Status = []byte("status")

var ffj_key_PersistentVolumeClaim_Kind = []byte("kind")

var ffj_key_PersistentVolumeClaim_APIVersion = []byte("apiVersion")

func (uj *PersistentVolumeClaim) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeClaim) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeClaimbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeClaimno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeClaim_APIVersion, kn) {
						currentKey = ffj_t_PersistentVolumeClaim_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PersistentVolumeClaim_Kind, kn) {
						currentKey = ffj_t_PersistentVolumeClaim_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PersistentVolumeClaim_ObjectMeta, kn) {
						currentKey = ffj_t_PersistentVolumeClaim_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PersistentVolumeClaim_Spec, kn) {
						currentKey = ffj_t_PersistentVolumeClaim_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PersistentVolumeClaim_Status, kn) {
						currentKey = ffj_t_PersistentVolumeClaim_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaim_APIVersion, kn) {
					currentKey = ffj_t_PersistentVolumeClaim_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaim_Kind, kn) {
					currentKey = ffj_t_PersistentVolumeClaim_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaim_Status, kn) {
					currentKey = ffj_t_PersistentVolumeClaim_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaim_Spec, kn) {
					currentKey = ffj_t_PersistentVolumeClaim_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeClaim_ObjectMeta, kn) {
					currentKey = ffj_t_PersistentVolumeClaim_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeClaimno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeClaim_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_PersistentVolumeClaim_Spec:
					goto handle_Spec

				case ffj_t_PersistentVolumeClaim_Status:
					goto handle_Status

				case ffj_t_PersistentVolumeClaim_Kind:
					goto handle_Kind

				case ffj_t_PersistentVolumeClaim_APIVersion:
					goto handle_APIVersion

				case ffj_t_PersistentVolumeClaimno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.PersistentVolumeClaimSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.PersistentVolumeClaimStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeClaimList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeClaimList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Items) != 0 {
		buf.WriteString(`"items":`)
		if mj.Items != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Items {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeClaimListbase = iota
	ffj_t_PersistentVolumeClaimListno_such_key

	ffj_t_PersistentVolumeClaimList_ListMeta

	ffj_t_PersistentVolumeClaimList_Items

	ffj_t_PersistentVolumeClaimList_Kind

	ffj_t_PersistentVolumeClaimList_APIVersion
)

var ffj_key_PersistentVolumeClaimList_ListMeta = []byte("metadata")

var ffj_key_PersistentVolumeClaimList_Items = []byte("items")

var ffj_key_PersistentVolumeClaimList_Kind = []byte("kind")

var ffj_key_PersistentVolumeClaimList_APIVersion = []byte("apiVersion")

func (uj *PersistentVolumeClaimList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeClaimList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeClaimListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeClaimListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeClaimList_APIVersion, kn) {
						currentKey = ffj_t_PersistentVolumeClaimList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PersistentVolumeClaimList_Items, kn) {
						currentKey = ffj_t_PersistentVolumeClaimList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PersistentVolumeClaimList_Kind, kn) {
						currentKey = ffj_t_PersistentVolumeClaimList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PersistentVolumeClaimList_ListMeta, kn) {
						currentKey = ffj_t_PersistentVolumeClaimList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimList_APIVersion, kn) {
					currentKey = ffj_t_PersistentVolumeClaimList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimList_Kind, kn) {
					currentKey = ffj_t_PersistentVolumeClaimList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimList_Items, kn) {
					currentKey = ffj_t_PersistentVolumeClaimList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeClaimList_ListMeta, kn) {
					currentKey = ffj_t_PersistentVolumeClaimList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeClaimListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeClaimList_ListMeta:
					goto handle_ListMeta

				case ffj_t_PersistentVolumeClaimList_Items:
					goto handle_Items

				case ffj_t_PersistentVolumeClaimList_Kind:
					goto handle_Kind

				case ffj_t_PersistentVolumeClaimList_APIVersion:
					goto handle_APIVersion

				case ffj_t_PersistentVolumeClaimListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.PersistentVolumeClaim kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]PersistentVolumeClaim, 0)

			wantVal := true

			for {

				var v PersistentVolumeClaim

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PersistentVolumeClaim kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeClaimSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeClaimSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.AccessModes) != 0 {
		buf.WriteString(`"accessModes":`)
		if mj.AccessModes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.AccessModes {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"resources":`)

		{
			err = mj.Resources.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.VolumeName) != 0 {
		buf.WriteString(`"volumeName":`)
		fflib.WriteJsonString(buf, string(mj.VolumeName))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeClaimSpecbase = iota
	ffj_t_PersistentVolumeClaimSpecno_such_key

	ffj_t_PersistentVolumeClaimSpec_AccessModes

	ffj_t_PersistentVolumeClaimSpec_Resources

	ffj_t_PersistentVolumeClaimSpec_VolumeName
)

var ffj_key_PersistentVolumeClaimSpec_AccessModes = []byte("accessModes")

var ffj_key_PersistentVolumeClaimSpec_Resources = []byte("resources")

var ffj_key_PersistentVolumeClaimSpec_VolumeName = []byte("volumeName")

func (uj *PersistentVolumeClaimSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeClaimSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeClaimSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeClaimSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeClaimSpec_AccessModes, kn) {
						currentKey = ffj_t_PersistentVolumeClaimSpec_AccessModes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PersistentVolumeClaimSpec_Resources, kn) {
						currentKey = ffj_t_PersistentVolumeClaimSpec_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_PersistentVolumeClaimSpec_VolumeName, kn) {
						currentKey = ffj_t_PersistentVolumeClaimSpec_VolumeName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeClaimSpec_VolumeName, kn) {
					currentKey = ffj_t_PersistentVolumeClaimSpec_VolumeName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimSpec_Resources, kn) {
					currentKey = ffj_t_PersistentVolumeClaimSpec_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimSpec_AccessModes, kn) {
					currentKey = ffj_t_PersistentVolumeClaimSpec_AccessModes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeClaimSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeClaimSpec_AccessModes:
					goto handle_AccessModes

				case ffj_t_PersistentVolumeClaimSpec_Resources:
					goto handle_Resources

				case ffj_t_PersistentVolumeClaimSpec_VolumeName:
					goto handle_VolumeName

				case ffj_t_PersistentVolumeClaimSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AccessModes:

	/* handler: uj.AccessModes type=[]v1.PersistentVolumeAccessMode kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.AccessModes = nil
		} else {

			uj.AccessModes = make([]PersistentVolumeAccessMode, 0)

			wantVal := true

			for {

				var v PersistentVolumeAccessMode

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PersistentVolumeAccessMode kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PersistentVolumeAccessMode", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = PersistentVolumeAccessMode(fs.Output.String())

					}
				}

				uj.AccessModes = append(uj.AccessModes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=v1.ResourceRequirements kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Resources.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VolumeName:

	/* handler: uj.VolumeName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.VolumeName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeClaimStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeClaimStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Phase) != 0 {
		buf.WriteString(`"phase":`)
		fflib.WriteJsonString(buf, string(mj.Phase))
		buf.WriteByte(',')
	}
	if len(mj.AccessModes) != 0 {
		buf.WriteString(`"accessModes":`)
		if mj.AccessModes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.AccessModes {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Capacity) != 0 {
		buf.WriteString(`"capacity":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Capacity)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeClaimStatusbase = iota
	ffj_t_PersistentVolumeClaimStatusno_such_key

	ffj_t_PersistentVolumeClaimStatus_Phase

	ffj_t_PersistentVolumeClaimStatus_AccessModes

	ffj_t_PersistentVolumeClaimStatus_Capacity
)

var ffj_key_PersistentVolumeClaimStatus_Phase = []byte("phase")

var ffj_key_PersistentVolumeClaimStatus_AccessModes = []byte("accessModes")

var ffj_key_PersistentVolumeClaimStatus_Capacity = []byte("capacity")

func (uj *PersistentVolumeClaimStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeClaimStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeClaimStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeClaimStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeClaimStatus_AccessModes, kn) {
						currentKey = ffj_t_PersistentVolumeClaimStatus_AccessModes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PersistentVolumeClaimStatus_Capacity, kn) {
						currentKey = ffj_t_PersistentVolumeClaimStatus_Capacity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PersistentVolumeClaimStatus_Phase, kn) {
						currentKey = ffj_t_PersistentVolumeClaimStatus_Phase
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeClaimStatus_Capacity, kn) {
					currentKey = ffj_t_PersistentVolumeClaimStatus_Capacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimStatus_AccessModes, kn) {
					currentKey = ffj_t_PersistentVolumeClaimStatus_AccessModes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeClaimStatus_Phase, kn) {
					currentKey = ffj_t_PersistentVolumeClaimStatus_Phase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeClaimStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeClaimStatus_Phase:
					goto handle_Phase

				case ffj_t_PersistentVolumeClaimStatus_AccessModes:
					goto handle_AccessModes

				case ffj_t_PersistentVolumeClaimStatus_Capacity:
					goto handle_Capacity

				case ffj_t_PersistentVolumeClaimStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Phase:

	/* handler: uj.Phase type=v1.PersistentVolumeClaimPhase kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PersistentVolumeClaimPhase", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Phase = PersistentVolumeClaimPhase(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccessModes:

	/* handler: uj.AccessModes type=[]v1.PersistentVolumeAccessMode kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.AccessModes = nil
		} else {

			uj.AccessModes = make([]PersistentVolumeAccessMode, 0)

			wantVal := true

			for {

				var v PersistentVolumeAccessMode

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PersistentVolumeAccessMode kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PersistentVolumeAccessMode", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = PersistentVolumeAccessMode(fs.Output.String())

					}
				}

				uj.AccessModes = append(uj.AccessModes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Capacity:

	/* handler: uj.Capacity type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Capacity)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeClaimVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeClaimVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "claimName":`)
	fflib.WriteJsonString(buf, string(mj.ClaimName))
	buf.WriteByte(',')
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeClaimVolumeSourcebase = iota
	ffj_t_PersistentVolumeClaimVolumeSourceno_such_key

	ffj_t_PersistentVolumeClaimVolumeSource_ClaimName

	ffj_t_PersistentVolumeClaimVolumeSource_ReadOnly
)

var ffj_key_PersistentVolumeClaimVolumeSource_ClaimName = []byte("claimName")

var ffj_key_PersistentVolumeClaimVolumeSource_ReadOnly = []byte("readOnly")

func (uj *PersistentVolumeClaimVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeClaimVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeClaimVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeClaimVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_PersistentVolumeClaimVolumeSource_ClaimName, kn) {
						currentKey = ffj_t_PersistentVolumeClaimVolumeSource_ClaimName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PersistentVolumeClaimVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_PersistentVolumeClaimVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeClaimVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_PersistentVolumeClaimVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeClaimVolumeSource_ClaimName, kn) {
					currentKey = ffj_t_PersistentVolumeClaimVolumeSource_ClaimName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeClaimVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeClaimVolumeSource_ClaimName:
					goto handle_ClaimName

				case ffj_t_PersistentVolumeClaimVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_PersistentVolumeClaimVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ClaimName:

	/* handler: uj.ClaimName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ClaimName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Items) != 0 {
		buf.WriteString(`"items":`)
		if mj.Items != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Items {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeListbase = iota
	ffj_t_PersistentVolumeListno_such_key

	ffj_t_PersistentVolumeList_ListMeta

	ffj_t_PersistentVolumeList_Items

	ffj_t_PersistentVolumeList_Kind

	ffj_t_PersistentVolumeList_APIVersion
)

var ffj_key_PersistentVolumeList_ListMeta = []byte("metadata")

var ffj_key_PersistentVolumeList_Items = []byte("items")

var ffj_key_PersistentVolumeList_Kind = []byte("kind")

var ffj_key_PersistentVolumeList_APIVersion = []byte("apiVersion")

func (uj *PersistentVolumeList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeList_APIVersion, kn) {
						currentKey = ffj_t_PersistentVolumeList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PersistentVolumeList_Items, kn) {
						currentKey = ffj_t_PersistentVolumeList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PersistentVolumeList_Kind, kn) {
						currentKey = ffj_t_PersistentVolumeList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PersistentVolumeList_ListMeta, kn) {
						currentKey = ffj_t_PersistentVolumeList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeList_APIVersion, kn) {
					currentKey = ffj_t_PersistentVolumeList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeList_Kind, kn) {
					currentKey = ffj_t_PersistentVolumeList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeList_Items, kn) {
					currentKey = ffj_t_PersistentVolumeList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeList_ListMeta, kn) {
					currentKey = ffj_t_PersistentVolumeList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeList_ListMeta:
					goto handle_ListMeta

				case ffj_t_PersistentVolumeList_Items:
					goto handle_Items

				case ffj_t_PersistentVolumeList_Kind:
					goto handle_Kind

				case ffj_t_PersistentVolumeList_APIVersion:
					goto handle_APIVersion

				case ffj_t_PersistentVolumeListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.PersistentVolume kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]PersistentVolume, 0)

			wantVal := true

			for {

				var v PersistentVolume

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PersistentVolume kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.GCEPersistentDisk != nil {
		if true {
			buf.WriteString(`"gcePersistentDisk":`)

			{
				err = mj.GCEPersistentDisk.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.AWSElasticBlockStore != nil {
		if true {
			buf.WriteString(`"awsElasticBlockStore":`)

			{
				err = mj.AWSElasticBlockStore.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.HostPath != nil {
		if true {
			buf.WriteString(`"hostPath":`)

			{
				err = mj.HostPath.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Glusterfs != nil {
		if true {
			buf.WriteString(`"glusterfs":`)

			{
				err = mj.Glusterfs.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.NFS != nil {
		if true {
			buf.WriteString(`"nfs":`)

			{
				err = mj.NFS.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.RBD != nil {
		if true {
			buf.WriteString(`"rbd":`)

			{
				err = mj.RBD.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.ISCSI != nil {
		if true {
			buf.WriteString(`"iscsi":`)

			{
				err = mj.ISCSI.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeSourcebase = iota
	ffj_t_PersistentVolumeSourceno_such_key

	ffj_t_PersistentVolumeSource_GCEPersistentDisk

	ffj_t_PersistentVolumeSource_AWSElasticBlockStore

	ffj_t_PersistentVolumeSource_HostPath

	ffj_t_PersistentVolumeSource_Glusterfs

	ffj_t_PersistentVolumeSource_NFS

	ffj_t_PersistentVolumeSource_RBD

	ffj_t_PersistentVolumeSource_ISCSI
)

var ffj_key_PersistentVolumeSource_GCEPersistentDisk = []byte("gcePersistentDisk")

var ffj_key_PersistentVolumeSource_AWSElasticBlockStore = []byte("awsElasticBlockStore")

var ffj_key_PersistentVolumeSource_HostPath = []byte("hostPath")

var ffj_key_PersistentVolumeSource_Glusterfs = []byte("glusterfs")

var ffj_key_PersistentVolumeSource_NFS = []byte("nfs")

var ffj_key_PersistentVolumeSource_RBD = []byte("rbd")

var ffj_key_PersistentVolumeSource_ISCSI = []byte("iscsi")

func (uj *PersistentVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeSource_AWSElasticBlockStore, kn) {
						currentKey = ffj_t_PersistentVolumeSource_AWSElasticBlockStore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_PersistentVolumeSource_GCEPersistentDisk, kn) {
						currentKey = ffj_t_PersistentVolumeSource_GCEPersistentDisk
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PersistentVolumeSource_Glusterfs, kn) {
						currentKey = ffj_t_PersistentVolumeSource_Glusterfs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_PersistentVolumeSource_HostPath, kn) {
						currentKey = ffj_t_PersistentVolumeSource_HostPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PersistentVolumeSource_ISCSI, kn) {
						currentKey = ffj_t_PersistentVolumeSource_ISCSI
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_PersistentVolumeSource_NFS, kn) {
						currentKey = ffj_t_PersistentVolumeSource_NFS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PersistentVolumeSource_RBD, kn) {
						currentKey = ffj_t_PersistentVolumeSource_RBD
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSource_ISCSI, kn) {
					currentKey = ffj_t_PersistentVolumeSource_ISCSI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeSource_RBD, kn) {
					currentKey = ffj_t_PersistentVolumeSource_RBD
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSource_NFS, kn) {
					currentKey = ffj_t_PersistentVolumeSource_NFS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSource_Glusterfs, kn) {
					currentKey = ffj_t_PersistentVolumeSource_Glusterfs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSource_HostPath, kn) {
					currentKey = ffj_t_PersistentVolumeSource_HostPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSource_AWSElasticBlockStore, kn) {
					currentKey = ffj_t_PersistentVolumeSource_AWSElasticBlockStore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSource_GCEPersistentDisk, kn) {
					currentKey = ffj_t_PersistentVolumeSource_GCEPersistentDisk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeSource_GCEPersistentDisk:
					goto handle_GCEPersistentDisk

				case ffj_t_PersistentVolumeSource_AWSElasticBlockStore:
					goto handle_AWSElasticBlockStore

				case ffj_t_PersistentVolumeSource_HostPath:
					goto handle_HostPath

				case ffj_t_PersistentVolumeSource_Glusterfs:
					goto handle_Glusterfs

				case ffj_t_PersistentVolumeSource_NFS:
					goto handle_NFS

				case ffj_t_PersistentVolumeSource_RBD:
					goto handle_RBD

				case ffj_t_PersistentVolumeSource_ISCSI:
					goto handle_ISCSI

				case ffj_t_PersistentVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GCEPersistentDisk:

	/* handler: uj.GCEPersistentDisk type=v1.GCEPersistentDiskVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.GCEPersistentDisk = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GCEPersistentDisk == nil {
			uj.GCEPersistentDisk = new(GCEPersistentDiskVolumeSource)
		}

		err = uj.GCEPersistentDisk.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AWSElasticBlockStore:

	/* handler: uj.AWSElasticBlockStore type=v1.AWSElasticBlockStoreVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.AWSElasticBlockStore = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AWSElasticBlockStore == nil {
			uj.AWSElasticBlockStore = new(AWSElasticBlockStoreVolumeSource)
		}

		err = uj.AWSElasticBlockStore.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostPath:

	/* handler: uj.HostPath type=v1.HostPathVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.HostPath = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HostPath == nil {
			uj.HostPath = new(HostPathVolumeSource)
		}

		err = uj.HostPath.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Glusterfs:

	/* handler: uj.Glusterfs type=v1.GlusterfsVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Glusterfs = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Glusterfs == nil {
			uj.Glusterfs = new(GlusterfsVolumeSource)
		}

		err = uj.Glusterfs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NFS:

	/* handler: uj.NFS type=v1.NFSVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.NFS = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NFS == nil {
			uj.NFS = new(NFSVolumeSource)
		}

		err = uj.NFS.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RBD:

	/* handler: uj.RBD type=v1.RBDVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.RBD = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RBD == nil {
			uj.RBD = new(RBDVolumeSource)
		}

		err = uj.RBD.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ISCSI:

	/* handler: uj.ISCSI type=v1.ISCSIVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ISCSI = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ISCSI == nil {
			uj.ISCSI = new(ISCSIVolumeSource)
		}

		err = uj.ISCSI.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Capacity) != 0 {
		buf.WriteString(`"capacity":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Capacity)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.AccessModes) != 0 {
		buf.WriteString(`"accessModes":`)
		if mj.AccessModes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.AccessModes {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.ClaimRef != nil {
		if true {
			buf.WriteString(`"claimRef":`)

			{
				err = mj.ClaimRef.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if len(mj.PersistentVolumeReclaimPolicy) != 0 {
		buf.WriteString(`"persistentVolumeReclaimPolicy":`)
		fflib.WriteJsonString(buf, string(mj.PersistentVolumeReclaimPolicy))
		buf.WriteByte(',')
	}
	if mj.GCEPersistentDisk != nil {
		if true {
			buf.WriteString(`"gcePersistentDisk":`)

			{
				err = mj.GCEPersistentDisk.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.AWSElasticBlockStore != nil {
		if true {
			buf.WriteString(`"awsElasticBlockStore":`)

			{
				err = mj.AWSElasticBlockStore.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.HostPath != nil {
		if true {
			buf.WriteString(`"hostPath":`)

			{
				err = mj.HostPath.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Glusterfs != nil {
		if true {
			buf.WriteString(`"glusterfs":`)

			{
				err = mj.Glusterfs.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.NFS != nil {
		if true {
			buf.WriteString(`"nfs":`)

			{
				err = mj.NFS.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.RBD != nil {
		if true {
			buf.WriteString(`"rbd":`)

			{
				err = mj.RBD.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.ISCSI != nil {
		if true {
			buf.WriteString(`"iscsi":`)

			{
				err = mj.ISCSI.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeSpecbase = iota
	ffj_t_PersistentVolumeSpecno_such_key

	ffj_t_PersistentVolumeSpec_Capacity

	ffj_t_PersistentVolumeSpec_AccessModes

	ffj_t_PersistentVolumeSpec_ClaimRef

	ffj_t_PersistentVolumeSpec_PersistentVolumeReclaimPolicy

	ffj_t_PersistentVolumeSpec_GCEPersistentDisk

	ffj_t_PersistentVolumeSpec_AWSElasticBlockStore

	ffj_t_PersistentVolumeSpec_HostPath

	ffj_t_PersistentVolumeSpec_Glusterfs

	ffj_t_PersistentVolumeSpec_NFS

	ffj_t_PersistentVolumeSpec_RBD

	ffj_t_PersistentVolumeSpec_ISCSI
)

var ffj_key_PersistentVolumeSpec_Capacity = []byte("capacity")

var ffj_key_PersistentVolumeSpec_AccessModes = []byte("accessModes")

var ffj_key_PersistentVolumeSpec_ClaimRef = []byte("claimRef")

var ffj_key_PersistentVolumeSpec_PersistentVolumeReclaimPolicy = []byte("persistentVolumeReclaimPolicy")

var ffj_key_PersistentVolumeSpec_GCEPersistentDisk = []byte("gcePersistentDisk")

var ffj_key_PersistentVolumeSpec_AWSElasticBlockStore = []byte("awsElasticBlockStore")

var ffj_key_PersistentVolumeSpec_HostPath = []byte("hostPath")

var ffj_key_PersistentVolumeSpec_Glusterfs = []byte("glusterfs")

var ffj_key_PersistentVolumeSpec_NFS = []byte("nfs")

var ffj_key_PersistentVolumeSpec_RBD = []byte("rbd")

var ffj_key_PersistentVolumeSpec_ISCSI = []byte("iscsi")

func (uj *PersistentVolumeSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_AccessModes, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_AccessModes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PersistentVolumeSpec_AWSElasticBlockStore, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_AWSElasticBlockStore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_Capacity, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_Capacity
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PersistentVolumeSpec_ClaimRef, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_ClaimRef
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_GCEPersistentDisk, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_GCEPersistentDisk
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PersistentVolumeSpec_Glusterfs, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_Glusterfs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_HostPath, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_HostPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_ISCSI, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_ISCSI
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_NFS, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_NFS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_PersistentVolumeReclaimPolicy, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_PersistentVolumeReclaimPolicy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PersistentVolumeSpec_RBD, kn) {
						currentKey = ffj_t_PersistentVolumeSpec_RBD
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_ISCSI, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_ISCSI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeSpec_RBD, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_RBD
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_NFS, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_NFS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_Glusterfs, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_Glusterfs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_HostPath, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_HostPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_AWSElasticBlockStore, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_AWSElasticBlockStore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_GCEPersistentDisk, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_GCEPersistentDisk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_PersistentVolumeReclaimPolicy, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_PersistentVolumeReclaimPolicy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeSpec_ClaimRef, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_ClaimRef
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeSpec_AccessModes, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_AccessModes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PersistentVolumeSpec_Capacity, kn) {
					currentKey = ffj_t_PersistentVolumeSpec_Capacity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeSpec_Capacity:
					goto handle_Capacity

				case ffj_t_PersistentVolumeSpec_AccessModes:
					goto handle_AccessModes

				case ffj_t_PersistentVolumeSpec_ClaimRef:
					goto handle_ClaimRef

				case ffj_t_PersistentVolumeSpec_PersistentVolumeReclaimPolicy:
					goto handle_PersistentVolumeReclaimPolicy

				case ffj_t_PersistentVolumeSpec_GCEPersistentDisk:
					goto handle_GCEPersistentDisk

				case ffj_t_PersistentVolumeSpec_AWSElasticBlockStore:
					goto handle_AWSElasticBlockStore

				case ffj_t_PersistentVolumeSpec_HostPath:
					goto handle_HostPath

				case ffj_t_PersistentVolumeSpec_Glusterfs:
					goto handle_Glusterfs

				case ffj_t_PersistentVolumeSpec_NFS:
					goto handle_NFS

				case ffj_t_PersistentVolumeSpec_RBD:
					goto handle_RBD

				case ffj_t_PersistentVolumeSpec_ISCSI:
					goto handle_ISCSI

				case ffj_t_PersistentVolumeSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Capacity:

	/* handler: uj.Capacity type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Capacity)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccessModes:

	/* handler: uj.AccessModes type=[]v1.PersistentVolumeAccessMode kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.AccessModes = nil
		} else {

			uj.AccessModes = make([]PersistentVolumeAccessMode, 0)

			wantVal := true

			for {

				var v PersistentVolumeAccessMode

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PersistentVolumeAccessMode kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PersistentVolumeAccessMode", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = PersistentVolumeAccessMode(fs.Output.String())

					}
				}

				uj.AccessModes = append(uj.AccessModes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClaimRef:

	/* handler: uj.ClaimRef type=v1.ObjectReference kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ClaimRef = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ClaimRef == nil {
			uj.ClaimRef = new(ObjectReference)
		}

		err = uj.ClaimRef.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PersistentVolumeReclaimPolicy:

	/* handler: uj.PersistentVolumeReclaimPolicy type=v1.PersistentVolumeReclaimPolicy kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PersistentVolumeReclaimPolicy", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.PersistentVolumeReclaimPolicy = PersistentVolumeReclaimPolicy(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GCEPersistentDisk:

	/* handler: uj.GCEPersistentDisk type=v1.GCEPersistentDiskVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.GCEPersistentDisk = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GCEPersistentDisk == nil {
			uj.GCEPersistentDisk = new(GCEPersistentDiskVolumeSource)
		}

		err = uj.GCEPersistentDisk.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AWSElasticBlockStore:

	/* handler: uj.AWSElasticBlockStore type=v1.AWSElasticBlockStoreVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.AWSElasticBlockStore = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AWSElasticBlockStore == nil {
			uj.AWSElasticBlockStore = new(AWSElasticBlockStoreVolumeSource)
		}

		err = uj.AWSElasticBlockStore.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostPath:

	/* handler: uj.HostPath type=v1.HostPathVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.HostPath = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HostPath == nil {
			uj.HostPath = new(HostPathVolumeSource)
		}

		err = uj.HostPath.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Glusterfs:

	/* handler: uj.Glusterfs type=v1.GlusterfsVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Glusterfs = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Glusterfs == nil {
			uj.Glusterfs = new(GlusterfsVolumeSource)
		}

		err = uj.Glusterfs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NFS:

	/* handler: uj.NFS type=v1.NFSVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.NFS = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NFS == nil {
			uj.NFS = new(NFSVolumeSource)
		}

		err = uj.NFS.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RBD:

	/* handler: uj.RBD type=v1.RBDVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.RBD = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RBD == nil {
			uj.RBD = new(RBDVolumeSource)
		}

		err = uj.RBD.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ISCSI:

	/* handler: uj.ISCSI type=v1.ISCSIVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ISCSI = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ISCSI == nil {
			uj.ISCSI = new(ISCSIVolumeSource)
		}

		err = uj.ISCSI.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PersistentVolumeStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PersistentVolumeStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Phase) != 0 {
		buf.WriteString(`"phase":`)
		fflib.WriteJsonString(buf, string(mj.Phase))
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if len(mj.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Reason))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PersistentVolumeStatusbase = iota
	ffj_t_PersistentVolumeStatusno_such_key

	ffj_t_PersistentVolumeStatus_Phase

	ffj_t_PersistentVolumeStatus_Message

	ffj_t_PersistentVolumeStatus_Reason
)

var ffj_key_PersistentVolumeStatus_Phase = []byte("phase")

var ffj_key_PersistentVolumeStatus_Message = []byte("message")

var ffj_key_PersistentVolumeStatus_Reason = []byte("reason")

func (uj *PersistentVolumeStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PersistentVolumeStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PersistentVolumeStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PersistentVolumeStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_PersistentVolumeStatus_Message, kn) {
						currentKey = ffj_t_PersistentVolumeStatus_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PersistentVolumeStatus_Phase, kn) {
						currentKey = ffj_t_PersistentVolumeStatus_Phase
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PersistentVolumeStatus_Reason, kn) {
						currentKey = ffj_t_PersistentVolumeStatus_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeStatus_Reason, kn) {
					currentKey = ffj_t_PersistentVolumeStatus_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeStatus_Message, kn) {
					currentKey = ffj_t_PersistentVolumeStatus_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PersistentVolumeStatus_Phase, kn) {
					currentKey = ffj_t_PersistentVolumeStatus_Phase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PersistentVolumeStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PersistentVolumeStatus_Phase:
					goto handle_Phase

				case ffj_t_PersistentVolumeStatus_Message:
					goto handle_Message

				case ffj_t_PersistentVolumeStatus_Reason:
					goto handle_Reason

				case ffj_t_PersistentVolumeStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Phase:

	/* handler: uj.Phase type=v1.PersistentVolumePhase kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PersistentVolumePhase", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Phase = PersistentVolumePhase(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Reason = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Pod) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Pod) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Podbase = iota
	ffj_t_Podno_such_key

	ffj_t_Pod_ObjectMeta

	ffj_t_Pod_Spec

	ffj_t_Pod_Status

	ffj_t_Pod_Kind

	ffj_t_Pod_APIVersion
)

var ffj_key_Pod_ObjectMeta = []byte("metadata")

var ffj_key_Pod_Spec = []byte("spec")

var ffj_key_Pod_Status = []byte("status")

var ffj_key_Pod_Kind = []byte("kind")

var ffj_key_Pod_APIVersion = []byte("apiVersion")

func (uj *Pod) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Pod) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Podbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Podno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Pod_APIVersion, kn) {
						currentKey = ffj_t_Pod_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Pod_Kind, kn) {
						currentKey = ffj_t_Pod_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Pod_ObjectMeta, kn) {
						currentKey = ffj_t_Pod_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Pod_Spec, kn) {
						currentKey = ffj_t_Pod_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Pod_Status, kn) {
						currentKey = ffj_t_Pod_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Pod_APIVersion, kn) {
					currentKey = ffj_t_Pod_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Pod_Kind, kn) {
					currentKey = ffj_t_Pod_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Pod_Status, kn) {
					currentKey = ffj_t_Pod_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Pod_Spec, kn) {
					currentKey = ffj_t_Pod_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Pod_ObjectMeta, kn) {
					currentKey = ffj_t_Pod_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Podno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Pod_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Pod_Spec:
					goto handle_Spec

				case ffj_t_Pod_Status:
					goto handle_Status

				case ffj_t_Pod_Kind:
					goto handle_Kind

				case ffj_t_Pod_APIVersion:
					goto handle_APIVersion

				case ffj_t_Podno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.PodSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.PodStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodCondition) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodCondition) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"status":`)
	fflib.WriteJsonString(buf, string(mj.Status))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodConditionbase = iota
	ffj_t_PodConditionno_such_key

	ffj_t_PodCondition_Type

	ffj_t_PodCondition_Status
)

var ffj_key_PodCondition_Type = []byte("type")

var ffj_key_PodCondition_Status = []byte("status")

func (uj *PodCondition) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodCondition) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodConditionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodConditionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffj_key_PodCondition_Status, kn) {
						currentKey = ffj_t_PodCondition_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PodCondition_Type, kn) {
						currentKey = ffj_t_PodCondition_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodCondition_Status, kn) {
					currentKey = ffj_t_PodCondition_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodCondition_Type, kn) {
					currentKey = ffj_t_PodCondition_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodConditionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodCondition_Type:
					goto handle_Type

				case ffj_t_PodCondition_Status:
					goto handle_Status

				case ffj_t_PodConditionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=v1.PodConditionType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PodConditionType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = PodConditionType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.ConditionStatus kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ConditionStatus", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Status = ConditionStatus(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodExecOptions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodExecOptions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Stdin != false {
		if mj.Stdin {
			buf.WriteString(`"stdin":true`)
		} else {
			buf.WriteString(`"stdin":false`)
		}
		buf.WriteByte(',')
	}
	if mj.Stdout != false {
		if mj.Stdout {
			buf.WriteString(`"stdout":true`)
		} else {
			buf.WriteString(`"stdout":false`)
		}
		buf.WriteByte(',')
	}
	if mj.Stderr != false {
		if mj.Stderr {
			buf.WriteString(`"stderr":true`)
		} else {
			buf.WriteString(`"stderr":false`)
		}
		buf.WriteByte(',')
	}
	if mj.TTY != false {
		if mj.TTY {
			buf.WriteString(`"tty":true`)
		} else {
			buf.WriteString(`"tty":false`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Container) != 0 {
		buf.WriteString(`"container":`)
		fflib.WriteJsonString(buf, string(mj.Container))
		buf.WriteByte(',')
	}
	buf.WriteString(`"command":`)
	if mj.Command != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Command {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodExecOptionsbase = iota
	ffj_t_PodExecOptionsno_such_key

	ffj_t_PodExecOptions_Stdin

	ffj_t_PodExecOptions_Stdout

	ffj_t_PodExecOptions_Stderr

	ffj_t_PodExecOptions_TTY

	ffj_t_PodExecOptions_Container

	ffj_t_PodExecOptions_Command

	ffj_t_PodExecOptions_Kind

	ffj_t_PodExecOptions_APIVersion
)

var ffj_key_PodExecOptions_Stdin = []byte("stdin")

var ffj_key_PodExecOptions_Stdout = []byte("stdout")

var ffj_key_PodExecOptions_Stderr = []byte("stderr")

var ffj_key_PodExecOptions_TTY = []byte("tty")

var ffj_key_PodExecOptions_Container = []byte("container")

var ffj_key_PodExecOptions_Command = []byte("command")

var ffj_key_PodExecOptions_Kind = []byte("kind")

var ffj_key_PodExecOptions_APIVersion = []byte("apiVersion")

func (uj *PodExecOptions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodExecOptions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodExecOptionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodExecOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodExecOptions_APIVersion, kn) {
						currentKey = ffj_t_PodExecOptions_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PodExecOptions_Container, kn) {
						currentKey = ffj_t_PodExecOptions_Container
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PodExecOptions_Command, kn) {
						currentKey = ffj_t_PodExecOptions_Command
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodExecOptions_Kind, kn) {
						currentKey = ffj_t_PodExecOptions_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PodExecOptions_Stdin, kn) {
						currentKey = ffj_t_PodExecOptions_Stdin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PodExecOptions_Stdout, kn) {
						currentKey = ffj_t_PodExecOptions_Stdout
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PodExecOptions_Stderr, kn) {
						currentKey = ffj_t_PodExecOptions_Stderr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PodExecOptions_TTY, kn) {
						currentKey = ffj_t_PodExecOptions_TTY
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodExecOptions_APIVersion, kn) {
					currentKey = ffj_t_PodExecOptions_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodExecOptions_Kind, kn) {
					currentKey = ffj_t_PodExecOptions_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodExecOptions_Command, kn) {
					currentKey = ffj_t_PodExecOptions_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodExecOptions_Container, kn) {
					currentKey = ffj_t_PodExecOptions_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodExecOptions_TTY, kn) {
					currentKey = ffj_t_PodExecOptions_TTY
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodExecOptions_Stderr, kn) {
					currentKey = ffj_t_PodExecOptions_Stderr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodExecOptions_Stdout, kn) {
					currentKey = ffj_t_PodExecOptions_Stdout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodExecOptions_Stdin, kn) {
					currentKey = ffj_t_PodExecOptions_Stdin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodExecOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodExecOptions_Stdin:
					goto handle_Stdin

				case ffj_t_PodExecOptions_Stdout:
					goto handle_Stdout

				case ffj_t_PodExecOptions_Stderr:
					goto handle_Stderr

				case ffj_t_PodExecOptions_TTY:
					goto handle_TTY

				case ffj_t_PodExecOptions_Container:
					goto handle_Container

				case ffj_t_PodExecOptions_Command:
					goto handle_Command

				case ffj_t_PodExecOptions_Kind:
					goto handle_Kind

				case ffj_t_PodExecOptions_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodExecOptionsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Stdin:

	/* handler: uj.Stdin type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Stdin = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Stdin = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stdout:

	/* handler: uj.Stdout type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Stdout = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Stdout = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stderr:

	/* handler: uj.Stderr type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Stderr = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Stderr = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TTY:

	/* handler: uj.TTY type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.TTY = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.TTY = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Container = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=[]string kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Command = nil
		} else {

			uj.Command = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = string(fs.Output.String())

					}
				}

				uj.Command = append(uj.Command, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodListbase = iota
	ffj_t_PodListno_such_key

	ffj_t_PodList_ListMeta

	ffj_t_PodList_Items

	ffj_t_PodList_Kind

	ffj_t_PodList_APIVersion
)

var ffj_key_PodList_ListMeta = []byte("metadata")

var ffj_key_PodList_Items = []byte("items")

var ffj_key_PodList_Kind = []byte("kind")

var ffj_key_PodList_APIVersion = []byte("apiVersion")

func (uj *PodList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodList_APIVersion, kn) {
						currentKey = ffj_t_PodList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PodList_Items, kn) {
						currentKey = ffj_t_PodList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodList_Kind, kn) {
						currentKey = ffj_t_PodList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PodList_ListMeta, kn) {
						currentKey = ffj_t_PodList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodList_APIVersion, kn) {
					currentKey = ffj_t_PodList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodList_Kind, kn) {
					currentKey = ffj_t_PodList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodList_Items, kn) {
					currentKey = ffj_t_PodList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodList_ListMeta, kn) {
					currentKey = ffj_t_PodList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodList_ListMeta:
					goto handle_ListMeta

				case ffj_t_PodList_Items:
					goto handle_Items

				case ffj_t_PodList_Kind:
					goto handle_Kind

				case ffj_t_PodList_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Pod kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Pod, 0)

			wantVal := true

			for {

				var v Pod

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Pod kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodLogOptions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodLogOptions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Container) != 0 {
		buf.WriteString(`"container":`)
		fflib.WriteJsonString(buf, string(mj.Container))
		buf.WriteByte(',')
	}
	if mj.Follow != false {
		if mj.Follow {
			buf.WriteString(`"follow":true`)
		} else {
			buf.WriteString(`"follow":false`)
		}
		buf.WriteByte(',')
	}
	if mj.Previous != false {
		if mj.Previous {
			buf.WriteString(`"previous":true`)
		} else {
			buf.WriteString(`"previous":false`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodLogOptionsbase = iota
	ffj_t_PodLogOptionsno_such_key

	ffj_t_PodLogOptions_Container

	ffj_t_PodLogOptions_Follow

	ffj_t_PodLogOptions_Previous

	ffj_t_PodLogOptions_Kind

	ffj_t_PodLogOptions_APIVersion
)

var ffj_key_PodLogOptions_Container = []byte("container")

var ffj_key_PodLogOptions_Follow = []byte("follow")

var ffj_key_PodLogOptions_Previous = []byte("previous")

var ffj_key_PodLogOptions_Kind = []byte("kind")

var ffj_key_PodLogOptions_APIVersion = []byte("apiVersion")

func (uj *PodLogOptions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodLogOptions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodLogOptionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodLogOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodLogOptions_APIVersion, kn) {
						currentKey = ffj_t_PodLogOptions_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PodLogOptions_Container, kn) {
						currentKey = ffj_t_PodLogOptions_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_PodLogOptions_Follow, kn) {
						currentKey = ffj_t_PodLogOptions_Follow
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodLogOptions_Kind, kn) {
						currentKey = ffj_t_PodLogOptions_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PodLogOptions_Previous, kn) {
						currentKey = ffj_t_PodLogOptions_Previous
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodLogOptions_APIVersion, kn) {
					currentKey = ffj_t_PodLogOptions_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodLogOptions_Kind, kn) {
					currentKey = ffj_t_PodLogOptions_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodLogOptions_Previous, kn) {
					currentKey = ffj_t_PodLogOptions_Previous
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodLogOptions_Follow, kn) {
					currentKey = ffj_t_PodLogOptions_Follow
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodLogOptions_Container, kn) {
					currentKey = ffj_t_PodLogOptions_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodLogOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodLogOptions_Container:
					goto handle_Container

				case ffj_t_PodLogOptions_Follow:
					goto handle_Follow

				case ffj_t_PodLogOptions_Previous:
					goto handle_Previous

				case ffj_t_PodLogOptions_Kind:
					goto handle_Kind

				case ffj_t_PodLogOptions_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodLogOptionsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Container:

	/* handler: uj.Container type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Container = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Follow:

	/* handler: uj.Follow type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Follow = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Follow = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Previous:

	/* handler: uj.Previous type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Previous = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Previous = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodProxyOptions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodProxyOptions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Path) != 0 {
		buf.WriteString(`"path":`)
		fflib.WriteJsonString(buf, string(mj.Path))
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodProxyOptionsbase = iota
	ffj_t_PodProxyOptionsno_such_key

	ffj_t_PodProxyOptions_Path

	ffj_t_PodProxyOptions_Kind

	ffj_t_PodProxyOptions_APIVersion
)

var ffj_key_PodProxyOptions_Path = []byte("path")

var ffj_key_PodProxyOptions_Kind = []byte("kind")

var ffj_key_PodProxyOptions_APIVersion = []byte("apiVersion")

func (uj *PodProxyOptions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodProxyOptions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodProxyOptionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodProxyOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodProxyOptions_APIVersion, kn) {
						currentKey = ffj_t_PodProxyOptions_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodProxyOptions_Kind, kn) {
						currentKey = ffj_t_PodProxyOptions_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PodProxyOptions_Path, kn) {
						currentKey = ffj_t_PodProxyOptions_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodProxyOptions_APIVersion, kn) {
					currentKey = ffj_t_PodProxyOptions_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodProxyOptions_Kind, kn) {
					currentKey = ffj_t_PodProxyOptions_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodProxyOptions_Path, kn) {
					currentKey = ffj_t_PodProxyOptions_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodProxyOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodProxyOptions_Path:
					goto handle_Path

				case ffj_t_PodProxyOptions_Kind:
					goto handle_Kind

				case ffj_t_PodProxyOptions_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodProxyOptionsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Path:

	/* handler: uj.Path type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Path = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Volumes) != 0 {
		buf.WriteString(`"volumes":`)
		if mj.Volumes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Volumes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"containers":`)
	if mj.Containers != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Containers {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.RestartPolicy) != 0 {
		buf.WriteString(`"restartPolicy":`)
		fflib.WriteJsonString(buf, string(mj.RestartPolicy))
		buf.WriteByte(',')
	}
	if mj.TerminationGracePeriodSeconds != nil {
		if true {
			buf.WriteString(`"terminationGracePeriodSeconds":`)
			fflib.FormatBits2(buf, uint64(*mj.TerminationGracePeriodSeconds), 10, *mj.TerminationGracePeriodSeconds < 0)
			buf.WriteByte(',')
		}
	}
	if mj.ActiveDeadlineSeconds != nil {
		if true {
			buf.WriteString(`"activeDeadlineSeconds":`)
			fflib.FormatBits2(buf, uint64(*mj.ActiveDeadlineSeconds), 10, *mj.ActiveDeadlineSeconds < 0)
			buf.WriteByte(',')
		}
	}
	if len(mj.DNSPolicy) != 0 {
		buf.WriteString(`"dnsPolicy":`)
		fflib.WriteJsonString(buf, string(mj.DNSPolicy))
		buf.WriteByte(',')
	}
	if len(mj.NodeSelector) != 0 {
		if mj.NodeSelector == nil {
			buf.WriteString(`"nodeSelector":null`)
		} else {
			buf.WriteString(`"nodeSelector":{ `)
			for key, value := range mj.NodeSelector {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if len(mj.ServiceAccount) != 0 {
		buf.WriteString(`"serviceAccount":`)
		fflib.WriteJsonString(buf, string(mj.ServiceAccount))
		buf.WriteByte(',')
	}
	if len(mj.NodeName) != 0 {
		buf.WriteString(`"nodeName":`)
		fflib.WriteJsonString(buf, string(mj.NodeName))
		buf.WriteByte(',')
	}
	if mj.HostNetwork != false {
		if mj.HostNetwork {
			buf.WriteString(`"hostNetwork":true`)
		} else {
			buf.WriteString(`"hostNetwork":false`)
		}
		buf.WriteByte(',')
	}
	if len(mj.ImagePullSecrets) != 0 {
		buf.WriteString(`"imagePullSecrets":`)
		if mj.ImagePullSecrets != nil {
			buf.WriteString(`[`)
			for i, v := range mj.ImagePullSecrets {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodSpecbase = iota
	ffj_t_PodSpecno_such_key

	ffj_t_PodSpec_Volumes

	ffj_t_PodSpec_Containers

	ffj_t_PodSpec_RestartPolicy

	ffj_t_PodSpec_TerminationGracePeriodSeconds

	ffj_t_PodSpec_ActiveDeadlineSeconds

	ffj_t_PodSpec_DNSPolicy

	ffj_t_PodSpec_NodeSelector

	ffj_t_PodSpec_ServiceAccount

	ffj_t_PodSpec_NodeName

	ffj_t_PodSpec_HostNetwork

	ffj_t_PodSpec_ImagePullSecrets
)

var ffj_key_PodSpec_Volumes = []byte("volumes")

var ffj_key_PodSpec_Containers = []byte("containers")

var ffj_key_PodSpec_RestartPolicy = []byte("restartPolicy")

var ffj_key_PodSpec_TerminationGracePeriodSeconds = []byte("terminationGracePeriodSeconds")

var ffj_key_PodSpec_ActiveDeadlineSeconds = []byte("activeDeadlineSeconds")

var ffj_key_PodSpec_DNSPolicy = []byte("dnsPolicy")

var ffj_key_PodSpec_NodeSelector = []byte("nodeSelector")

var ffj_key_PodSpec_ServiceAccount = []byte("serviceAccount")

var ffj_key_PodSpec_NodeName = []byte("nodeName")

var ffj_key_PodSpec_HostNetwork = []byte("hostNetwork")

var ffj_key_PodSpec_ImagePullSecrets = []byte("imagePullSecrets")

func (uj *PodSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodSpec_ActiveDeadlineSeconds, kn) {
						currentKey = ffj_t_PodSpec_ActiveDeadlineSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PodSpec_Containers, kn) {
						currentKey = ffj_t_PodSpec_Containers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_PodSpec_DNSPolicy, kn) {
						currentKey = ffj_t_PodSpec_DNSPolicy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_PodSpec_HostNetwork, kn) {
						currentKey = ffj_t_PodSpec_HostNetwork
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PodSpec_ImagePullSecrets, kn) {
						currentKey = ffj_t_PodSpec_ImagePullSecrets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_PodSpec_NodeSelector, kn) {
						currentKey = ffj_t_PodSpec_NodeSelector
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PodSpec_NodeName, kn) {
						currentKey = ffj_t_PodSpec_NodeName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_PodSpec_RestartPolicy, kn) {
						currentKey = ffj_t_PodSpec_RestartPolicy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PodSpec_ServiceAccount, kn) {
						currentKey = ffj_t_PodSpec_ServiceAccount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PodSpec_TerminationGracePeriodSeconds, kn) {
						currentKey = ffj_t_PodSpec_TerminationGracePeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_PodSpec_Volumes, kn) {
						currentKey = ffj_t_PodSpec_Volumes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_ImagePullSecrets, kn) {
					currentKey = ffj_t_PodSpec_ImagePullSecrets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_HostNetwork, kn) {
					currentKey = ffj_t_PodSpec_HostNetwork
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodSpec_NodeName, kn) {
					currentKey = ffj_t_PodSpec_NodeName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_ServiceAccount, kn) {
					currentKey = ffj_t_PodSpec_ServiceAccount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_NodeSelector, kn) {
					currentKey = ffj_t_PodSpec_NodeSelector
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_DNSPolicy, kn) {
					currentKey = ffj_t_PodSpec_DNSPolicy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_ActiveDeadlineSeconds, kn) {
					currentKey = ffj_t_PodSpec_ActiveDeadlineSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_TerminationGracePeriodSeconds, kn) {
					currentKey = ffj_t_PodSpec_TerminationGracePeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_RestartPolicy, kn) {
					currentKey = ffj_t_PodSpec_RestartPolicy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_Containers, kn) {
					currentKey = ffj_t_PodSpec_Containers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodSpec_Volumes, kn) {
					currentKey = ffj_t_PodSpec_Volumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodSpec_Volumes:
					goto handle_Volumes

				case ffj_t_PodSpec_Containers:
					goto handle_Containers

				case ffj_t_PodSpec_RestartPolicy:
					goto handle_RestartPolicy

				case ffj_t_PodSpec_TerminationGracePeriodSeconds:
					goto handle_TerminationGracePeriodSeconds

				case ffj_t_PodSpec_ActiveDeadlineSeconds:
					goto handle_ActiveDeadlineSeconds

				case ffj_t_PodSpec_DNSPolicy:
					goto handle_DNSPolicy

				case ffj_t_PodSpec_NodeSelector:
					goto handle_NodeSelector

				case ffj_t_PodSpec_ServiceAccount:
					goto handle_ServiceAccount

				case ffj_t_PodSpec_NodeName:
					goto handle_NodeName

				case ffj_t_PodSpec_HostNetwork:
					goto handle_HostNetwork

				case ffj_t_PodSpec_ImagePullSecrets:
					goto handle_ImagePullSecrets

				case ffj_t_PodSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Volumes:

	/* handler: uj.Volumes type=[]v1.Volume kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Volumes = nil
		} else {

			uj.Volumes = make([]Volume, 0)

			wantVal := true

			for {

				var v Volume

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Volume kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Volumes = append(uj.Volumes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Containers:

	/* handler: uj.Containers type=[]v1.Container kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Containers = nil
		} else {

			uj.Containers = make([]Container, 0)

			wantVal := true

			for {

				var v Container

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Container kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Containers = append(uj.Containers, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RestartPolicy:

	/* handler: uj.RestartPolicy type=v1.RestartPolicy kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for RestartPolicy", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.RestartPolicy = RestartPolicy(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TerminationGracePeriodSeconds:

	/* handler: uj.TerminationGracePeriodSeconds type=int64 kind=int64 */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.TerminationGracePeriodSeconds = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.TerminationGracePeriodSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveDeadlineSeconds:

	/* handler: uj.ActiveDeadlineSeconds type=int64 kind=int64 */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ActiveDeadlineSeconds = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.ActiveDeadlineSeconds = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSPolicy:

	/* handler: uj.DNSPolicy type=v1.DNSPolicy kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for DNSPolicy", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.DNSPolicy = DNSPolicy(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeSelector:

	/* handler: uj.NodeSelector type=map[string]string kind=map */

	{
		/* Falling back. type=map[string]string kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.NodeSelector)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ServiceAccount:

	/* handler: uj.ServiceAccount type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ServiceAccount = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeName:

	/* handler: uj.NodeName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.NodeName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostNetwork:

	/* handler: uj.HostNetwork type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.HostNetwork = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.HostNetwork = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImagePullSecrets:

	/* handler: uj.ImagePullSecrets type=[]v1.LocalObjectReference kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ImagePullSecrets = nil
		} else {

			uj.ImagePullSecrets = make([]LocalObjectReference, 0)

			wantVal := true

			for {

				var v LocalObjectReference

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.LocalObjectReference kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ImagePullSecrets = append(uj.ImagePullSecrets, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Phase) != 0 {
		buf.WriteString(`"phase":`)
		fflib.WriteJsonString(buf, string(mj.Phase))
		buf.WriteByte(',')
	}
	if len(mj.Conditions) != 0 {
		buf.WriteString(`"conditions":`)
		if mj.Conditions != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Conditions {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if len(mj.HostIP) != 0 {
		buf.WriteString(`"hostIP":`)
		fflib.WriteJsonString(buf, string(mj.HostIP))
		buf.WriteByte(',')
	}
	if len(mj.PodIP) != 0 {
		buf.WriteString(`"podIP":`)
		fflib.WriteJsonString(buf, string(mj.PodIP))
		buf.WriteByte(',')
	}
	if mj.StartTime != nil {
		if true {
			buf.WriteString(`"startTime":`)

			{
				obj, err = mj.StartTime.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)
			}

			buf.WriteByte(',')
		}
	}
	if len(mj.ContainerStatuses) != 0 {
		buf.WriteString(`"containerStatuses":`)
		if mj.ContainerStatuses != nil {
			buf.WriteString(`[`)
			for i, v := range mj.ContainerStatuses {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodStatusbase = iota
	ffj_t_PodStatusno_such_key

	ffj_t_PodStatus_Phase

	ffj_t_PodStatus_Conditions

	ffj_t_PodStatus_Message

	ffj_t_PodStatus_HostIP

	ffj_t_PodStatus_PodIP

	ffj_t_PodStatus_StartTime

	ffj_t_PodStatus_ContainerStatuses
)

var ffj_key_PodStatus_Phase = []byte("phase")

var ffj_key_PodStatus_Conditions = []byte("conditions")

var ffj_key_PodStatus_Message = []byte("message")

var ffj_key_PodStatus_HostIP = []byte("hostIP")

var ffj_key_PodStatus_PodIP = []byte("podIP")

var ffj_key_PodStatus_StartTime = []byte("startTime")

var ffj_key_PodStatus_ContainerStatuses = []byte("containerStatuses")

func (uj *PodStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_PodStatus_Conditions, kn) {
						currentKey = ffj_t_PodStatus_Conditions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PodStatus_ContainerStatuses, kn) {
						currentKey = ffj_t_PodStatus_ContainerStatuses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_PodStatus_HostIP, kn) {
						currentKey = ffj_t_PodStatus_HostIP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PodStatus_Message, kn) {
						currentKey = ffj_t_PodStatus_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PodStatus_Phase, kn) {
						currentKey = ffj_t_PodStatus_Phase
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PodStatus_PodIP, kn) {
						currentKey = ffj_t_PodStatus_PodIP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PodStatus_StartTime, kn) {
						currentKey = ffj_t_PodStatus_StartTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodStatus_ContainerStatuses, kn) {
					currentKey = ffj_t_PodStatus_ContainerStatuses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatus_StartTime, kn) {
					currentKey = ffj_t_PodStatus_StartTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodStatus_PodIP, kn) {
					currentKey = ffj_t_PodStatus_PodIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatus_HostIP, kn) {
					currentKey = ffj_t_PodStatus_HostIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatus_Message, kn) {
					currentKey = ffj_t_PodStatus_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatus_Conditions, kn) {
					currentKey = ffj_t_PodStatus_Conditions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatus_Phase, kn) {
					currentKey = ffj_t_PodStatus_Phase
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodStatus_Phase:
					goto handle_Phase

				case ffj_t_PodStatus_Conditions:
					goto handle_Conditions

				case ffj_t_PodStatus_Message:
					goto handle_Message

				case ffj_t_PodStatus_HostIP:
					goto handle_HostIP

				case ffj_t_PodStatus_PodIP:
					goto handle_PodIP

				case ffj_t_PodStatus_StartTime:
					goto handle_StartTime

				case ffj_t_PodStatus_ContainerStatuses:
					goto handle_ContainerStatuses

				case ffj_t_PodStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Phase:

	/* handler: uj.Phase type=v1.PodPhase kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for PodPhase", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Phase = PodPhase(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Conditions:

	/* handler: uj.Conditions type=[]v1.PodCondition kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Conditions = nil
		} else {

			uj.Conditions = make([]PodCondition, 0)

			wantVal := true

			for {

				var v PodCondition

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PodCondition kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Conditions = append(uj.Conditions, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostIP:

	/* handler: uj.HostIP type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.HostIP = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PodIP:

	/* handler: uj.PodIP type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.PodIP = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartTime:

	/* handler: uj.StartTime type=util.Time kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.StartTime = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.StartTime == nil {
			uj.StartTime = new(util.Time)
		}

		err = uj.StartTime.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerStatuses:

	/* handler: uj.ContainerStatuses type=[]v1.ContainerStatus kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ContainerStatuses = nil
		} else {

			uj.ContainerStatuses = make([]ContainerStatus, 0)

			wantVal := true

			for {

				var v ContainerStatus

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ContainerStatus kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ContainerStatuses = append(uj.ContainerStatuses, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodStatusResult) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodStatusResult) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodStatusResultbase = iota
	ffj_t_PodStatusResultno_such_key

	ffj_t_PodStatusResult_ObjectMeta

	ffj_t_PodStatusResult_Status

	ffj_t_PodStatusResult_Kind

	ffj_t_PodStatusResult_APIVersion
)

var ffj_key_PodStatusResult_ObjectMeta = []byte("metadata")

var ffj_key_PodStatusResult_Status = []byte("status")

var ffj_key_PodStatusResult_Kind = []byte("kind")

var ffj_key_PodStatusResult_APIVersion = []byte("apiVersion")

func (uj *PodStatusResult) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodStatusResult) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodStatusResultbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodStatusResultno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodStatusResult_APIVersion, kn) {
						currentKey = ffj_t_PodStatusResult_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodStatusResult_Kind, kn) {
						currentKey = ffj_t_PodStatusResult_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PodStatusResult_ObjectMeta, kn) {
						currentKey = ffj_t_PodStatusResult_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PodStatusResult_Status, kn) {
						currentKey = ffj_t_PodStatusResult_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodStatusResult_APIVersion, kn) {
					currentKey = ffj_t_PodStatusResult_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatusResult_Kind, kn) {
					currentKey = ffj_t_PodStatusResult_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodStatusResult_Status, kn) {
					currentKey = ffj_t_PodStatusResult_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodStatusResult_ObjectMeta, kn) {
					currentKey = ffj_t_PodStatusResult_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodStatusResultno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodStatusResult_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_PodStatusResult_Status:
					goto handle_Status

				case ffj_t_PodStatusResult_Kind:
					goto handle_Kind

				case ffj_t_PodStatusResult_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodStatusResultno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.PodStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodTemplate) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodTemplate) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"template":`)

		{
			err = mj.Template.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodTemplatebase = iota
	ffj_t_PodTemplateno_such_key

	ffj_t_PodTemplate_ObjectMeta

	ffj_t_PodTemplate_Template

	ffj_t_PodTemplate_Kind

	ffj_t_PodTemplate_APIVersion
)

var ffj_key_PodTemplate_ObjectMeta = []byte("metadata")

var ffj_key_PodTemplate_Template = []byte("template")

var ffj_key_PodTemplate_Kind = []byte("kind")

var ffj_key_PodTemplate_APIVersion = []byte("apiVersion")

func (uj *PodTemplate) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodTemplate) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodTemplatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodTemplateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodTemplate_APIVersion, kn) {
						currentKey = ffj_t_PodTemplate_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodTemplate_Kind, kn) {
						currentKey = ffj_t_PodTemplate_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PodTemplate_ObjectMeta, kn) {
						currentKey = ffj_t_PodTemplate_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PodTemplate_Template, kn) {
						currentKey = ffj_t_PodTemplate_Template
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodTemplate_APIVersion, kn) {
					currentKey = ffj_t_PodTemplate_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodTemplate_Kind, kn) {
					currentKey = ffj_t_PodTemplate_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodTemplate_Template, kn) {
					currentKey = ffj_t_PodTemplate_Template
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodTemplate_ObjectMeta, kn) {
					currentKey = ffj_t_PodTemplate_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodTemplateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodTemplate_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_PodTemplate_Template:
					goto handle_Template

				case ffj_t_PodTemplate_Kind:
					goto handle_Kind

				case ffj_t_PodTemplate_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodTemplateno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Template:

	/* handler: uj.Template type=v1.PodTemplateSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Template.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodTemplateList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodTemplateList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodTemplateListbase = iota
	ffj_t_PodTemplateListno_such_key

	ffj_t_PodTemplateList_ListMeta

	ffj_t_PodTemplateList_Items

	ffj_t_PodTemplateList_Kind

	ffj_t_PodTemplateList_APIVersion
)

var ffj_key_PodTemplateList_ListMeta = []byte("metadata")

var ffj_key_PodTemplateList_Items = []byte("items")

var ffj_key_PodTemplateList_Kind = []byte("kind")

var ffj_key_PodTemplateList_APIVersion = []byte("apiVersion")

func (uj *PodTemplateList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodTemplateList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodTemplateListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodTemplateListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PodTemplateList_APIVersion, kn) {
						currentKey = ffj_t_PodTemplateList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PodTemplateList_Items, kn) {
						currentKey = ffj_t_PodTemplateList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_PodTemplateList_Kind, kn) {
						currentKey = ffj_t_PodTemplateList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PodTemplateList_ListMeta, kn) {
						currentKey = ffj_t_PodTemplateList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodTemplateList_APIVersion, kn) {
					currentKey = ffj_t_PodTemplateList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodTemplateList_Kind, kn) {
					currentKey = ffj_t_PodTemplateList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PodTemplateList_Items, kn) {
					currentKey = ffj_t_PodTemplateList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodTemplateList_ListMeta, kn) {
					currentKey = ffj_t_PodTemplateList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodTemplateListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodTemplateList_ListMeta:
					goto handle_ListMeta

				case ffj_t_PodTemplateList_Items:
					goto handle_Items

				case ffj_t_PodTemplateList_Kind:
					goto handle_Kind

				case ffj_t_PodTemplateList_APIVersion:
					goto handle_APIVersion

				case ffj_t_PodTemplateListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.PodTemplate kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]PodTemplate, 0)

			wantVal := true

			for {

				var v PodTemplate

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.PodTemplate kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PodTemplateSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PodTemplateSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PodTemplateSpecbase = iota
	ffj_t_PodTemplateSpecno_such_key

	ffj_t_PodTemplateSpec_ObjectMeta

	ffj_t_PodTemplateSpec_Spec
)

var ffj_key_PodTemplateSpec_ObjectMeta = []byte("metadata")

var ffj_key_PodTemplateSpec_Spec = []byte("spec")

func (uj *PodTemplateSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PodTemplateSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PodTemplateSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PodTemplateSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_PodTemplateSpec_ObjectMeta, kn) {
						currentKey = ffj_t_PodTemplateSpec_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PodTemplateSpec_Spec, kn) {
						currentKey = ffj_t_PodTemplateSpec_Spec
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PodTemplateSpec_Spec, kn) {
					currentKey = ffj_t_PodTemplateSpec_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PodTemplateSpec_ObjectMeta, kn) {
					currentKey = ffj_t_PodTemplateSpec_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PodTemplateSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PodTemplateSpec_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_PodTemplateSpec_Spec:
					goto handle_Spec

				case ffj_t_PodTemplateSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.PodSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Probe) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Probe) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.InitialDelaySeconds != 0 {
		buf.WriteString(`"initialDelaySeconds":`)
		fflib.FormatBits2(buf, uint64(mj.InitialDelaySeconds), 10, mj.InitialDelaySeconds < 0)
		buf.WriteByte(',')
	}
	if mj.TimeoutSeconds != 0 {
		buf.WriteString(`"timeoutSeconds":`)
		fflib.FormatBits2(buf, uint64(mj.TimeoutSeconds), 10, mj.TimeoutSeconds < 0)
		buf.WriteByte(',')
	}
	if mj.Exec != nil {
		if true {
			buf.WriteString(`"exec":`)

			{
				err = mj.Exec.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.HTTPGet != nil {
		if true {
			buf.WriteString(`"httpGet":`)

			{
				err = mj.HTTPGet.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.TCPSocket != nil {
		if true {
			buf.WriteString(`"tcpSocket":`)

			{
				err = mj.TCPSocket.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Probebase = iota
	ffj_t_Probeno_such_key

	ffj_t_Probe_InitialDelaySeconds

	ffj_t_Probe_TimeoutSeconds

	ffj_t_Probe_Exec

	ffj_t_Probe_HTTPGet

	ffj_t_Probe_TCPSocket
)

var ffj_key_Probe_InitialDelaySeconds = []byte("initialDelaySeconds")

var ffj_key_Probe_TimeoutSeconds = []byte("timeoutSeconds")

var ffj_key_Probe_Exec = []byte("exec")

var ffj_key_Probe_HTTPGet = []byte("httpGet")

var ffj_key_Probe_TCPSocket = []byte("tcpSocket")

func (uj *Probe) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Probe) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Probebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Probeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_Probe_Exec, kn) {
						currentKey = ffj_t_Probe_Exec
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Probe_HTTPGet, kn) {
						currentKey = ffj_t_Probe_HTTPGet
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Probe_InitialDelaySeconds, kn) {
						currentKey = ffj_t_Probe_InitialDelaySeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Probe_TimeoutSeconds, kn) {
						currentKey = ffj_t_Probe_TimeoutSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Probe_TCPSocket, kn) {
						currentKey = ffj_t_Probe_TCPSocket
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Probe_TCPSocket, kn) {
					currentKey = ffj_t_Probe_TCPSocket
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Probe_HTTPGet, kn) {
					currentKey = ffj_t_Probe_HTTPGet
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Probe_Exec, kn) {
					currentKey = ffj_t_Probe_Exec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Probe_TimeoutSeconds, kn) {
					currentKey = ffj_t_Probe_TimeoutSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Probe_InitialDelaySeconds, kn) {
					currentKey = ffj_t_Probe_InitialDelaySeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Probeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Probe_InitialDelaySeconds:
					goto handle_InitialDelaySeconds

				case ffj_t_Probe_TimeoutSeconds:
					goto handle_TimeoutSeconds

				case ffj_t_Probe_Exec:
					goto handle_Exec

				case ffj_t_Probe_HTTPGet:
					goto handle_HTTPGet

				case ffj_t_Probe_TCPSocket:
					goto handle_TCPSocket

				case ffj_t_Probeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InitialDelaySeconds:

	/* handler: uj.InitialDelaySeconds type=int64 kind=int64 */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InitialDelaySeconds = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TimeoutSeconds:

	/* handler: uj.TimeoutSeconds type=int64 kind=int64 */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.TimeoutSeconds = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Exec:

	/* handler: uj.Exec type=v1.ExecAction kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Exec = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Exec == nil {
			uj.Exec = new(ExecAction)
		}

		err = uj.Exec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HTTPGet:

	/* handler: uj.HTTPGet type=v1.HTTPGetAction kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.HTTPGet = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HTTPGet == nil {
			uj.HTTPGet = new(HTTPGetAction)
		}

		err = uj.HTTPGet.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TCPSocket:

	/* handler: uj.TCPSocket type=v1.TCPSocketAction kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.TCPSocket = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TCPSocket == nil {
			uj.TCPSocket = new(TCPSocketAction)
		}

		err = uj.TCPSocket.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RBDVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RBDVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "monitors":`)
	if mj.CephMonitors != nil {
		buf.WriteString(`[`)
		for i, v := range mj.CephMonitors {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"image":`)
	fflib.WriteJsonString(buf, string(mj.RBDImage))
	buf.WriteByte(',')
	if len(mj.FSType) != 0 {
		buf.WriteString(`"fsType":`)
		fflib.WriteJsonString(buf, string(mj.FSType))
		buf.WriteByte(',')
	}
	buf.WriteString(`"pool":`)
	fflib.WriteJsonString(buf, string(mj.RBDPool))
	buf.WriteString(`,"user":`)
	fflib.WriteJsonString(buf, string(mj.RadosUser))
	buf.WriteString(`,"keyring":`)
	fflib.WriteJsonString(buf, string(mj.Keyring))
	if mj.SecretRef != nil {
		buf.WriteString(`,"secretRef":`)

		{
			err = mj.SecretRef.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

	} else {
		buf.WriteString(`,"secretRef":null`)
	}
	buf.WriteByte(',')
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RBDVolumeSourcebase = iota
	ffj_t_RBDVolumeSourceno_such_key

	ffj_t_RBDVolumeSource_CephMonitors

	ffj_t_RBDVolumeSource_RBDImage

	ffj_t_RBDVolumeSource_FSType

	ffj_t_RBDVolumeSource_RBDPool

	ffj_t_RBDVolumeSource_RadosUser

	ffj_t_RBDVolumeSource_Keyring

	ffj_t_RBDVolumeSource_SecretRef

	ffj_t_RBDVolumeSource_ReadOnly
)

var ffj_key_RBDVolumeSource_CephMonitors = []byte("monitors")

var ffj_key_RBDVolumeSource_RBDImage = []byte("image")

var ffj_key_RBDVolumeSource_FSType = []byte("fsType")

var ffj_key_RBDVolumeSource_RBDPool = []byte("pool")

var ffj_key_RBDVolumeSource_RadosUser = []byte("user")

var ffj_key_RBDVolumeSource_Keyring = []byte("keyring")

var ffj_key_RBDVolumeSource_SecretRef = []byte("secretRef")

var ffj_key_RBDVolumeSource_ReadOnly = []byte("readOnly")

func (uj *RBDVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RBDVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RBDVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RBDVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_RBDVolumeSource_FSType, kn) {
						currentKey = ffj_t_RBDVolumeSource_FSType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_RBDVolumeSource_RBDImage, kn) {
						currentKey = ffj_t_RBDVolumeSource_RBDImage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_RBDVolumeSource_Keyring, kn) {
						currentKey = ffj_t_RBDVolumeSource_Keyring
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_RBDVolumeSource_CephMonitors, kn) {
						currentKey = ffj_t_RBDVolumeSource_CephMonitors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_RBDVolumeSource_RBDPool, kn) {
						currentKey = ffj_t_RBDVolumeSource_RBDPool
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_RBDVolumeSource_ReadOnly, kn) {
						currentKey = ffj_t_RBDVolumeSource_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_RBDVolumeSource_SecretRef, kn) {
						currentKey = ffj_t_RBDVolumeSource_SecretRef
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_RBDVolumeSource_RadosUser, kn) {
						currentKey = ffj_t_RBDVolumeSource_RadosUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_RBDVolumeSource_ReadOnly, kn) {
					currentKey = ffj_t_RBDVolumeSource_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RBDVolumeSource_SecretRef, kn) {
					currentKey = ffj_t_RBDVolumeSource_SecretRef
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RBDVolumeSource_Keyring, kn) {
					currentKey = ffj_t_RBDVolumeSource_Keyring
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RBDVolumeSource_RadosUser, kn) {
					currentKey = ffj_t_RBDVolumeSource_RadosUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RBDVolumeSource_RBDPool, kn) {
					currentKey = ffj_t_RBDVolumeSource_RBDPool
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RBDVolumeSource_FSType, kn) {
					currentKey = ffj_t_RBDVolumeSource_FSType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RBDVolumeSource_RBDImage, kn) {
					currentKey = ffj_t_RBDVolumeSource_RBDImage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RBDVolumeSource_CephMonitors, kn) {
					currentKey = ffj_t_RBDVolumeSource_CephMonitors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RBDVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RBDVolumeSource_CephMonitors:
					goto handle_CephMonitors

				case ffj_t_RBDVolumeSource_RBDImage:
					goto handle_RBDImage

				case ffj_t_RBDVolumeSource_FSType:
					goto handle_FSType

				case ffj_t_RBDVolumeSource_RBDPool:
					goto handle_RBDPool

				case ffj_t_RBDVolumeSource_RadosUser:
					goto handle_RadosUser

				case ffj_t_RBDVolumeSource_Keyring:
					goto handle_Keyring

				case ffj_t_RBDVolumeSource_SecretRef:
					goto handle_SecretRef

				case ffj_t_RBDVolumeSource_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_RBDVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CephMonitors:

	/* handler: uj.CephMonitors type=[]string kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.CephMonitors = nil
		} else {

			uj.CephMonitors = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = string(fs.Output.String())

					}
				}

				uj.CephMonitors = append(uj.CephMonitors, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RBDImage:

	/* handler: uj.RBDImage type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.RBDImage = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FSType:

	/* handler: uj.FSType type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.FSType = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RBDPool:

	/* handler: uj.RBDPool type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.RBDPool = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RadosUser:

	/* handler: uj.RadosUser type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.RadosUser = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Keyring:

	/* handler: uj.Keyring type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Keyring = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SecretRef:

	/* handler: uj.SecretRef type=v1.LocalObjectReference kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.SecretRef = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.SecretRef == nil {
			uj.SecretRef = new(LocalObjectReference)
		}

		err = uj.SecretRef.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RangeAllocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RangeAllocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"range":`)
	fflib.WriteJsonString(buf, string(mj.Range))
	buf.WriteString(`,"data":`)
	if mj.Data != nil {
		buf.WriteString(`"`)
		{
			enc := base64.NewEncoder(base64.StdEncoding, buf)
			enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
			enc.Close()
		}
		buf.WriteString(`"`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RangeAllocationbase = iota
	ffj_t_RangeAllocationno_such_key

	ffj_t_RangeAllocation_ObjectMeta

	ffj_t_RangeAllocation_Range

	ffj_t_RangeAllocation_Data

	ffj_t_RangeAllocation_Kind

	ffj_t_RangeAllocation_APIVersion
)

var ffj_key_RangeAllocation_ObjectMeta = []byte("metadata")

var ffj_key_RangeAllocation_Range = []byte("range")

var ffj_key_RangeAllocation_Data = []byte("data")

var ffj_key_RangeAllocation_Kind = []byte("kind")

var ffj_key_RangeAllocation_APIVersion = []byte("apiVersion")

func (uj *RangeAllocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RangeAllocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RangeAllocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RangeAllocationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_RangeAllocation_APIVersion, kn) {
						currentKey = ffj_t_RangeAllocation_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_RangeAllocation_Data, kn) {
						currentKey = ffj_t_RangeAllocation_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_RangeAllocation_Kind, kn) {
						currentKey = ffj_t_RangeAllocation_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_RangeAllocation_ObjectMeta, kn) {
						currentKey = ffj_t_RangeAllocation_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_RangeAllocation_Range, kn) {
						currentKey = ffj_t_RangeAllocation_Range
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_RangeAllocation_APIVersion, kn) {
					currentKey = ffj_t_RangeAllocation_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RangeAllocation_Kind, kn) {
					currentKey = ffj_t_RangeAllocation_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RangeAllocation_Data, kn) {
					currentKey = ffj_t_RangeAllocation_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RangeAllocation_Range, kn) {
					currentKey = ffj_t_RangeAllocation_Range
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RangeAllocation_ObjectMeta, kn) {
					currentKey = ffj_t_RangeAllocation_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RangeAllocationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RangeAllocation_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_RangeAllocation_Range:
					goto handle_Range

				case ffj_t_RangeAllocation_Data:
					goto handle_Data

				case ffj_t_RangeAllocation_Kind:
					goto handle_Kind

				case ffj_t_RangeAllocation_APIVersion:
					goto handle_APIVersion

				case ffj_t_RangeAllocationno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Range:

	/* handler: uj.Range type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Range = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReplicationController) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReplicationController) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReplicationControllerbase = iota
	ffj_t_ReplicationControllerno_such_key

	ffj_t_ReplicationController_ObjectMeta

	ffj_t_ReplicationController_Spec

	ffj_t_ReplicationController_Status

	ffj_t_ReplicationController_Kind

	ffj_t_ReplicationController_APIVersion
)

var ffj_key_ReplicationController_ObjectMeta = []byte("metadata")

var ffj_key_ReplicationController_Spec = []byte("spec")

var ffj_key_ReplicationController_Status = []byte("status")

var ffj_key_ReplicationController_Kind = []byte("kind")

var ffj_key_ReplicationController_APIVersion = []byte("apiVersion")

func (uj *ReplicationController) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReplicationController) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReplicationControllerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReplicationControllerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ReplicationController_APIVersion, kn) {
						currentKey = ffj_t_ReplicationController_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ReplicationController_Kind, kn) {
						currentKey = ffj_t_ReplicationController_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ReplicationController_ObjectMeta, kn) {
						currentKey = ffj_t_ReplicationController_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ReplicationController_Spec, kn) {
						currentKey = ffj_t_ReplicationController_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ReplicationController_Status, kn) {
						currentKey = ffj_t_ReplicationController_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReplicationController_APIVersion, kn) {
					currentKey = ffj_t_ReplicationController_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationController_Kind, kn) {
					currentKey = ffj_t_ReplicationController_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationController_Status, kn) {
					currentKey = ffj_t_ReplicationController_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationController_Spec, kn) {
					currentKey = ffj_t_ReplicationController_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReplicationController_ObjectMeta, kn) {
					currentKey = ffj_t_ReplicationController_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReplicationControllerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReplicationController_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_ReplicationController_Spec:
					goto handle_Spec

				case ffj_t_ReplicationController_Status:
					goto handle_Status

				case ffj_t_ReplicationController_Kind:
					goto handle_Kind

				case ffj_t_ReplicationController_APIVersion:
					goto handle_APIVersion

				case ffj_t_ReplicationControllerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.ReplicationControllerSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.ReplicationControllerStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReplicationControllerList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReplicationControllerList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReplicationControllerListbase = iota
	ffj_t_ReplicationControllerListno_such_key

	ffj_t_ReplicationControllerList_ListMeta

	ffj_t_ReplicationControllerList_Items

	ffj_t_ReplicationControllerList_Kind

	ffj_t_ReplicationControllerList_APIVersion
)

var ffj_key_ReplicationControllerList_ListMeta = []byte("metadata")

var ffj_key_ReplicationControllerList_Items = []byte("items")

var ffj_key_ReplicationControllerList_Kind = []byte("kind")

var ffj_key_ReplicationControllerList_APIVersion = []byte("apiVersion")

func (uj *ReplicationControllerList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReplicationControllerList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReplicationControllerListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReplicationControllerListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ReplicationControllerList_APIVersion, kn) {
						currentKey = ffj_t_ReplicationControllerList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ReplicationControllerList_Items, kn) {
						currentKey = ffj_t_ReplicationControllerList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ReplicationControllerList_Kind, kn) {
						currentKey = ffj_t_ReplicationControllerList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ReplicationControllerList_ListMeta, kn) {
						currentKey = ffj_t_ReplicationControllerList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReplicationControllerList_APIVersion, kn) {
					currentKey = ffj_t_ReplicationControllerList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationControllerList_Kind, kn) {
					currentKey = ffj_t_ReplicationControllerList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationControllerList_Items, kn) {
					currentKey = ffj_t_ReplicationControllerList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReplicationControllerList_ListMeta, kn) {
					currentKey = ffj_t_ReplicationControllerList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReplicationControllerListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReplicationControllerList_ListMeta:
					goto handle_ListMeta

				case ffj_t_ReplicationControllerList_Items:
					goto handle_Items

				case ffj_t_ReplicationControllerList_Kind:
					goto handle_Kind

				case ffj_t_ReplicationControllerList_APIVersion:
					goto handle_APIVersion

				case ffj_t_ReplicationControllerListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.ReplicationController kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]ReplicationController, 0)

			wantVal := true

			for {

				var v ReplicationController

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ReplicationController kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReplicationControllerSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReplicationControllerSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Replicas != nil {
		if true {
			buf.WriteString(`"replicas":`)
			fflib.FormatBits2(buf, uint64(*mj.Replicas), 10, *mj.Replicas < 0)
			buf.WriteByte(',')
		}
	}
	if len(mj.Selector) != 0 {
		if mj.Selector == nil {
			buf.WriteString(`"selector":null`)
		} else {
			buf.WriteString(`"selector":{ `)
			for key, value := range mj.Selector {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if mj.Template != nil {
		if true {
			buf.WriteString(`"template":`)

			{
				err = mj.Template.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReplicationControllerSpecbase = iota
	ffj_t_ReplicationControllerSpecno_such_key

	ffj_t_ReplicationControllerSpec_Replicas

	ffj_t_ReplicationControllerSpec_Selector

	ffj_t_ReplicationControllerSpec_Template
)

var ffj_key_ReplicationControllerSpec_Replicas = []byte("replicas")

var ffj_key_ReplicationControllerSpec_Selector = []byte("selector")

var ffj_key_ReplicationControllerSpec_Template = []byte("template")

func (uj *ReplicationControllerSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReplicationControllerSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReplicationControllerSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReplicationControllerSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_ReplicationControllerSpec_Replicas, kn) {
						currentKey = ffj_t_ReplicationControllerSpec_Replicas
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ReplicationControllerSpec_Selector, kn) {
						currentKey = ffj_t_ReplicationControllerSpec_Selector
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ReplicationControllerSpec_Template, kn) {
						currentKey = ffj_t_ReplicationControllerSpec_Template
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReplicationControllerSpec_Template, kn) {
					currentKey = ffj_t_ReplicationControllerSpec_Template
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationControllerSpec_Selector, kn) {
					currentKey = ffj_t_ReplicationControllerSpec_Selector
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplicationControllerSpec_Replicas, kn) {
					currentKey = ffj_t_ReplicationControllerSpec_Replicas
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReplicationControllerSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReplicationControllerSpec_Replicas:
					goto handle_Replicas

				case ffj_t_ReplicationControllerSpec_Selector:
					goto handle_Selector

				case ffj_t_ReplicationControllerSpec_Template:
					goto handle_Template

				case ffj_t_ReplicationControllerSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Replicas:

	/* handler: uj.Replicas type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Replicas = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int(tval)
			uj.Replicas = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selector:

	/* handler: uj.Selector type=map[string]string kind=map */

	{
		/* Falling back. type=map[string]string kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Selector)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Template:

	/* handler: uj.Template type=v1.PodTemplateSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Template = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Template == nil {
			uj.Template = new(PodTemplateSpec)
		}

		err = uj.Template.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReplicationControllerStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReplicationControllerStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"replicas":`)
	fflib.FormatBits2(buf, uint64(mj.Replicas), 10, mj.Replicas < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReplicationControllerStatusbase = iota
	ffj_t_ReplicationControllerStatusno_such_key

	ffj_t_ReplicationControllerStatus_Replicas
)

var ffj_key_ReplicationControllerStatus_Replicas = []byte("replicas")

func (uj *ReplicationControllerStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReplicationControllerStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReplicationControllerStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReplicationControllerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_ReplicationControllerStatus_Replicas, kn) {
						currentKey = ffj_t_ReplicationControllerStatus_Replicas
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReplicationControllerStatus_Replicas, kn) {
					currentKey = ffj_t_ReplicationControllerStatus_Replicas
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReplicationControllerStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReplicationControllerStatus_Replicas:
					goto handle_Replicas

				case ffj_t_ReplicationControllerStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Replicas:

	/* handler: uj.Replicas type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Replicas = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceQuota) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceQuota) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceQuotabase = iota
	ffj_t_ResourceQuotano_such_key

	ffj_t_ResourceQuota_ObjectMeta

	ffj_t_ResourceQuota_Spec

	ffj_t_ResourceQuota_Status

	ffj_t_ResourceQuota_Kind

	ffj_t_ResourceQuota_APIVersion
)

var ffj_key_ResourceQuota_ObjectMeta = []byte("metadata")

var ffj_key_ResourceQuota_Spec = []byte("spec")

var ffj_key_ResourceQuota_Status = []byte("status")

var ffj_key_ResourceQuota_Kind = []byte("kind")

var ffj_key_ResourceQuota_APIVersion = []byte("apiVersion")

func (uj *ResourceQuota) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceQuota) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceQuotabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceQuotano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ResourceQuota_APIVersion, kn) {
						currentKey = ffj_t_ResourceQuota_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ResourceQuota_Kind, kn) {
						currentKey = ffj_t_ResourceQuota_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ResourceQuota_ObjectMeta, kn) {
						currentKey = ffj_t_ResourceQuota_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ResourceQuota_Spec, kn) {
						currentKey = ffj_t_ResourceQuota_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ResourceQuota_Status, kn) {
						currentKey = ffj_t_ResourceQuota_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuota_APIVersion, kn) {
					currentKey = ffj_t_ResourceQuota_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuota_Kind, kn) {
					currentKey = ffj_t_ResourceQuota_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuota_Status, kn) {
					currentKey = ffj_t_ResourceQuota_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuota_Spec, kn) {
					currentKey = ffj_t_ResourceQuota_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceQuota_ObjectMeta, kn) {
					currentKey = ffj_t_ResourceQuota_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceQuotano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceQuota_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_ResourceQuota_Spec:
					goto handle_Spec

				case ffj_t_ResourceQuota_Status:
					goto handle_Status

				case ffj_t_ResourceQuota_Kind:
					goto handle_Kind

				case ffj_t_ResourceQuota_APIVersion:
					goto handle_APIVersion

				case ffj_t_ResourceQuotano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.ResourceQuotaSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.ResourceQuotaStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceQuotaList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceQuotaList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceQuotaListbase = iota
	ffj_t_ResourceQuotaListno_such_key

	ffj_t_ResourceQuotaList_ListMeta

	ffj_t_ResourceQuotaList_Items

	ffj_t_ResourceQuotaList_Kind

	ffj_t_ResourceQuotaList_APIVersion
)

var ffj_key_ResourceQuotaList_ListMeta = []byte("metadata")

var ffj_key_ResourceQuotaList_Items = []byte("items")

var ffj_key_ResourceQuotaList_Kind = []byte("kind")

var ffj_key_ResourceQuotaList_APIVersion = []byte("apiVersion")

func (uj *ResourceQuotaList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceQuotaList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceQuotaListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceQuotaListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ResourceQuotaList_APIVersion, kn) {
						currentKey = ffj_t_ResourceQuotaList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ResourceQuotaList_Items, kn) {
						currentKey = ffj_t_ResourceQuotaList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ResourceQuotaList_Kind, kn) {
						currentKey = ffj_t_ResourceQuotaList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ResourceQuotaList_ListMeta, kn) {
						currentKey = ffj_t_ResourceQuotaList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuotaList_APIVersion, kn) {
					currentKey = ffj_t_ResourceQuotaList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuotaList_Kind, kn) {
					currentKey = ffj_t_ResourceQuotaList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuotaList_Items, kn) {
					currentKey = ffj_t_ResourceQuotaList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceQuotaList_ListMeta, kn) {
					currentKey = ffj_t_ResourceQuotaList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceQuotaListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceQuotaList_ListMeta:
					goto handle_ListMeta

				case ffj_t_ResourceQuotaList_Items:
					goto handle_Items

				case ffj_t_ResourceQuotaList_Kind:
					goto handle_Kind

				case ffj_t_ResourceQuotaList_APIVersion:
					goto handle_APIVersion

				case ffj_t_ResourceQuotaListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.ResourceQuota kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]ResourceQuota, 0)

			wantVal := true

			for {

				var v ResourceQuota

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ResourceQuota kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceQuotaSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceQuotaSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Hard) != 0 {
		buf.WriteString(`"hard":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Hard)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceQuotaSpecbase = iota
	ffj_t_ResourceQuotaSpecno_such_key

	ffj_t_ResourceQuotaSpec_Hard
)

var ffj_key_ResourceQuotaSpec_Hard = []byte("hard")

func (uj *ResourceQuotaSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceQuotaSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceQuotaSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceQuotaSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_ResourceQuotaSpec_Hard, kn) {
						currentKey = ffj_t_ResourceQuotaSpec_Hard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceQuotaSpec_Hard, kn) {
					currentKey = ffj_t_ResourceQuotaSpec_Hard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceQuotaSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceQuotaSpec_Hard:
					goto handle_Hard

				case ffj_t_ResourceQuotaSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hard:

	/* handler: uj.Hard type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Hard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceQuotaStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceQuotaStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Hard) != 0 {
		buf.WriteString(`"hard":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Hard)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.Used) != 0 {
		buf.WriteString(`"used":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Used)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceQuotaStatusbase = iota
	ffj_t_ResourceQuotaStatusno_such_key

	ffj_t_ResourceQuotaStatus_Hard

	ffj_t_ResourceQuotaStatus_Used
)

var ffj_key_ResourceQuotaStatus_Hard = []byte("hard")

var ffj_key_ResourceQuotaStatus_Used = []byte("used")

func (uj *ResourceQuotaStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceQuotaStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceQuotaStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceQuotaStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_ResourceQuotaStatus_Hard, kn) {
						currentKey = ffj_t_ResourceQuotaStatus_Hard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ResourceQuotaStatus_Used, kn) {
						currentKey = ffj_t_ResourceQuotaStatus_Used
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceQuotaStatus_Used, kn) {
					currentKey = ffj_t_ResourceQuotaStatus_Used
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ResourceQuotaStatus_Hard, kn) {
					currentKey = ffj_t_ResourceQuotaStatus_Hard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceQuotaStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceQuotaStatus_Hard:
					goto handle_Hard

				case ffj_t_ResourceQuotaStatus_Used:
					goto handle_Used

				case ffj_t_ResourceQuotaStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Hard:

	/* handler: uj.Hard type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Hard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Used:

	/* handler: uj.Used type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Used)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ResourceRequirements) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ResourceRequirements) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Limits) != 0 {
		buf.WriteString(`"limits":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Limits)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.Requests) != 0 {
		buf.WriteString(`"requests":`)
		/* Falling back. type=v1.ResourceList kind=map */
		err = buf.Encode(mj.Requests)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ResourceRequirementsbase = iota
	ffj_t_ResourceRequirementsno_such_key

	ffj_t_ResourceRequirements_Limits

	ffj_t_ResourceRequirements_Requests
)

var ffj_key_ResourceRequirements_Limits = []byte("limits")

var ffj_key_ResourceRequirements_Requests = []byte("requests")

func (uj *ResourceRequirements) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ResourceRequirements) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ResourceRequirementsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ResourceRequirementsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_ResourceRequirements_Limits, kn) {
						currentKey = ffj_t_ResourceRequirements_Limits
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ResourceRequirements_Requests, kn) {
						currentKey = ffj_t_ResourceRequirements_Requests
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ResourceRequirements_Requests, kn) {
					currentKey = ffj_t_ResourceRequirements_Requests
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ResourceRequirements_Limits, kn) {
					currentKey = ffj_t_ResourceRequirements_Limits
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ResourceRequirementsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ResourceRequirements_Limits:
					goto handle_Limits

				case ffj_t_ResourceRequirements_Requests:
					goto handle_Requests

				case ffj_t_ResourceRequirementsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Limits:

	/* handler: uj.Limits type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Limits)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Requests:

	/* handler: uj.Requests type=v1.ResourceList kind=map */

	{
		/* Falling back. type=v1.ResourceList kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Requests)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SELinuxOptions) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SELinuxOptions) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.User) != 0 {
		buf.WriteString(`"user":`)
		fflib.WriteJsonString(buf, string(mj.User))
		buf.WriteByte(',')
	}
	if len(mj.Role) != 0 {
		buf.WriteString(`"role":`)
		fflib.WriteJsonString(buf, string(mj.Role))
		buf.WriteByte(',')
	}
	if len(mj.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(mj.Type))
		buf.WriteByte(',')
	}
	if len(mj.Level) != 0 {
		buf.WriteString(`"level":`)
		fflib.WriteJsonString(buf, string(mj.Level))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SELinuxOptionsbase = iota
	ffj_t_SELinuxOptionsno_such_key

	ffj_t_SELinuxOptions_User

	ffj_t_SELinuxOptions_Role

	ffj_t_SELinuxOptions_Type

	ffj_t_SELinuxOptions_Level
)

var ffj_key_SELinuxOptions_User = []byte("user")

var ffj_key_SELinuxOptions_Role = []byte("role")

var ffj_key_SELinuxOptions_Type = []byte("type")

var ffj_key_SELinuxOptions_Level = []byte("level")

func (uj *SELinuxOptions) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SELinuxOptions) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SELinuxOptionsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SELinuxOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_SELinuxOptions_Level, kn) {
						currentKey = ffj_t_SELinuxOptions_Level
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_SELinuxOptions_Role, kn) {
						currentKey = ffj_t_SELinuxOptions_Role
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_SELinuxOptions_Type, kn) {
						currentKey = ffj_t_SELinuxOptions_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_SELinuxOptions_User, kn) {
						currentKey = ffj_t_SELinuxOptions_User
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_SELinuxOptions_Level, kn) {
					currentKey = ffj_t_SELinuxOptions_Level
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SELinuxOptions_Type, kn) {
					currentKey = ffj_t_SELinuxOptions_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SELinuxOptions_Role, kn) {
					currentKey = ffj_t_SELinuxOptions_Role
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SELinuxOptions_User, kn) {
					currentKey = ffj_t_SELinuxOptions_User
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SELinuxOptionsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SELinuxOptions_User:
					goto handle_User

				case ffj_t_SELinuxOptions_Role:
					goto handle_Role

				case ffj_t_SELinuxOptions_Type:
					goto handle_Type

				case ffj_t_SELinuxOptions_Level:
					goto handle_Level

				case ffj_t_SELinuxOptionsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_User:

	/* handler: uj.User type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.User = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Role:

	/* handler: uj.Role type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Role = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Level:

	/* handler: uj.Level type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Level = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Secret) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Secret) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		/* Falling back. type=map[string][]uint8 kind=map */
		err = buf.Encode(mj.Data)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(mj.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(mj.Type))
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Secretbase = iota
	ffj_t_Secretno_such_key

	ffj_t_Secret_ObjectMeta

	ffj_t_Secret_Data

	ffj_t_Secret_Type

	ffj_t_Secret_Kind

	ffj_t_Secret_APIVersion
)

var ffj_key_Secret_ObjectMeta = []byte("metadata")

var ffj_key_Secret_Data = []byte("data")

var ffj_key_Secret_Type = []byte("type")

var ffj_key_Secret_Kind = []byte("kind")

var ffj_key_Secret_APIVersion = []byte("apiVersion")

func (uj *Secret) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Secret) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Secretbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Secretno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Secret_APIVersion, kn) {
						currentKey = ffj_t_Secret_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Secret_Data, kn) {
						currentKey = ffj_t_Secret_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Secret_Kind, kn) {
						currentKey = ffj_t_Secret_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Secret_ObjectMeta, kn) {
						currentKey = ffj_t_Secret_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Secret_Type, kn) {
						currentKey = ffj_t_Secret_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Secret_APIVersion, kn) {
					currentKey = ffj_t_Secret_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Secret_Kind, kn) {
					currentKey = ffj_t_Secret_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Secret_Type, kn) {
					currentKey = ffj_t_Secret_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Secret_Data, kn) {
					currentKey = ffj_t_Secret_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Secret_ObjectMeta, kn) {
					currentKey = ffj_t_Secret_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Secretno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Secret_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Secret_Data:
					goto handle_Data

				case ffj_t_Secret_Type:
					goto handle_Type

				case ffj_t_Secret_Kind:
					goto handle_Kind

				case ffj_t_Secret_APIVersion:
					goto handle_APIVersion

				case ffj_t_Secretno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=map[string][]uint8 kind=map */

	{
		/* Falling back. type=map[string][]uint8 kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Data)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=v1.SecretType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for SecretType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = SecretType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SecretList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SecretList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SecretListbase = iota
	ffj_t_SecretListno_such_key

	ffj_t_SecretList_ListMeta

	ffj_t_SecretList_Items

	ffj_t_SecretList_Kind

	ffj_t_SecretList_APIVersion
)

var ffj_key_SecretList_ListMeta = []byte("metadata")

var ffj_key_SecretList_Items = []byte("items")

var ffj_key_SecretList_Kind = []byte("kind")

var ffj_key_SecretList_APIVersion = []byte("apiVersion")

func (uj *SecretList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SecretList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SecretListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SecretListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_SecretList_APIVersion, kn) {
						currentKey = ffj_t_SecretList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_SecretList_Items, kn) {
						currentKey = ffj_t_SecretList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_SecretList_Kind, kn) {
						currentKey = ffj_t_SecretList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_SecretList_ListMeta, kn) {
						currentKey = ffj_t_SecretList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SecretList_APIVersion, kn) {
					currentKey = ffj_t_SecretList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SecretList_Kind, kn) {
					currentKey = ffj_t_SecretList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SecretList_Items, kn) {
					currentKey = ffj_t_SecretList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SecretList_ListMeta, kn) {
					currentKey = ffj_t_SecretList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SecretListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SecretList_ListMeta:
					goto handle_ListMeta

				case ffj_t_SecretList_Items:
					goto handle_Items

				case ffj_t_SecretList_Kind:
					goto handle_Kind

				case ffj_t_SecretList_APIVersion:
					goto handle_APIVersion

				case ffj_t_SecretListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Secret kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Secret, 0)

			wantVal := true

			for {

				var v Secret

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Secret kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SecretVolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SecretVolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"secretName":`)
	fflib.WriteJsonString(buf, string(mj.SecretName))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SecretVolumeSourcebase = iota
	ffj_t_SecretVolumeSourceno_such_key

	ffj_t_SecretVolumeSource_SecretName
)

var ffj_key_SecretVolumeSource_SecretName = []byte("secretName")

func (uj *SecretVolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SecretVolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SecretVolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SecretVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffj_key_SecretVolumeSource_SecretName, kn) {
						currentKey = ffj_t_SecretVolumeSource_SecretName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SecretVolumeSource_SecretName, kn) {
					currentKey = ffj_t_SecretVolumeSource_SecretName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SecretVolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SecretVolumeSource_SecretName:
					goto handle_SecretName

				case ffj_t_SecretVolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_SecretName:

	/* handler: uj.SecretName type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.SecretName = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SecurityContext) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SecurityContext) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Capabilities != nil {
		if true {
			buf.WriteString(`"capabilities":`)

			{
				err = mj.Capabilities.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Privileged != nil {
		if true {
			if *mj.Privileged {
				buf.WriteString(`"privileged":true`)
			} else {
				buf.WriteString(`"privileged":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.SELinuxOptions != nil {
		if true {
			buf.WriteString(`"seLinuxOptions":`)

			{
				err = mj.SELinuxOptions.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.RunAsUser != nil {
		if true {
			buf.WriteString(`"runAsUser":`)
			fflib.FormatBits2(buf, uint64(*mj.RunAsUser), 10, *mj.RunAsUser < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SecurityContextbase = iota
	ffj_t_SecurityContextno_such_key

	ffj_t_SecurityContext_Capabilities

	ffj_t_SecurityContext_Privileged

	ffj_t_SecurityContext_SELinuxOptions

	ffj_t_SecurityContext_RunAsUser
)

var ffj_key_SecurityContext_Capabilities = []byte("capabilities")

var ffj_key_SecurityContext_Privileged = []byte("privileged")

var ffj_key_SecurityContext_SELinuxOptions = []byte("seLinuxOptions")

var ffj_key_SecurityContext_RunAsUser = []byte("runAsUser")

func (uj *SecurityContext) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SecurityContext) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SecurityContextbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SecurityContextno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_SecurityContext_Capabilities, kn) {
						currentKey = ffj_t_SecurityContext_Capabilities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_SecurityContext_Privileged, kn) {
						currentKey = ffj_t_SecurityContext_Privileged
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_SecurityContext_RunAsUser, kn) {
						currentKey = ffj_t_SecurityContext_RunAsUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_SecurityContext_SELinuxOptions, kn) {
						currentKey = ffj_t_SecurityContext_SELinuxOptions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SecurityContext_RunAsUser, kn) {
					currentKey = ffj_t_SecurityContext_RunAsUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SecurityContext_SELinuxOptions, kn) {
					currentKey = ffj_t_SecurityContext_SELinuxOptions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SecurityContext_Privileged, kn) {
					currentKey = ffj_t_SecurityContext_Privileged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SecurityContext_Capabilities, kn) {
					currentKey = ffj_t_SecurityContext_Capabilities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SecurityContextno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SecurityContext_Capabilities:
					goto handle_Capabilities

				case ffj_t_SecurityContext_Privileged:
					goto handle_Privileged

				case ffj_t_SecurityContext_SELinuxOptions:
					goto handle_SELinuxOptions

				case ffj_t_SecurityContext_RunAsUser:
					goto handle_RunAsUser

				case ffj_t_SecurityContextno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Capabilities:

	/* handler: uj.Capabilities type=v1.Capabilities kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Capabilities = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Capabilities == nil {
			uj.Capabilities = new(Capabilities)
		}

		err = uj.Capabilities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Privileged:

	/* handler: uj.Privileged type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Privileged = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Privileged = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SELinuxOptions:

	/* handler: uj.SELinuxOptions type=v1.SELinuxOptions kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.SELinuxOptions = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.SELinuxOptions == nil {
			uj.SELinuxOptions = new(SELinuxOptions)
		}

		err = uj.SELinuxOptions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RunAsUser:

	/* handler: uj.RunAsUser type=int64 kind=int64 */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.RunAsUser = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int64(tval)
			uj.RunAsUser = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SerializedReference) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SerializedReference) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"reference":`)

		{
			err = mj.Reference.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SerializedReferencebase = iota
	ffj_t_SerializedReferenceno_such_key

	ffj_t_SerializedReference_Reference

	ffj_t_SerializedReference_Kind

	ffj_t_SerializedReference_APIVersion
)

var ffj_key_SerializedReference_Reference = []byte("reference")

var ffj_key_SerializedReference_Kind = []byte("kind")

var ffj_key_SerializedReference_APIVersion = []byte("apiVersion")

func (uj *SerializedReference) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SerializedReference) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SerializedReferencebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SerializedReferenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_SerializedReference_APIVersion, kn) {
						currentKey = ffj_t_SerializedReference_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_SerializedReference_Kind, kn) {
						currentKey = ffj_t_SerializedReference_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_SerializedReference_Reference, kn) {
						currentKey = ffj_t_SerializedReference_Reference
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_SerializedReference_APIVersion, kn) {
					currentKey = ffj_t_SerializedReference_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_SerializedReference_Kind, kn) {
					currentKey = ffj_t_SerializedReference_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SerializedReference_Reference, kn) {
					currentKey = ffj_t_SerializedReference_Reference
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SerializedReferenceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SerializedReference_Reference:
					goto handle_Reference

				case ffj_t_SerializedReference_Kind:
					goto handle_Kind

				case ffj_t_SerializedReference_APIVersion:
					goto handle_APIVersion

				case ffj_t_SerializedReferenceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Reference:

	/* handler: uj.Reference type=v1.ObjectReference kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Reference.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Service) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Service) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"spec":`)

		{
			err = mj.Spec.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"status":`)

		{
			err = mj.Status.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Servicebase = iota
	ffj_t_Serviceno_such_key

	ffj_t_Service_ObjectMeta

	ffj_t_Service_Spec

	ffj_t_Service_Status

	ffj_t_Service_Kind

	ffj_t_Service_APIVersion
)

var ffj_key_Service_ObjectMeta = []byte("metadata")

var ffj_key_Service_Spec = []byte("spec")

var ffj_key_Service_Status = []byte("status")

var ffj_key_Service_Kind = []byte("kind")

var ffj_key_Service_APIVersion = []byte("apiVersion")

func (uj *Service) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Service) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Servicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Serviceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Service_APIVersion, kn) {
						currentKey = ffj_t_Service_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Service_Kind, kn) {
						currentKey = ffj_t_Service_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Service_ObjectMeta, kn) {
						currentKey = ffj_t_Service_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Service_Spec, kn) {
						currentKey = ffj_t_Service_Spec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Service_Status, kn) {
						currentKey = ffj_t_Service_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Service_APIVersion, kn) {
					currentKey = ffj_t_Service_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Service_Kind, kn) {
					currentKey = ffj_t_Service_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Service_Status, kn) {
					currentKey = ffj_t_Service_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Service_Spec, kn) {
					currentKey = ffj_t_Service_Spec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Service_ObjectMeta, kn) {
					currentKey = ffj_t_Service_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Serviceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Service_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_Service_Spec:
					goto handle_Spec

				case ffj_t_Service_Status:
					goto handle_Status

				case ffj_t_Service_Kind:
					goto handle_Kind

				case ffj_t_Service_APIVersion:
					goto handle_APIVersion

				case ffj_t_Serviceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Spec:

	/* handler: uj.Spec type=v1.ServiceSpec kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Spec.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=v1.ServiceStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Status.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServiceAccount) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServiceAccount) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ObjectMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Secrets) != 0 {
		buf.WriteString(`"secrets":`)
		if mj.Secrets != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Secrets {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.ImagePullSecrets) != 0 {
		buf.WriteString(`"imagePullSecrets":`)
		if mj.ImagePullSecrets != nil {
			buf.WriteString(`[`)
			for i, v := range mj.ImagePullSecrets {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServiceAccountbase = iota
	ffj_t_ServiceAccountno_such_key

	ffj_t_ServiceAccount_ObjectMeta

	ffj_t_ServiceAccount_Secrets

	ffj_t_ServiceAccount_ImagePullSecrets

	ffj_t_ServiceAccount_Kind

	ffj_t_ServiceAccount_APIVersion
)

var ffj_key_ServiceAccount_ObjectMeta = []byte("metadata")

var ffj_key_ServiceAccount_Secrets = []byte("secrets")

var ffj_key_ServiceAccount_ImagePullSecrets = []byte("imagePullSecrets")

var ffj_key_ServiceAccount_Kind = []byte("kind")

var ffj_key_ServiceAccount_APIVersion = []byte("apiVersion")

func (uj *ServiceAccount) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServiceAccount) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServiceAccountbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServiceAccountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ServiceAccount_APIVersion, kn) {
						currentKey = ffj_t_ServiceAccount_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ServiceAccount_ImagePullSecrets, kn) {
						currentKey = ffj_t_ServiceAccount_ImagePullSecrets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ServiceAccount_Kind, kn) {
						currentKey = ffj_t_ServiceAccount_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ServiceAccount_ObjectMeta, kn) {
						currentKey = ffj_t_ServiceAccount_ObjectMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ServiceAccount_Secrets, kn) {
						currentKey = ffj_t_ServiceAccount_Secrets
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccount_APIVersion, kn) {
					currentKey = ffj_t_ServiceAccount_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccount_Kind, kn) {
					currentKey = ffj_t_ServiceAccount_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccount_ImagePullSecrets, kn) {
					currentKey = ffj_t_ServiceAccount_ImagePullSecrets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccount_Secrets, kn) {
					currentKey = ffj_t_ServiceAccount_Secrets
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServiceAccount_ObjectMeta, kn) {
					currentKey = ffj_t_ServiceAccount_ObjectMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServiceAccountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServiceAccount_ObjectMeta:
					goto handle_ObjectMeta

				case ffj_t_ServiceAccount_Secrets:
					goto handle_Secrets

				case ffj_t_ServiceAccount_ImagePullSecrets:
					goto handle_ImagePullSecrets

				case ffj_t_ServiceAccount_Kind:
					goto handle_Kind

				case ffj_t_ServiceAccount_APIVersion:
					goto handle_APIVersion

				case ffj_t_ServiceAccountno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ObjectMeta:

	/* handler: uj.ObjectMeta type=v1.ObjectMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ObjectMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secrets:

	/* handler: uj.Secrets type=[]v1.ObjectReference kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Secrets = nil
		} else {

			uj.Secrets = make([]ObjectReference, 0)

			wantVal := true

			for {

				var v ObjectReference

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ObjectReference kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Secrets = append(uj.Secrets, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImagePullSecrets:

	/* handler: uj.ImagePullSecrets type=[]v1.LocalObjectReference kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ImagePullSecrets = nil
		} else {

			uj.ImagePullSecrets = make([]LocalObjectReference, 0)

			wantVal := true

			for {

				var v LocalObjectReference

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.LocalObjectReference kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ImagePullSecrets = append(uj.ImagePullSecrets, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServiceAccountList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServiceAccountList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServiceAccountListbase = iota
	ffj_t_ServiceAccountListno_such_key

	ffj_t_ServiceAccountList_ListMeta

	ffj_t_ServiceAccountList_Items

	ffj_t_ServiceAccountList_Kind

	ffj_t_ServiceAccountList_APIVersion
)

var ffj_key_ServiceAccountList_ListMeta = []byte("metadata")

var ffj_key_ServiceAccountList_Items = []byte("items")

var ffj_key_ServiceAccountList_Kind = []byte("kind")

var ffj_key_ServiceAccountList_APIVersion = []byte("apiVersion")

func (uj *ServiceAccountList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServiceAccountList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServiceAccountListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServiceAccountListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ServiceAccountList_APIVersion, kn) {
						currentKey = ffj_t_ServiceAccountList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ServiceAccountList_Items, kn) {
						currentKey = ffj_t_ServiceAccountList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ServiceAccountList_Kind, kn) {
						currentKey = ffj_t_ServiceAccountList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ServiceAccountList_ListMeta, kn) {
						currentKey = ffj_t_ServiceAccountList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccountList_APIVersion, kn) {
					currentKey = ffj_t_ServiceAccountList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccountList_Kind, kn) {
					currentKey = ffj_t_ServiceAccountList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceAccountList_Items, kn) {
					currentKey = ffj_t_ServiceAccountList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServiceAccountList_ListMeta, kn) {
					currentKey = ffj_t_ServiceAccountList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServiceAccountListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServiceAccountList_ListMeta:
					goto handle_ListMeta

				case ffj_t_ServiceAccountList_Items:
					goto handle_Items

				case ffj_t_ServiceAccountList_Kind:
					goto handle_Kind

				case ffj_t_ServiceAccountList_APIVersion:
					goto handle_APIVersion

				case ffj_t_ServiceAccountListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.ServiceAccount kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]ServiceAccount, 0)

			wantVal := true

			for {

				var v ServiceAccount

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ServiceAccount kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServiceList) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServiceList) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServiceListbase = iota
	ffj_t_ServiceListno_such_key

	ffj_t_ServiceList_ListMeta

	ffj_t_ServiceList_Items

	ffj_t_ServiceList_Kind

	ffj_t_ServiceList_APIVersion
)

var ffj_key_ServiceList_ListMeta = []byte("metadata")

var ffj_key_ServiceList_Items = []byte("items")

var ffj_key_ServiceList_Kind = []byte("kind")

var ffj_key_ServiceList_APIVersion = []byte("apiVersion")

func (uj *ServiceList) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServiceList) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServiceListbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServiceListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ServiceList_APIVersion, kn) {
						currentKey = ffj_t_ServiceList_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ServiceList_Items, kn) {
						currentKey = ffj_t_ServiceList_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_ServiceList_Kind, kn) {
						currentKey = ffj_t_ServiceList_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_ServiceList_ListMeta, kn) {
						currentKey = ffj_t_ServiceList_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ServiceList_APIVersion, kn) {
					currentKey = ffj_t_ServiceList_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceList_Kind, kn) {
					currentKey = ffj_t_ServiceList_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceList_Items, kn) {
					currentKey = ffj_t_ServiceList_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServiceList_ListMeta, kn) {
					currentKey = ffj_t_ServiceList_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServiceListno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServiceList_ListMeta:
					goto handle_ListMeta

				case ffj_t_ServiceList_Items:
					goto handle_Items

				case ffj_t_ServiceList_Kind:
					goto handle_Kind

				case ffj_t_ServiceList_APIVersion:
					goto handle_APIVersion

				case ffj_t_ServiceListno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Items:

	/* handler: uj.Items type=[]v1.Service kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]Service, 0)

			wantVal := true

			for {

				var v Service

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.Service kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServicePort) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServicePort) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteByte('{')
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	if len(mj.Protocol) != 0 {
		buf.WriteString(`"protocol":`)
		fflib.WriteJsonString(buf, string(mj.Protocol))
		buf.WriteByte(',')
	}
	buf.WriteString(`"port":`)
	fflib.FormatBits2(buf, uint64(mj.Port), 10, mj.Port < 0)
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"targetPort":`)

		{
			obj, err = mj.TargetPort.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)
		}

		buf.WriteByte(',')
	}
	buf.WriteString(`"nodePort":`)
	fflib.FormatBits2(buf, uint64(mj.NodePort), 10, mj.NodePort < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServicePortbase = iota
	ffj_t_ServicePortno_such_key

	ffj_t_ServicePort_Name

	ffj_t_ServicePort_Protocol

	ffj_t_ServicePort_Port

	ffj_t_ServicePort_TargetPort

	ffj_t_ServicePort_NodePort
)

var ffj_key_ServicePort_Name = []byte("name")

var ffj_key_ServicePort_Protocol = []byte("protocol")

var ffj_key_ServicePort_Port = []byte("port")

var ffj_key_ServicePort_TargetPort = []byte("targetPort")

var ffj_key_ServicePort_NodePort = []byte("nodePort")

func (uj *ServicePort) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServicePort) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServicePortbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServicePortno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_ServicePort_Name, kn) {
						currentKey = ffj_t_ServicePort_Name
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ServicePort_NodePort, kn) {
						currentKey = ffj_t_ServicePort_NodePort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ServicePort_Protocol, kn) {
						currentKey = ffj_t_ServicePort_Protocol
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ServicePort_Port, kn) {
						currentKey = ffj_t_ServicePort_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ServicePort_TargetPort, kn) {
						currentKey = ffj_t_ServicePort_TargetPort
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServicePort_NodePort, kn) {
					currentKey = ffj_t_ServicePort_NodePort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServicePort_TargetPort, kn) {
					currentKey = ffj_t_ServicePort_TargetPort
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServicePort_Port, kn) {
					currentKey = ffj_t_ServicePort_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServicePort_Protocol, kn) {
					currentKey = ffj_t_ServicePort_Protocol
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServicePort_Name, kn) {
					currentKey = ffj_t_ServicePort_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServicePortno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServicePort_Name:
					goto handle_Name

				case ffj_t_ServicePort_Protocol:
					goto handle_Protocol

				case ffj_t_ServicePort_Port:
					goto handle_Port

				case ffj_t_ServicePort_TargetPort:
					goto handle_TargetPort

				case ffj_t_ServicePort_NodePort:
					goto handle_NodePort

				case ffj_t_ServicePortno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Protocol:

	/* handler: uj.Protocol type=v1.Protocol kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Protocol", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Protocol = Protocol(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Port:

	/* handler: uj.Port type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Port = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TargetPort:

	/* handler: uj.TargetPort type=util.IntOrString kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.TargetPort.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodePort:

	/* handler: uj.NodePort type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.NodePort = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServiceSpec) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServiceSpec) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "ports":`)
	if mj.Ports != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Ports {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{
				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if len(mj.Selector) != 0 {
		if mj.Selector == nil {
			buf.WriteString(`"selector":null`)
		} else {
			buf.WriteString(`"selector":{ `)
			for key, value := range mj.Selector {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"clusterIP":`)
	fflib.WriteJsonString(buf, string(mj.ClusterIP))
	buf.WriteByte(',')
	if len(mj.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(mj.Type))
		buf.WriteByte(',')
	}
	if len(mj.DeprecatedPublicIPs) != 0 {
		buf.WriteString(`"deprecatedPublicIPs":`)
		if mj.DeprecatedPublicIPs != nil {
			buf.WriteString(`[`)
			for i, v := range mj.DeprecatedPublicIPs {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(mj.SessionAffinity) != 0 {
		buf.WriteString(`"sessionAffinity":`)
		fflib.WriteJsonString(buf, string(mj.SessionAffinity))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServiceSpecbase = iota
	ffj_t_ServiceSpecno_such_key

	ffj_t_ServiceSpec_Ports

	ffj_t_ServiceSpec_Selector

	ffj_t_ServiceSpec_ClusterIP

	ffj_t_ServiceSpec_Type

	ffj_t_ServiceSpec_DeprecatedPublicIPs

	ffj_t_ServiceSpec_SessionAffinity
)

var ffj_key_ServiceSpec_Ports = []byte("ports")

var ffj_key_ServiceSpec_Selector = []byte("selector")

var ffj_key_ServiceSpec_ClusterIP = []byte("clusterIP")

var ffj_key_ServiceSpec_Type = []byte("type")

var ffj_key_ServiceSpec_DeprecatedPublicIPs = []byte("deprecatedPublicIPs")

var ffj_key_ServiceSpec_SessionAffinity = []byte("sessionAffinity")

func (uj *ServiceSpec) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServiceSpec) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServiceSpecbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServiceSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ServiceSpec_ClusterIP, kn) {
						currentKey = ffj_t_ServiceSpec_ClusterIP
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ServiceSpec_DeprecatedPublicIPs, kn) {
						currentKey = ffj_t_ServiceSpec_DeprecatedPublicIPs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ServiceSpec_Ports, kn) {
						currentKey = ffj_t_ServiceSpec_Ports
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ServiceSpec_Selector, kn) {
						currentKey = ffj_t_ServiceSpec_Selector
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ServiceSpec_SessionAffinity, kn) {
						currentKey = ffj_t_ServiceSpec_SessionAffinity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ServiceSpec_Type, kn) {
						currentKey = ffj_t_ServiceSpec_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ServiceSpec_SessionAffinity, kn) {
					currentKey = ffj_t_ServiceSpec_SessionAffinity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceSpec_DeprecatedPublicIPs, kn) {
					currentKey = ffj_t_ServiceSpec_DeprecatedPublicIPs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServiceSpec_Type, kn) {
					currentKey = ffj_t_ServiceSpec_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceSpec_ClusterIP, kn) {
					currentKey = ffj_t_ServiceSpec_ClusterIP
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceSpec_Selector, kn) {
					currentKey = ffj_t_ServiceSpec_Selector
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ServiceSpec_Ports, kn) {
					currentKey = ffj_t_ServiceSpec_Ports
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServiceSpecno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServiceSpec_Ports:
					goto handle_Ports

				case ffj_t_ServiceSpec_Selector:
					goto handle_Selector

				case ffj_t_ServiceSpec_ClusterIP:
					goto handle_ClusterIP

				case ffj_t_ServiceSpec_Type:
					goto handle_Type

				case ffj_t_ServiceSpec_DeprecatedPublicIPs:
					goto handle_DeprecatedPublicIPs

				case ffj_t_ServiceSpec_SessionAffinity:
					goto handle_SessionAffinity

				case ffj_t_ServiceSpecno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ports:

	/* handler: uj.Ports type=[]v1.ServicePort kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Ports = nil
		} else {

			uj.Ports = make([]ServicePort, 0)

			wantVal := true

			for {

				var v ServicePort

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.ServicePort kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Ports = append(uj.Ports, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selector:

	/* handler: uj.Selector type=map[string]string kind=map */

	{
		/* Falling back. type=map[string]string kind=map */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Selector)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClusterIP:

	/* handler: uj.ClusterIP type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.ClusterIP = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=v1.ServiceType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ServiceType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = ServiceType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeprecatedPublicIPs:

	/* handler: uj.DeprecatedPublicIPs type=[]string kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.DeprecatedPublicIPs = nil
		} else {

			uj.DeprecatedPublicIPs = make([]string, 0)

			wantVal := true

			for {

				var v string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=string kind=string */

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						v = string(fs.Output.String())

					}
				}

				uj.DeprecatedPublicIPs = append(uj.DeprecatedPublicIPs, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SessionAffinity:

	/* handler: uj.SessionAffinity type=v1.ServiceAffinity kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ServiceAffinity", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.SessionAffinity = ServiceAffinity(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServiceStatus) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServiceStatus) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"loadBalancer":`)

		{
			err = mj.LoadBalancer.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServiceStatusbase = iota
	ffj_t_ServiceStatusno_such_key

	ffj_t_ServiceStatus_LoadBalancer
)

var ffj_key_ServiceStatus_LoadBalancer = []byte("loadBalancer")

func (uj *ServiceStatus) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServiceStatus) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServiceStatusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServiceStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_ServiceStatus_LoadBalancer, kn) {
						currentKey = ffj_t_ServiceStatus_LoadBalancer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServiceStatus_LoadBalancer, kn) {
					currentKey = ffj_t_ServiceStatus_LoadBalancer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServiceStatusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServiceStatus_LoadBalancer:
					goto handle_LoadBalancer

				case ffj_t_ServiceStatusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_LoadBalancer:

	/* handler: uj.LoadBalancer type=v1.LoadBalancerStatus kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.LoadBalancer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Status) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Status) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if true {
		buf.WriteString(`"metadata":`)

		{
			err = mj.ListMeta.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}
		}

		buf.WriteByte(',')
	}
	if len(mj.Status) != 0 {
		buf.WriteString(`"status":`)
		fflib.WriteJsonString(buf, string(mj.Status))
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if len(mj.Reason) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Reason))
		buf.WriteByte(',')
	}
	if mj.Details != nil {
		if true {
			buf.WriteString(`"details":`)

			{
				err = mj.Details.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Code != 0 {
		buf.WriteString(`"code":`)
		fflib.FormatBits2(buf, uint64(mj.Code), 10, mj.Code < 0)
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Statusbase = iota
	ffj_t_Statusno_such_key

	ffj_t_Status_ListMeta

	ffj_t_Status_Status

	ffj_t_Status_Message

	ffj_t_Status_Reason

	ffj_t_Status_Details

	ffj_t_Status_Code

	ffj_t_Status_Kind

	ffj_t_Status_APIVersion
)

var ffj_key_Status_ListMeta = []byte("metadata")

var ffj_key_Status_Status = []byte("status")

var ffj_key_Status_Message = []byte("message")

var ffj_key_Status_Reason = []byte("reason")

var ffj_key_Status_Details = []byte("details")

var ffj_key_Status_Code = []byte("code")

var ffj_key_Status_Kind = []byte("kind")

var ffj_key_Status_APIVersion = []byte("apiVersion")

func (uj *Status) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Status) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Statusbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Statusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Status_APIVersion, kn) {
						currentKey = ffj_t_Status_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Status_Code, kn) {
						currentKey = ffj_t_Status_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Status_Details, kn) {
						currentKey = ffj_t_Status_Details
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Status_Kind, kn) {
						currentKey = ffj_t_Status_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Status_ListMeta, kn) {
						currentKey = ffj_t_Status_ListMeta
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Status_Message, kn) {
						currentKey = ffj_t_Status_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Status_Reason, kn) {
						currentKey = ffj_t_Status_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Status_Status, kn) {
						currentKey = ffj_t_Status_Status
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Status_APIVersion, kn) {
					currentKey = ffj_t_Status_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Status_Kind, kn) {
					currentKey = ffj_t_Status_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Status_Code, kn) {
					currentKey = ffj_t_Status_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Status_Details, kn) {
					currentKey = ffj_t_Status_Details
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Status_Reason, kn) {
					currentKey = ffj_t_Status_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Status_Message, kn) {
					currentKey = ffj_t_Status_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Status_Status, kn) {
					currentKey = ffj_t_Status_Status
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Status_ListMeta, kn) {
					currentKey = ffj_t_Status_ListMeta
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Statusno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Status_ListMeta:
					goto handle_ListMeta

				case ffj_t_Status_Status:
					goto handle_Status

				case ffj_t_Status_Message:
					goto handle_Message

				case ffj_t_Status_Reason:
					goto handle_Reason

				case ffj_t_Status_Details:
					goto handle_Details

				case ffj_t_Status_Code:
					goto handle_Code

				case ffj_t_Status_Kind:
					goto handle_Kind

				case ffj_t_Status_APIVersion:
					goto handle_APIVersion

				case ffj_t_Statusno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ListMeta:

	/* handler: uj.ListMeta type=v1.ListMeta kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ListMeta.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: uj.Status type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Status = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=v1.StatusReason kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for StatusReason", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Reason = StatusReason(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Details:

	/* handler: uj.Details type=v1.StatusDetails kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Details = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Details == nil {
			uj.Details = new(StatusDetails)
		}

		err = uj.Details.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Code:

	/* handler: uj.Code type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Code = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *StatusCause) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *StatusCause) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Type) != 0 {
		buf.WriteString(`"reason":`)
		fflib.WriteJsonString(buf, string(mj.Type))
		buf.WriteByte(',')
	}
	if len(mj.Message) != 0 {
		buf.WriteString(`"message":`)
		fflib.WriteJsonString(buf, string(mj.Message))
		buf.WriteByte(',')
	}
	if len(mj.Field) != 0 {
		buf.WriteString(`"field":`)
		fflib.WriteJsonString(buf, string(mj.Field))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_StatusCausebase = iota
	ffj_t_StatusCauseno_such_key

	ffj_t_StatusCause_Type

	ffj_t_StatusCause_Message

	ffj_t_StatusCause_Field
)

var ffj_key_StatusCause_Type = []byte("reason")

var ffj_key_StatusCause_Message = []byte("message")

var ffj_key_StatusCause_Field = []byte("field")

func (uj *StatusCause) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *StatusCause) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_StatusCausebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_StatusCauseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_StatusCause_Field, kn) {
						currentKey = ffj_t_StatusCause_Field
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_StatusCause_Message, kn) {
						currentKey = ffj_t_StatusCause_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_StatusCause_Type, kn) {
						currentKey = ffj_t_StatusCause_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_StatusCause_Field, kn) {
					currentKey = ffj_t_StatusCause_Field
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_StatusCause_Message, kn) {
					currentKey = ffj_t_StatusCause_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_StatusCause_Type, kn) {
					currentKey = ffj_t_StatusCause_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_StatusCauseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_StatusCause_Type:
					goto handle_Type

				case ffj_t_StatusCause_Message:
					goto handle_Message

				case ffj_t_StatusCause_Field:
					goto handle_Field

				case ffj_t_StatusCauseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=v1.CauseType kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for CauseType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Type = CauseType(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Message = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Field:

	/* handler: uj.Field type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Field = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *StatusDetails) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *StatusDetails) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Name) != 0 {
		buf.WriteString(`"name":`)
		fflib.WriteJsonString(buf, string(mj.Name))
		buf.WriteByte(',')
	}
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.Causes) != 0 {
		buf.WriteString(`"causes":`)
		if mj.Causes != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Causes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{
					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}
				}

			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.RetryAfterSeconds != 0 {
		buf.WriteString(`"retryAfterSeconds":`)
		fflib.FormatBits2(buf, uint64(mj.RetryAfterSeconds), 10, mj.RetryAfterSeconds < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_StatusDetailsbase = iota
	ffj_t_StatusDetailsno_such_key

	ffj_t_StatusDetails_Name

	ffj_t_StatusDetails_Kind

	ffj_t_StatusDetails_Causes

	ffj_t_StatusDetails_RetryAfterSeconds
)

var ffj_key_StatusDetails_Name = []byte("name")

var ffj_key_StatusDetails_Kind = []byte("kind")

var ffj_key_StatusDetails_Causes = []byte("causes")

var ffj_key_StatusDetails_RetryAfterSeconds = []byte("retryAfterSeconds")

func (uj *StatusDetails) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *StatusDetails) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_StatusDetailsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_StatusDetailsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_StatusDetails_Causes, kn) {
						currentKey = ffj_t_StatusDetails_Causes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_StatusDetails_Kind, kn) {
						currentKey = ffj_t_StatusDetails_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_StatusDetails_Name, kn) {
						currentKey = ffj_t_StatusDetails_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_StatusDetails_RetryAfterSeconds, kn) {
						currentKey = ffj_t_StatusDetails_RetryAfterSeconds
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_StatusDetails_RetryAfterSeconds, kn) {
					currentKey = ffj_t_StatusDetails_RetryAfterSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_StatusDetails_Causes, kn) {
					currentKey = ffj_t_StatusDetails_Causes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_StatusDetails_Kind, kn) {
					currentKey = ffj_t_StatusDetails_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_StatusDetails_Name, kn) {
					currentKey = ffj_t_StatusDetails_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_StatusDetailsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_StatusDetails_Name:
					goto handle_Name

				case ffj_t_StatusDetails_Kind:
					goto handle_Kind

				case ffj_t_StatusDetails_Causes:
					goto handle_Causes

				case ffj_t_StatusDetails_RetryAfterSeconds:
					goto handle_RetryAfterSeconds

				case ffj_t_StatusDetailsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Causes:

	/* handler: uj.Causes type=[]v1.StatusCause kind=slice */

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Causes = nil
		} else {

			uj.Causes = make([]StatusCause, 0)

			wantVal := true

			for {

				var v StatusCause

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: v type=v1.StatusCause kind=struct */

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = v.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Causes = append(uj.Causes, v)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RetryAfterSeconds:

	/* handler: uj.RetryAfterSeconds type=int kind=int */

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.RetryAfterSeconds = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TCPSocketAction) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TCPSocketAction) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"port":`)

	{
		obj, err = mj.Port.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)
	}

	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TCPSocketActionbase = iota
	ffj_t_TCPSocketActionno_such_key

	ffj_t_TCPSocketAction_Port
)

var ffj_key_TCPSocketAction_Port = []byte("port")

func (uj *TCPSocketAction) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TCPSocketAction) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TCPSocketActionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TCPSocketActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_TCPSocketAction_Port, kn) {
						currentKey = ffj_t_TCPSocketAction_Port
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_TCPSocketAction_Port, kn) {
					currentKey = ffj_t_TCPSocketAction_Port
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TCPSocketActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TCPSocketAction_Port:
					goto handle_Port

				case ffj_t_TCPSocketActionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Port:

	/* handler: uj.Port type=util.IntOrString kind=struct */

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Port.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *TypeMeta) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *TypeMeta) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Kind) != 0 {
		buf.WriteString(`"kind":`)
		fflib.WriteJsonString(buf, string(mj.Kind))
		buf.WriteByte(',')
	}
	if len(mj.APIVersion) != 0 {
		buf.WriteString(`"apiVersion":`)
		fflib.WriteJsonString(buf, string(mj.APIVersion))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_TypeMetabase = iota
	ffj_t_TypeMetano_such_key

	ffj_t_TypeMeta_Kind

	ffj_t_TypeMeta_APIVersion
)

var ffj_key_TypeMeta_Kind = []byte("kind")

var ffj_key_TypeMeta_APIVersion = []byte("apiVersion")

func (uj *TypeMeta) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *TypeMeta) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_TypeMetabase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_TypeMetano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_TypeMeta_APIVersion, kn) {
						currentKey = ffj_t_TypeMeta_APIVersion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_TypeMeta_Kind, kn) {
						currentKey = ffj_t_TypeMeta_Kind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_TypeMeta_APIVersion, kn) {
					currentKey = ffj_t_TypeMeta_APIVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_TypeMeta_Kind, kn) {
					currentKey = ffj_t_TypeMeta_Kind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_TypeMetano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_TypeMeta_Kind:
					goto handle_Kind

				case ffj_t_TypeMeta_APIVersion:
					goto handle_APIVersion

				case ffj_t_TypeMetano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Kind:

	/* handler: uj.Kind type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Kind = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_APIVersion:

	/* handler: uj.APIVersion type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.APIVersion = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Volume) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Volume) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.HostPath != nil {
		if true {
			buf.WriteString(`"hostPath":`)

			{
				err = mj.HostPath.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.EmptyDir != nil {
		if true {
			buf.WriteString(`"emptyDir":`)

			{
				err = mj.EmptyDir.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.GCEPersistentDisk != nil {
		if true {
			buf.WriteString(`"gcePersistentDisk":`)

			{
				err = mj.GCEPersistentDisk.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.AWSElasticBlockStore != nil {
		if true {
			buf.WriteString(`"awsElasticBlockStore":`)

			{
				err = mj.AWSElasticBlockStore.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.GitRepo != nil {
		if true {
			buf.WriteString(`"gitRepo":`)

			{
				err = mj.GitRepo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Secret != nil {
		if true {
			buf.WriteString(`"secret":`)

			{
				err = mj.Secret.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.NFS != nil {
		if true {
			buf.WriteString(`"nfs":`)

			{
				err = mj.NFS.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.ISCSI != nil {
		if true {
			buf.WriteString(`"iscsi":`)

			{
				err = mj.ISCSI.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Glusterfs != nil {
		if true {
			buf.WriteString(`"glusterfs":`)

			{
				err = mj.Glusterfs.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.PersistentVolumeClaimVolumeSource != nil {
		if true {
			buf.WriteString(`"persistentVolumeClaim":`)

			{
				err = mj.PersistentVolumeClaimVolumeSource.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.RBD != nil {
		if true {
			buf.WriteString(`"rbd":`)

			{
				err = mj.RBD.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Volumebase = iota
	ffj_t_Volumeno_such_key

	ffj_t_Volume_Name

	ffj_t_Volume_HostPath

	ffj_t_Volume_EmptyDir

	ffj_t_Volume_GCEPersistentDisk

	ffj_t_Volume_AWSElasticBlockStore

	ffj_t_Volume_GitRepo

	ffj_t_Volume_Secret

	ffj_t_Volume_NFS

	ffj_t_Volume_ISCSI

	ffj_t_Volume_Glusterfs

	ffj_t_Volume_PersistentVolumeClaimVolumeSource

	ffj_t_Volume_RBD
)

var ffj_key_Volume_Name = []byte("name")

var ffj_key_Volume_HostPath = []byte("hostPath")

var ffj_key_Volume_EmptyDir = []byte("emptyDir")

var ffj_key_Volume_GCEPersistentDisk = []byte("gcePersistentDisk")

var ffj_key_Volume_AWSElasticBlockStore = []byte("awsElasticBlockStore")

var ffj_key_Volume_GitRepo = []byte("gitRepo")

var ffj_key_Volume_Secret = []byte("secret")

var ffj_key_Volume_NFS = []byte("nfs")

var ffj_key_Volume_ISCSI = []byte("iscsi")

var ffj_key_Volume_Glusterfs = []byte("glusterfs")

var ffj_key_Volume_PersistentVolumeClaimVolumeSource = []byte("persistentVolumeClaim")

var ffj_key_Volume_RBD = []byte("rbd")

func (uj *Volume) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Volume) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Volumebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Volumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Volume_AWSElasticBlockStore, kn) {
						currentKey = ffj_t_Volume_AWSElasticBlockStore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Volume_EmptyDir, kn) {
						currentKey = ffj_t_Volume_EmptyDir
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_Volume_GCEPersistentDisk, kn) {
						currentKey = ffj_t_Volume_GCEPersistentDisk
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Volume_GitRepo, kn) {
						currentKey = ffj_t_Volume_GitRepo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Volume_Glusterfs, kn) {
						currentKey = ffj_t_Volume_Glusterfs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Volume_HostPath, kn) {
						currentKey = ffj_t_Volume_HostPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Volume_ISCSI, kn) {
						currentKey = ffj_t_Volume_ISCSI
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Volume_Name, kn) {
						currentKey = ffj_t_Volume_Name
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Volume_NFS, kn) {
						currentKey = ffj_t_Volume_NFS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Volume_PersistentVolumeClaimVolumeSource, kn) {
						currentKey = ffj_t_Volume_PersistentVolumeClaimVolumeSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Volume_RBD, kn) {
						currentKey = ffj_t_Volume_RBD
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Volume_Secret, kn) {
						currentKey = ffj_t_Volume_Secret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_RBD, kn) {
					currentKey = ffj_t_Volume_RBD
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_PersistentVolumeClaimVolumeSource, kn) {
					currentKey = ffj_t_Volume_PersistentVolumeClaimVolumeSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_Glusterfs, kn) {
					currentKey = ffj_t_Volume_Glusterfs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_ISCSI, kn) {
					currentKey = ffj_t_Volume_ISCSI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_NFS, kn) {
					currentKey = ffj_t_Volume_NFS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_Secret, kn) {
					currentKey = ffj_t_Volume_Secret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_GitRepo, kn) {
					currentKey = ffj_t_Volume_GitRepo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_AWSElasticBlockStore, kn) {
					currentKey = ffj_t_Volume_AWSElasticBlockStore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_GCEPersistentDisk, kn) {
					currentKey = ffj_t_Volume_GCEPersistentDisk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_EmptyDir, kn) {
					currentKey = ffj_t_Volume_EmptyDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Volume_HostPath, kn) {
					currentKey = ffj_t_Volume_HostPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Volume_Name, kn) {
					currentKey = ffj_t_Volume_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Volumeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Volume_Name:
					goto handle_Name

				case ffj_t_Volume_HostPath:
					goto handle_HostPath

				case ffj_t_Volume_EmptyDir:
					goto handle_EmptyDir

				case ffj_t_Volume_GCEPersistentDisk:
					goto handle_GCEPersistentDisk

				case ffj_t_Volume_AWSElasticBlockStore:
					goto handle_AWSElasticBlockStore

				case ffj_t_Volume_GitRepo:
					goto handle_GitRepo

				case ffj_t_Volume_Secret:
					goto handle_Secret

				case ffj_t_Volume_NFS:
					goto handle_NFS

				case ffj_t_Volume_ISCSI:
					goto handle_ISCSI

				case ffj_t_Volume_Glusterfs:
					goto handle_Glusterfs

				case ffj_t_Volume_PersistentVolumeClaimVolumeSource:
					goto handle_PersistentVolumeClaimVolumeSource

				case ffj_t_Volume_RBD:
					goto handle_RBD

				case ffj_t_Volumeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostPath:

	/* handler: uj.HostPath type=v1.HostPathVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.HostPath = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HostPath == nil {
			uj.HostPath = new(HostPathVolumeSource)
		}

		err = uj.HostPath.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmptyDir:

	/* handler: uj.EmptyDir type=v1.EmptyDirVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.EmptyDir = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.EmptyDir == nil {
			uj.EmptyDir = new(EmptyDirVolumeSource)
		}

		err = uj.EmptyDir.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GCEPersistentDisk:

	/* handler: uj.GCEPersistentDisk type=v1.GCEPersistentDiskVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.GCEPersistentDisk = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GCEPersistentDisk == nil {
			uj.GCEPersistentDisk = new(GCEPersistentDiskVolumeSource)
		}

		err = uj.GCEPersistentDisk.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AWSElasticBlockStore:

	/* handler: uj.AWSElasticBlockStore type=v1.AWSElasticBlockStoreVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.AWSElasticBlockStore = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AWSElasticBlockStore == nil {
			uj.AWSElasticBlockStore = new(AWSElasticBlockStoreVolumeSource)
		}

		err = uj.AWSElasticBlockStore.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GitRepo:

	/* handler: uj.GitRepo type=v1.GitRepoVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.GitRepo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GitRepo == nil {
			uj.GitRepo = new(GitRepoVolumeSource)
		}

		err = uj.GitRepo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: uj.Secret type=v1.SecretVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Secret = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Secret == nil {
			uj.Secret = new(SecretVolumeSource)
		}

		err = uj.Secret.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NFS:

	/* handler: uj.NFS type=v1.NFSVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.NFS = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NFS == nil {
			uj.NFS = new(NFSVolumeSource)
		}

		err = uj.NFS.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ISCSI:

	/* handler: uj.ISCSI type=v1.ISCSIVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ISCSI = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ISCSI == nil {
			uj.ISCSI = new(ISCSIVolumeSource)
		}

		err = uj.ISCSI.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Glusterfs:

	/* handler: uj.Glusterfs type=v1.GlusterfsVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Glusterfs = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Glusterfs == nil {
			uj.Glusterfs = new(GlusterfsVolumeSource)
		}

		err = uj.Glusterfs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PersistentVolumeClaimVolumeSource:

	/* handler: uj.PersistentVolumeClaimVolumeSource type=v1.PersistentVolumeClaimVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.PersistentVolumeClaimVolumeSource = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PersistentVolumeClaimVolumeSource == nil {
			uj.PersistentVolumeClaimVolumeSource = new(PersistentVolumeClaimVolumeSource)
		}

		err = uj.PersistentVolumeClaimVolumeSource.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RBD:

	/* handler: uj.RBD type=v1.RBDVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.RBD = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RBD == nil {
			uj.RBD = new(RBDVolumeSource)
		}

		err = uj.RBD.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *VolumeMount) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *VolumeMount) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte(',')
	if mj.ReadOnly != false {
		if mj.ReadOnly {
			buf.WriteString(`"readOnly":true`)
		} else {
			buf.WriteString(`"readOnly":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"mountPath":`)
	fflib.WriteJsonString(buf, string(mj.MountPath))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_VolumeMountbase = iota
	ffj_t_VolumeMountno_such_key

	ffj_t_VolumeMount_Name

	ffj_t_VolumeMount_ReadOnly

	ffj_t_VolumeMount_MountPath
)

var ffj_key_VolumeMount_Name = []byte("name")

var ffj_key_VolumeMount_ReadOnly = []byte("readOnly")

var ffj_key_VolumeMount_MountPath = []byte("mountPath")

func (uj *VolumeMount) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *VolumeMount) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_VolumeMountbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_VolumeMountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_VolumeMount_MountPath, kn) {
						currentKey = ffj_t_VolumeMount_MountPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_VolumeMount_Name, kn) {
						currentKey = ffj_t_VolumeMount_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_VolumeMount_ReadOnly, kn) {
						currentKey = ffj_t_VolumeMount_ReadOnly
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_VolumeMount_MountPath, kn) {
					currentKey = ffj_t_VolumeMount_MountPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_VolumeMount_ReadOnly, kn) {
					currentKey = ffj_t_VolumeMount_ReadOnly
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_VolumeMount_Name, kn) {
					currentKey = ffj_t_VolumeMount_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_VolumeMountno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_VolumeMount_Name:
					goto handle_Name

				case ffj_t_VolumeMount_ReadOnly:
					goto handle_ReadOnly

				case ffj_t_VolumeMount_MountPath:
					goto handle_MountPath

				case ffj_t_VolumeMountno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.Name = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadOnly:

	/* handler: uj.ReadOnly type=bool kind=bool */

	{

		{
			if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ReadOnly = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ReadOnly = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MountPath:

	/* handler: uj.MountPath type=string kind=string */

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			uj.MountPath = string(fs.Output.String())

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *VolumeSource) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *VolumeSource) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.HostPath != nil {
		if true {
			buf.WriteString(`"hostPath":`)

			{
				err = mj.HostPath.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.EmptyDir != nil {
		if true {
			buf.WriteString(`"emptyDir":`)

			{
				err = mj.EmptyDir.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.GCEPersistentDisk != nil {
		if true {
			buf.WriteString(`"gcePersistentDisk":`)

			{
				err = mj.GCEPersistentDisk.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.AWSElasticBlockStore != nil {
		if true {
			buf.WriteString(`"awsElasticBlockStore":`)

			{
				err = mj.AWSElasticBlockStore.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.GitRepo != nil {
		if true {
			buf.WriteString(`"gitRepo":`)

			{
				err = mj.GitRepo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Secret != nil {
		if true {
			buf.WriteString(`"secret":`)

			{
				err = mj.Secret.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.NFS != nil {
		if true {
			buf.WriteString(`"nfs":`)

			{
				err = mj.NFS.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.ISCSI != nil {
		if true {
			buf.WriteString(`"iscsi":`)

			{
				err = mj.ISCSI.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.Glusterfs != nil {
		if true {
			buf.WriteString(`"glusterfs":`)

			{
				err = mj.Glusterfs.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.PersistentVolumeClaimVolumeSource != nil {
		if true {
			buf.WriteString(`"persistentVolumeClaim":`)

			{
				err = mj.PersistentVolumeClaimVolumeSource.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	if mj.RBD != nil {
		if true {
			buf.WriteString(`"rbd":`)

			{
				err = mj.RBD.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}
			}

			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_VolumeSourcebase = iota
	ffj_t_VolumeSourceno_such_key

	ffj_t_VolumeSource_HostPath

	ffj_t_VolumeSource_EmptyDir

	ffj_t_VolumeSource_GCEPersistentDisk

	ffj_t_VolumeSource_AWSElasticBlockStore

	ffj_t_VolumeSource_GitRepo

	ffj_t_VolumeSource_Secret

	ffj_t_VolumeSource_NFS

	ffj_t_VolumeSource_ISCSI

	ffj_t_VolumeSource_Glusterfs

	ffj_t_VolumeSource_PersistentVolumeClaimVolumeSource

	ffj_t_VolumeSource_RBD
)

var ffj_key_VolumeSource_HostPath = []byte("hostPath")

var ffj_key_VolumeSource_EmptyDir = []byte("emptyDir")

var ffj_key_VolumeSource_GCEPersistentDisk = []byte("gcePersistentDisk")

var ffj_key_VolumeSource_AWSElasticBlockStore = []byte("awsElasticBlockStore")

var ffj_key_VolumeSource_GitRepo = []byte("gitRepo")

var ffj_key_VolumeSource_Secret = []byte("secret")

var ffj_key_VolumeSource_NFS = []byte("nfs")

var ffj_key_VolumeSource_ISCSI = []byte("iscsi")

var ffj_key_VolumeSource_Glusterfs = []byte("glusterfs")

var ffj_key_VolumeSource_PersistentVolumeClaimVolumeSource = []byte("persistentVolumeClaim")

var ffj_key_VolumeSource_RBD = []byte("rbd")

func (uj *VolumeSource) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *VolumeSource) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_VolumeSourcebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_VolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_VolumeSource_AWSElasticBlockStore, kn) {
						currentKey = ffj_t_VolumeSource_AWSElasticBlockStore
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_VolumeSource_EmptyDir, kn) {
						currentKey = ffj_t_VolumeSource_EmptyDir
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_VolumeSource_GCEPersistentDisk, kn) {
						currentKey = ffj_t_VolumeSource_GCEPersistentDisk
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_VolumeSource_GitRepo, kn) {
						currentKey = ffj_t_VolumeSource_GitRepo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_VolumeSource_Glusterfs, kn) {
						currentKey = ffj_t_VolumeSource_Glusterfs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_VolumeSource_HostPath, kn) {
						currentKey = ffj_t_VolumeSource_HostPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_VolumeSource_ISCSI, kn) {
						currentKey = ffj_t_VolumeSource_ISCSI
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_VolumeSource_NFS, kn) {
						currentKey = ffj_t_VolumeSource_NFS
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_VolumeSource_PersistentVolumeClaimVolumeSource, kn) {
						currentKey = ffj_t_VolumeSource_PersistentVolumeClaimVolumeSource
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_VolumeSource_RBD, kn) {
						currentKey = ffj_t_VolumeSource_RBD
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_VolumeSource_Secret, kn) {
						currentKey = ffj_t_VolumeSource_Secret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_VolumeSource_RBD, kn) {
					currentKey = ffj_t_VolumeSource_RBD
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_PersistentVolumeClaimVolumeSource, kn) {
					currentKey = ffj_t_VolumeSource_PersistentVolumeClaimVolumeSource
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_Glusterfs, kn) {
					currentKey = ffj_t_VolumeSource_Glusterfs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_ISCSI, kn) {
					currentKey = ffj_t_VolumeSource_ISCSI
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_NFS, kn) {
					currentKey = ffj_t_VolumeSource_NFS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_Secret, kn) {
					currentKey = ffj_t_VolumeSource_Secret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_VolumeSource_GitRepo, kn) {
					currentKey = ffj_t_VolumeSource_GitRepo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_AWSElasticBlockStore, kn) {
					currentKey = ffj_t_VolumeSource_AWSElasticBlockStore
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_GCEPersistentDisk, kn) {
					currentKey = ffj_t_VolumeSource_GCEPersistentDisk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_VolumeSource_EmptyDir, kn) {
					currentKey = ffj_t_VolumeSource_EmptyDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_VolumeSource_HostPath, kn) {
					currentKey = ffj_t_VolumeSource_HostPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_VolumeSourceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_VolumeSource_HostPath:
					goto handle_HostPath

				case ffj_t_VolumeSource_EmptyDir:
					goto handle_EmptyDir

				case ffj_t_VolumeSource_GCEPersistentDisk:
					goto handle_GCEPersistentDisk

				case ffj_t_VolumeSource_AWSElasticBlockStore:
					goto handle_AWSElasticBlockStore

				case ffj_t_VolumeSource_GitRepo:
					goto handle_GitRepo

				case ffj_t_VolumeSource_Secret:
					goto handle_Secret

				case ffj_t_VolumeSource_NFS:
					goto handle_NFS

				case ffj_t_VolumeSource_ISCSI:
					goto handle_ISCSI

				case ffj_t_VolumeSource_Glusterfs:
					goto handle_Glusterfs

				case ffj_t_VolumeSource_PersistentVolumeClaimVolumeSource:
					goto handle_PersistentVolumeClaimVolumeSource

				case ffj_t_VolumeSource_RBD:
					goto handle_RBD

				case ffj_t_VolumeSourceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_HostPath:

	/* handler: uj.HostPath type=v1.HostPathVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.HostPath = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.HostPath == nil {
			uj.HostPath = new(HostPathVolumeSource)
		}

		err = uj.HostPath.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EmptyDir:

	/* handler: uj.EmptyDir type=v1.EmptyDirVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.EmptyDir = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.EmptyDir == nil {
			uj.EmptyDir = new(EmptyDirVolumeSource)
		}

		err = uj.EmptyDir.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GCEPersistentDisk:

	/* handler: uj.GCEPersistentDisk type=v1.GCEPersistentDiskVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.GCEPersistentDisk = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GCEPersistentDisk == nil {
			uj.GCEPersistentDisk = new(GCEPersistentDiskVolumeSource)
		}

		err = uj.GCEPersistentDisk.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AWSElasticBlockStore:

	/* handler: uj.AWSElasticBlockStore type=v1.AWSElasticBlockStoreVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.AWSElasticBlockStore = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AWSElasticBlockStore == nil {
			uj.AWSElasticBlockStore = new(AWSElasticBlockStoreVolumeSource)
		}

		err = uj.AWSElasticBlockStore.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GitRepo:

	/* handler: uj.GitRepo type=v1.GitRepoVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.GitRepo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GitRepo == nil {
			uj.GitRepo = new(GitRepoVolumeSource)
		}

		err = uj.GitRepo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Secret:

	/* handler: uj.Secret type=v1.SecretVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Secret = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Secret == nil {
			uj.Secret = new(SecretVolumeSource)
		}

		err = uj.Secret.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NFS:

	/* handler: uj.NFS type=v1.NFSVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.NFS = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NFS == nil {
			uj.NFS = new(NFSVolumeSource)
		}

		err = uj.NFS.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ISCSI:

	/* handler: uj.ISCSI type=v1.ISCSIVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.ISCSI = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ISCSI == nil {
			uj.ISCSI = new(ISCSIVolumeSource)
		}

		err = uj.ISCSI.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Glusterfs:

	/* handler: uj.Glusterfs type=v1.GlusterfsVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.Glusterfs = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Glusterfs == nil {
			uj.Glusterfs = new(GlusterfsVolumeSource)
		}

		err = uj.Glusterfs.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PersistentVolumeClaimVolumeSource:

	/* handler: uj.PersistentVolumeClaimVolumeSource type=v1.PersistentVolumeClaimVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.PersistentVolumeClaimVolumeSource = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PersistentVolumeClaimVolumeSource == nil {
			uj.PersistentVolumeClaimVolumeSource = new(PersistentVolumeClaimVolumeSource)
		}

		err = uj.PersistentVolumeClaimVolumeSource.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RBD:

	/* handler: uj.RBD type=v1.RBDVolumeSource kind=struct */

	{
		if tok == fflib.FFTok_null {

			uj.RBD = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RBD == nil {
			uj.RBD = new(RBDVolumeSource)
		}

		err = uj.RBD.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
