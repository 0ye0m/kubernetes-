/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	componentbaseconfig "k8s.io/component-base/config"
	componentbaseconfigv1alpha1 "k8s.io/component-base/config/v1alpha1"
	v1alpha1 "k8s.io/component-base/config/v1alpha1"
	v1 "k8s.io/kube-scheduler/config/v1"
	"k8s.io/kube-scheduler/config/v1beta2"
	"k8s.io/kubernetes/pkg/scheduler/apis/config"
	"k8s.io/kubernetes/pkg/scheduler/framework/plugins/names"
	"k8s.io/utils/pointer"
)

type CustomPluginArgs struct {
	metav1.TypeMeta
	A string
	B string
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CustomPluginArgs) DeepCopyInto(out *CustomPluginArgs) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DefaultPreemptionArgs.
func (in *CustomPluginArgs) DeepCopy() *CustomPluginArgs {
	if in == nil {
		return nil
	}
	out := new(CustomPluginArgs)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CustomPluginArgs) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func Test_Convert_v1beta2_KubeSchedulerConfiguration_To_config_KubeSchedulerConfiguration(t *testing.T) {
	testcases := []struct {
		name    string
		in      v1beta2.KubeSchedulerConfiguration
		out     config.KubeSchedulerConfiguration
		want    config.KubeSchedulerConfiguration
		wantErr string
	}{
		{
			name: "fully configured KubeSchedulerConfiguration",
			in: v1beta2.KubeSchedulerConfiguration{
				TypeMeta: metav1.TypeMeta{
					Kind:       "KubeSchedulerConfiguration",
					APIVersion: "kubescheduler.config.k8s.io/v1beta2",
				},
				Parallelism: pointer.Int32Ptr(18),
				LeaderElection: componentbaseconfigv1alpha1.LeaderElectionConfiguration{
					LeaderElect: pointer.BoolPtr(false),
				},
				ClientConnection: componentbaseconfigv1alpha1.ClientConnectionConfiguration{
					ContentType:        runtime.ContentTypeProtobuf,
					AcceptContentTypes: runtime.ContentTypeProtobuf,
				},
				HealthzBindAddress:       pointer.StringPtr("0.0.0.0:10251"),
				MetricsBindAddress:       pointer.StringPtr("0.0.0.0:10251"),
				PercentageOfNodesToScore: pointer.Int32Ptr(25),
				PodMaxBackoffSeconds:     pointer.Int64Ptr(30),
				PodInitialBackoffSeconds: pointer.Int64Ptr(2),
				Profiles: []v1beta2.KubeSchedulerProfile{
					{
						SchedulerName: pointer.StringPtr("test-scheduler"),
						Plugins: &v1beta2.Plugins{
							QueueSort: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.PrioritySort},
								},
							},
							PreFilter: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.NodeResourcesFit},
								},
							},
							Filter: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.NodeUnschedulable},
								},
							},
							PostFilter: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.DefaultPreemption},
								},
							},
							PreScore: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.InterPodAffinity},
								},
							},
							Score: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.NodeResourcesBalancedAllocation, Weight: pointer.Int32Ptr(1)},
								},
							},
							Reserve: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.VolumeBinding},
								},
							},
							PreBind: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.VolumeBinding},
								},
							},
							Bind: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.DefaultBinder},
								},
							},
						},
						PluginConfig: []v1beta2.PluginConfig{
							{
								Name: names.DefaultPreemption,
								Args: runtime.RawExtension{
									Object: &v1beta2.DefaultPreemptionArgs{
										MinCandidateNodesPercentage: pointer.Int32Ptr(10),
										MinCandidateNodesAbsolute:   pointer.Int32Ptr(100),
									},
								},
							},
						},
					},
				},
				Extenders: []v1beta2.Extender{
					{
						URLPrefix:      "/extender-test",
						FilterVerb:     "filter",
						PrioritizeVerb: "prioritize",
						Weight:         1,
						BindVerb:       "bind",
						EnableHTTPS:    true,
						TLSConfig:      &v1.ExtenderTLSConfig{},
					},
				},
			},
			out: config.KubeSchedulerConfiguration{},
			want: config.KubeSchedulerConfiguration{
				Parallelism: 18,
				LeaderElection: componentbaseconfig.LeaderElectionConfiguration{
					LeaderElect: false,
				},
				ClientConnection: componentbaseconfig.ClientConnectionConfiguration{
					ContentType:        runtime.ContentTypeProtobuf,
					AcceptContentTypes: runtime.ContentTypeProtobuf,
				},
				HealthzBindAddress:       "0.0.0.0:10251",
				MetricsBindAddress:       "0.0.0.0:10251",
				PercentageOfNodesToScore: 25,
				PodMaxBackoffSeconds:     30,
				PodInitialBackoffSeconds: 2,
				Profiles: []config.KubeSchedulerProfile{
					{
						SchedulerName: "test-scheduler",
						Plugins: &config.Plugins{
							QueueSort: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.PrioritySort},
								},
							},
							PreFilter: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.NodeResourcesFit},
								},
							},
							Filter: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.NodeUnschedulable},
								},
							},
							PostFilter: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.DefaultPreemption},
								},
							},
							PreScore: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.InterPodAffinity},
								},
							},
							Score: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.NodeResourcesBalancedAllocation, Weight: 1},
								},
							},
							Reserve: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.VolumeBinding},
								},
							},
							PreBind: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.VolumeBinding},
								},
							},
							Bind: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.DefaultBinder},
								},
							},
						},
						PluginConfig: []config.PluginConfig{
							{
								Name: "DefaultPreemption",
								Args: &config.DefaultPreemptionArgs{
									MinCandidateNodesPercentage: 10,
									MinCandidateNodesAbsolute:   100,
								},
							},
						},
					},
				},
				Extenders: []config.Extender{
					{
						URLPrefix:      "/extender-test",
						FilterVerb:     "filter",
						PrioritizeVerb: "prioritize",
						Weight:         1,
						BindVerb:       "bind",
						EnableHTTPS:    true,
						TLSConfig:      &config.ExtenderTLSConfig{},
					},
				},
			},
			wantErr: "",
		},
		{
			name: "config PluginConfig incorrectly",
			in: v1beta2.KubeSchedulerConfiguration{
				Profiles: []v1beta2.KubeSchedulerProfile{
					{
						SchedulerName: pointer.StringPtr("test-scheduler"),
						Plugins:       &v1beta2.Plugins{},
						PluginConfig: []v1beta2.PluginConfig{
							{
								Name: "ErrorPreemption",
								Args: runtime.RawExtension{
									Object: &CustomPluginArgs{
										A: "",
										B: "",
									},
								},
							},
						},
					},
				},
			},
			out: config.KubeSchedulerConfiguration{},
			want: config.KubeSchedulerConfiguration{
				Profiles: []config.KubeSchedulerProfile{
					{
						SchedulerName: "test-scheduler",
						Plugins:       &config.Plugins{},
						PluginConfig: []config.PluginConfig{
							{
								Name: "ErrorPreemption",
								Args: &CustomPluginArgs{},
							},
						},
					},
				},
			},
			wantErr: "no kind is registered for the type",
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			err := Convert_v1beta2_KubeSchedulerConfiguration_To_config_KubeSchedulerConfiguration(&tc.in, &tc.out, nil)
			if diff := cmp.Diff(tc.out, tc.want); diff != "" {
				t.Errorf("failed to convert: %+v", diff)
			}
			if tc.wantErr != "" && !strings.Contains(err.Error(), tc.wantErr) {
				t.Errorf("expect return error: %v, got: %v", tc.wantErr, err)
			}
		})
	}
}

func Test_Convert_config_KubeSchedulerConfiguration_To_v1beta2_KubeSchedulerConfiguration(t *testing.T) {
	testcases := []struct {
		name    string
		in      config.KubeSchedulerConfiguration
		out     v1beta2.KubeSchedulerConfiguration
		want    v1beta2.KubeSchedulerConfiguration
		wantErr string
	}{
		{
			name: "fully configured KubeSchedulerConfiguration",
			in: config.KubeSchedulerConfiguration{
				Parallelism: 18,
				LeaderElection: componentbaseconfig.LeaderElectionConfiguration{
					LeaderElect: false,
				},
				ClientConnection: componentbaseconfig.ClientConnectionConfiguration{
					ContentType:        runtime.ContentTypeProtobuf,
					AcceptContentTypes: runtime.ContentTypeProtobuf,
				},
				HealthzBindAddress:       "0.0.0.0:10251",
				MetricsBindAddress:       "0.0.0.0:10251",
				PercentageOfNodesToScore: 25,
				PodMaxBackoffSeconds:     30,
				PodInitialBackoffSeconds: 2,
				Profiles: []config.KubeSchedulerProfile{
					{
						SchedulerName: "test-scheduler",
						Plugins: &config.Plugins{
							QueueSort: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.PrioritySort},
								},
							},
							PreFilter: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.NodeResourcesFit},
								},
							},
							Filter: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.NodeUnschedulable},
								},
							},
							PostFilter: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.DefaultPreemption},
								},
							},
							PreScore: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.InterPodAffinity},
								},
							},
							Score: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.NodeResourcesBalancedAllocation, Weight: 1},
								},
							},
							Reserve: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.VolumeBinding},
								},
							},
							PreBind: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.VolumeBinding},
								},
							},
							Bind: config.PluginSet{
								Enabled: []config.Plugin{
									{Name: names.DefaultBinder},
								},
							},
						},
						PluginConfig: []config.PluginConfig{
							{
								Name: "DefaultPreemption",
								Args: &config.DefaultPreemptionArgs{
									MinCandidateNodesPercentage: 10,
									MinCandidateNodesAbsolute:   100,
								},
							},
						},
					},
				},
			},
			out: v1beta2.KubeSchedulerConfiguration{},
			want: v1beta2.KubeSchedulerConfiguration{
				Parallelism: pointer.Int32Ptr(18),
				LeaderElection: componentbaseconfigv1alpha1.LeaderElectionConfiguration{
					LeaderElect: pointer.BoolPtr(false),
				},
				ClientConnection: componentbaseconfigv1alpha1.ClientConnectionConfiguration{
					ContentType:        runtime.ContentTypeProtobuf,
					AcceptContentTypes: runtime.ContentTypeProtobuf,
				},
				HealthzBindAddress: pointer.StringPtr("0.0.0.0:10251"),
				MetricsBindAddress: pointer.StringPtr("0.0.0.0:10251"),
				DebuggingConfiguration: v1alpha1.DebuggingConfiguration{
					EnableProfiling:           pointer.BoolPtr(false),
					EnableContentionProfiling: pointer.BoolPtr(false),
				},
				PercentageOfNodesToScore: pointer.Int32Ptr(25),
				PodInitialBackoffSeconds: pointer.Int64Ptr(2),
				PodMaxBackoffSeconds:     pointer.Int64Ptr(30),
				Profiles: []v1beta2.KubeSchedulerProfile{
					{
						SchedulerName: pointer.StringPtr("test-scheduler"),
						Plugins: &v1beta2.Plugins{
							QueueSort: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.PrioritySort, Weight: pointer.Int32Ptr(0)},
								},
							},
							PreFilter: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.NodeResourcesFit, Weight: pointer.Int32Ptr(0)},
								},
							},
							Filter: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.NodeUnschedulable, Weight: pointer.Int32Ptr(0)},
								},
							},
							PostFilter: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.DefaultPreemption, Weight: pointer.Int32Ptr(0)},
								},
							},
							PreScore: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.InterPodAffinity, Weight: pointer.Int32Ptr(0)},
								},
							},
							Score: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.NodeResourcesBalancedAllocation, Weight: pointer.Int32Ptr(1)},
								},
							},
							Reserve: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.VolumeBinding, Weight: pointer.Int32Ptr(0)},
								},
							},
							PreBind: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.VolumeBinding, Weight: pointer.Int32Ptr(0)},
								},
							},
							Bind: v1beta2.PluginSet{
								Enabled: []v1beta2.Plugin{
									{Name: names.DefaultBinder, Weight: pointer.Int32Ptr(0)},
								},
							},
						},
						PluginConfig: []v1beta2.PluginConfig{
							{
								Name: names.DefaultPreemption,
								Args: runtime.RawExtension{
									Object: &v1beta2.DefaultPreemptionArgs{
										TypeMeta: metav1.TypeMeta{
											Kind:       "DefaultPreemptionArgs",
											APIVersion: "kubescheduler.config.k8s.io/v1beta2",
										},
										MinCandidateNodesPercentage: pointer.Int32Ptr(10),
										MinCandidateNodesAbsolute:   pointer.Int32Ptr(100),
									},
								},
							},
						},
					},
				},
			},
			wantErr: "",
		},
	}

	for _, tc := range testcases {
		err := Convert_config_KubeSchedulerConfiguration_To_v1beta2_KubeSchedulerConfiguration(&tc.in, &tc.out, nil)
		if diff := cmp.Diff(tc.out, tc.want); diff != "" {
			t.Errorf("failed to convert: %+v", diff)
		}
		if tc.wantErr != "" && strings.Contains(err.Error(), tc.wantErr) {
			t.Errorf("expect return error: %+v, got: %+v", tc.wantErr, err)
		}
	}
}
